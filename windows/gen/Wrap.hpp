
template <template <class, class...> class, class, class, class, class = void>
struct pop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedPoolManager {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedPoolManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedPoolManager))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedPoolManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedPoolManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedPoolManager))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedPoolManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct update {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct update<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::update))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::update(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct update<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::update))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::update(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setScaleX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setScaleY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setVisible {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVisible))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVisible))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFlipX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFlipX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFlipX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFlipX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFlipX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFlipY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFlipY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFlipY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFlipY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFlipY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRealPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRealPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRealPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRealPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRealPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRealPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRealPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOrientedBox {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedBox))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedBox))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animationFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animationFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animationFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animationFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animationFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animationFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animationFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activateStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activateStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activateStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addAllParticles {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllParticles))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllParticles))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToTouchedRings {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToTouchedRings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTouchedRings))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToTouchedRings(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToTouchedRings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTouchedRings))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToTouchedRings(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct boostPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct boostPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boostPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::boostPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct boostPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boostPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::boostPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct bumpPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct bumpPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bumpPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::bumpPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct bumpPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bumpPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::bumpPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct buttonDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct buttonDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::buttonDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::buttonDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct buttonDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::buttonDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::buttonDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct checkSnapJumpToObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkSnapJumpToObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSnapJumpToObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::checkSnapJumpToObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkSnapJumpToObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSnapJumpToObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::checkSnapJumpToObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct collidedWithObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::collidedWithObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::collidedWithObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct collidedWithSlope {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithSlope<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithSlope))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::collidedWithSlope(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithSlope<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithSlope))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::collidedWithSlope(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct convertToClosestRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToClosestRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToClosestRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::convertToClosestRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToClosestRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToClosestRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::convertToClosestRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct copyAttributes {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyAttributes<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyAttributes))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::copyAttributes(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyAttributes<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyAttributes))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::copyAttributes(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct create {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct create<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::create))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::create(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct create<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::create))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::create(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct deactivateParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::deactivateParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::deactivateParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct deactivateStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::deactivateStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::deactivateStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fadeOutStreak2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeOutStreak2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeOutStreak2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fadeOutStreak2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeOutStreak2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeOutStreak2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fadeOutStreak2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct flashPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flashPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flashPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::flashPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flashPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flashPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::flashPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct flipGravity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipGravity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipGravity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::flipGravity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipGravity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipGravity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::flipGravity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct flipMod {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipMod))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::flipMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipMod))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::flipMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getActiveMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActiveMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getActiveMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActiveMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getActiveMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getModifiedSlopeYVel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getModifiedSlopeYVel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getModifiedSlopeYVel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getModifiedSlopeYVel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getModifiedSlopeYVel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getModifiedSlopeYVel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getModifiedSlopeYVel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOldPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOldPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOldPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOldPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOldPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOldPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOldPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSecondColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecondColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSecondColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecondColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSecondColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct gravityDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::gravityDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::gravityDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct gravityUp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityUp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::gravityUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityUp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::gravityUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hardFlipGravity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hardFlipGravity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hardFlipGravity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hardFlipGravity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hardFlipGravity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hardFlipGravity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hardFlipGravity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hitGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hitGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hitGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hitGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hitGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hitGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hitGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct incrementJumps {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementJumps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementJumps))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::incrementJumps(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementJumps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementJumps))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::incrementJumps(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct init {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct init<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::init))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::init(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct init<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::init))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::init(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isBoostValid {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBoostValid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBoostValid))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isBoostValid(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBoostValid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBoostValid))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isBoostValid(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isFlying {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlying<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlying))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isFlying(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlying<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlying))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isFlying(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSafeFlip {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeFlip))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSafeFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeFlip))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSafeFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSafeMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSafeMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSafeMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSafeSpiderFlip {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeSpiderFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeSpiderFlip))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSafeSpiderFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSafeSpiderFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeSpiderFlip))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSafeSpiderFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelFlipFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelFlipFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelFlipFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelFlipping {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipping<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipping))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelFlipping(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipping<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipping))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelFlipping(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelWillFlip {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelWillFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWillFlip))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelWillFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelWillFlip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWillFlip))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelWillFlip(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFromCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFromCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFromCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct lockPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lockPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lockPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::lockPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lockPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lockPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::lockPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct logValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct logValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::logValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::logValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct logValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::logValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::logValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct modeDidChange {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct modeDidChange<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::modeDidChange))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::modeDidChange(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct modeDidChange<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::modeDidChange))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::modeDidChange(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct placeStreakPoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct placeStreakPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::placeStreakPoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::placeStreakPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct placeStreakPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::placeStreakPoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::placeStreakPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playBurstEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playBurstEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBurstEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playBurstEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playBurstEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBurstEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playBurstEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playDeathEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDeathEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDeathEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playDynamicSpiderRun {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playDynamicSpiderRun<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDynamicSpiderRun))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playDynamicSpiderRun(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playDynamicSpiderRun<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDynamicSpiderRun))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playDynamicSpiderRun(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerDestroyed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerDestroyed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDestroyed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerDestroyed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerDestroyed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDestroyed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerDestroyed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerIsFalling {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerIsFalling<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerIsFalling))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerIsFalling(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerIsFalling<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerIsFalling))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerIsFalling(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerTeleported {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTeleported<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTeleported))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerTeleported(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTeleported<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTeleported))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerTeleported(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playingEndEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playingEndEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playingEndEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playingEndEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playingEndEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playingEndEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playingEndEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct postCollision {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollision))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::postCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollision))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::postCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct preCollision {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollision))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::preCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollision))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::preCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct preSlopeCollision {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preSlopeCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preSlopeCollision))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::preSlopeCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preSlopeCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preSlopeCollision))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::preSlopeCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct propellPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct propellPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::propellPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::propellPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct propellPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::propellPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::propellPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pushButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pushButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pushButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pushDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pushDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pushDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pushPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pushPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pushPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct releaseButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct releaseButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::releaseButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::releaseButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct releaseButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::releaseButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::releaseButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllParticles {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllParticles))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllParticles))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removePendingCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removePendingCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePendingCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removePendingCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removePendingCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePendingCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removePendingCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetAllParticles {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAllParticles))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetAllParticles<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAllParticles))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetAllParticles(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetCollisionLog {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetCollisionLog<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetCollisionLog))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetCollisionLog(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetCollisionLog<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetCollisionLog))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetCollisionLog(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetPlayerIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayerIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayerIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetPlayerIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayerIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayerIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetPlayerIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetStateVariables {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetStateVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStateVariables))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetStateVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetStateVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStateVariables))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetStateVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ringJump {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ringJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ringJump))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ringJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ringJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ringJump))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ringJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runBallRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runBallRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runBallRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runBallRotation2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runBallRotation2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runBallRotation2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runNormalRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runNormalRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runNormalRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runNormalRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runNormalRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runNormalRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runNormalRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runRotateAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runRotateAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runRotateAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runRotateAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runRotateAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runRotateAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runRotateAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveToCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveToCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveToCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveToCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveToCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveToCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveToCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSecondColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSecondColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSecondColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSecondColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSecondColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSecondColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSecondColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnCircle2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnCircle2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnCircle2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnDualCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnDualCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnDualCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnDualCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnDualCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnDualCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnDualCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnFromPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnFromPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFromPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnFromPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnFromPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFromPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnFromPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnPortalCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnPortalCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPortalCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnPortalCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnPortalCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPortalCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnPortalCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnScaleCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnScaleCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnScaleCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnScaleCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnScaleCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnScaleCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnScaleCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct specialGroundHit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct specialGroundHit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::specialGroundHit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::specialGroundHit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct specialGroundHit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::specialGroundHit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::specialGroundHit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct speedDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct speedDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::speedDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct speedDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::speedDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct speedUp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct speedUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedUp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::speedUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct speedUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedUp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::speedUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spiderTestJump {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spiderTestJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spiderTestJump))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spiderTestJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spiderTestJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spiderTestJump))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spiderTestJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startDashing {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startDashing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startDashing))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startDashing(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startDashing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startDashing))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startDashing(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopBurstEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopBurstEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBurstEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopBurstEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopBurstEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBurstEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopBurstEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopDashing {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopDashing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopDashing))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopDashing(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopDashing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopDashing))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopDashing(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storeCollision {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCollision))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storeCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCollision))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storeCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct switchedToMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchedToMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchedToMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::switchedToMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchedToMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchedToMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::switchedToMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct testForMoving {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct testForMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testForMoving))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::testForMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct testForMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testForMoving))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::testForMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleBirdMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleBirdMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBirdMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleBirdMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleBirdMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBirdMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleBirdMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleDartMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleDartMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDartMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleDartMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleDartMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDartMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleDartMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleFlyMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlyMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlyMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGhostEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGhostEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGhostEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGhostEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGhostEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGhostEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGhostEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct togglePlayerScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::togglePlayerScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::togglePlayerScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleRobotMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRobotMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRobotMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleRollMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRollMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRollMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleSpiderMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSpiderMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSpiderMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct touchedObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct touchedObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touchedObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::touchedObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct touchedObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touchedObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::touchedObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct tryPlaceCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tryPlaceCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryPlaceCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::tryPlaceCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tryPlaceCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryPlaceCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::tryPlaceCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCheckpointMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCheckpointMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCheckpointMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCheckpointTest {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointTest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointTest))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCheckpointTest(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointTest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointTest))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCheckpointTest(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCollide {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollide))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCollide(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollide))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCollide(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCollideBottom {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideBottom))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCollideBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideBottom))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCollideBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCollideTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCollideTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCollideTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDashAnimation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDashAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashAnimation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDashAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDashAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashAnimation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDashAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDashArt {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDashArt<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashArt))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDashArt(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDashArt<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashArt))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDashArt(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGlowColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGlowColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGlowColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGlowColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGlowColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGlowColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGlowColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateJump {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJump))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateJump<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJump))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateJump(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateJumpVariables {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateJumpVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJumpVariables))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateJumpVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateJumpVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJumpVariables))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateJumpVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerBirdFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerBirdFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerBirdFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerBirdFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerBirdFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerBirdFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerBirdFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerDartFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerDartFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerDartFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerDartFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerDartFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerDartFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerDartFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerGlow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerGlow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerGlow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerRobotFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRobotFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRobotFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerRobotFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRobotFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRobotFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerRobotFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerRollFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRollFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRollFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerRollFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRollFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRollFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerRollFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerShipFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerShipFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerShipFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerShipFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerShipFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerShipFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerShipFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerSpiderFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpiderFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpiderFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerSpiderFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpiderFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpiderFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerSpiderFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePlayerSpriteExtra {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpriteExtra<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpriteExtra))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePlayerSpriteExtra(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpriteExtra<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpriteExtra))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePlayerSpriteExtra(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateRobotAnimationSpeed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateRobotAnimationSpeed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRobotAnimationSpeed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateRobotAnimationSpeed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateRobotAnimationSpeed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRobotAnimationSpeed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateRobotAnimationSpeed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateShipRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateShipRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateShipRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateShipRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateShipRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateShipSpriteExtra {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateShipSpriteExtra<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipSpriteExtra))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateShipSpriteExtra(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateShipSpriteExtra<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipSpriteExtra))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateShipSpriteExtra(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSlopeRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSlopeRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSlopeRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSlopeYVelocity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeYVelocity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeYVelocity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSlopeYVelocity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeYVelocity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeYVelocity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSlopeYVelocity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSpecial {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecial))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecial))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateStateVariables {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStateVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStateVariables))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateStateVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStateVariables<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStateVariables))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateStateVariables(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateTimeMod {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTimeMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTimeMod))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateTimeMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTimeMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTimeMod))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateTimeMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct usingWallLimitedMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct usingWallLimitedMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::usingWallLimitedMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::usingWallLimitedMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct usingWallLimitedMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::usingWallLimitedMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::usingWallLimitedMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct yStartDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct yStartDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::yStartDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct yStartDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::yStartDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct yStartUp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct yStartUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartUp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::yStartUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct yStartUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartUp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::yStartUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGLFWMouseCallBack {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGLFWMouseCallBack<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGLFWMouseCallBack))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGLFWMouseCallBack(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGLFWMouseCallBack<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGLFWMouseCallBack))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGLFWMouseCallBack(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct swapBuffers {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct swapBuffers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::swapBuffers))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::swapBuffers(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct swapBuffers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::swapBuffers))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::swapBuffers(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateWindow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateWindow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWindow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateWindow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateWindow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWindow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateWindow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleFullScreen {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFullScreen<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFullScreen))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleFullScreen(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFullScreen<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFullScreen))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleFullScreen(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pollEvents {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pollEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pollEvents))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pollEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pollEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pollEvents))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pollEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedFileUtils {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedFileUtils<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedFileUtils))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedFileUtils(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedFileUtils<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedFileUtils))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedFileUtils(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct disableUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::disableUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::disableUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct draw {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct draw<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::draw))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::draw(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct draw<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::draw))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::draw(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enableUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enableUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enableUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enterAnimFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterAnimFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterAnimFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enterAnimFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterAnimFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterAnimFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enterAnimFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enterLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enterLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enterLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hideLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hideLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hideLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct layerHidden {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct layerHidden<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerHidden))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::layerHidden(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct layerHidden<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerHidden))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::layerHidden(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct layerVisible {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct layerVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerVisible))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::layerVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct layerVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerVisible))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::layerVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerWithTouchDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerWithTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerWithTouchDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerWithTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerWithTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerWithTouchDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerWithTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onTargetIDArrow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTargetIDArrow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTargetIDArrow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onTargetIDArrow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTargetIDArrow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTargetIDArrow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onTargetIDArrow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateTargetID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTargetID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTargetID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateTargetID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTargetID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTargetID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateTargetID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDisplayedOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDisplayedOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDisplayedOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDisplayedOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDisplayedOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDisplayedOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isCascadeOpacityEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeOpacityEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeOpacityEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isCascadeOpacityEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeOpacityEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeOpacityEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isCascadeOpacityEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setCascadeOpacityEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeOpacityEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeOpacityEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setCascadeOpacityEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeOpacityEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeOpacityEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setCascadeOpacityEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDisplayedColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDisplayedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDisplayedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDisplayedColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDisplayedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDisplayedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isCascadeColorEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeColorEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeColorEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isCascadeColorEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeColorEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeColorEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isCascadeColorEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setCascadeColorEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeColorEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeColorEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setCascadeColorEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeColorEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeColorEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setCascadeColorEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onMyLevels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMyLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyLevels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onMyLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMyLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyLevels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onMyLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSavedLevels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSavedLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSavedLevels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSavedLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSavedLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSavedLevels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSavedLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onClose {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onClose<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClose))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onClose(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onClose<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClose))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onClose(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCurrentLanguage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentLanguage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentLanguage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCurrentLanguage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentLanguage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentLanguage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCurrentLanguage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTargetPlatform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTargetPlatform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetPlatform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTargetPlatform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTargetPlatform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetPlatform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTargetPlatform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct openURL {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct openURL<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::openURL))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::openURL(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct openURL<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::openURL))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::openURL(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAnimationInterval {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAnimationInterval<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnimationInterval))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAnimationInterval(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAnimationInterval<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnimationInterval))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAnimationInterval(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithSpriteFrames {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrames))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithSpriteFrames(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrames))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithSpriteFrames(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onButtonsPerRow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onButtonsPerRow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onButtonsPerRow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onButtonsPerRow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onButtonsPerRow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onButtonsPerRow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onButtonsPerRow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addObjectNew {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectNew))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addObjectNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectNew))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addObjectNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addObjectsFromArray {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectsFromArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectsFromArray))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addObjectsFromArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectsFromArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectsFromArray))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addObjectsFromArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct containsObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct containsObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::containsObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::containsObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct containsObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::containsObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::containsObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct count {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct count<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::count))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::count(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct count<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::count))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::count(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fastRemoveObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fastRemoveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fastRemoveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fastRemoveObjectAtIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fastRemoveObjectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fastRemoveObjectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fastRemoveObjectAtIndexNew {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndexNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndexNew))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fastRemoveObjectAtIndexNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndexNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndexNew))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fastRemoveObjectAtIndexNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct lastObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lastObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lastObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::lastObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lastObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lastObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::lastObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectAtIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeLastObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeLastObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeLastObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeLastObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeLastObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeObjectAtIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectAtIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeObjectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectAtIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeObjectAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stringAtIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stringAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stringAtIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stringAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stringAtIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stringAtIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stringAtIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct limitLabelWidth {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct limitLabelWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::limitLabelWidth))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::limitLabelWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct limitLabelWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::limitLabelWidth))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::limitLabelWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAnchorPoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAnchorPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnchorPoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAnchorPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAnchorPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnchorPoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAnchorPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setObjectColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObjectColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setObjectColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObjectColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setObjectColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onArtists {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onArtists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onArtists))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onArtists(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onArtists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onArtists))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onArtists(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSongBrowser {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSongBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSongBrowser))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSongBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSongBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSongBrowser))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSongBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sendActionsForControlEvents {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sendActionsForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sendActionsForControlEvents))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sendActionsForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sendActionsForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sendActionsForControlEvents))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sendActionsForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setOpacityModifyRGB {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOpacityModifyRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacityModifyRGB))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setOpacityModifyRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOpacityModifyRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacityModifyRGB))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setOpacityModifyRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onExit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isTouchInside {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isTouchInside<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchInside))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isTouchInside(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isTouchInside<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchInside))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isTouchInside(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onEnter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEnter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onEnter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEnter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onEnter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSelected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isOpacityModifyRGB {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isOpacityModifyRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOpacityModifyRGB))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isOpacityModifyRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isOpacityModifyRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOpacityModifyRGB))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isOpacityModifyRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setHighlighted {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setHighlighted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setHighlighted))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setHighlighted(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setHighlighted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setHighlighted))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setHighlighted(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct needsLayout {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct needsLayout<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::needsLayout))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::needsLayout(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct needsLayout<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::needsLayout))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::needsLayout(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTouchLocation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchLocation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchLocation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTouchLocation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchLocation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchLocation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTouchLocation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isHighlighted {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isHighlighted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isHighlighted))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isHighlighted(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isHighlighted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isHighlighted))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isHighlighted(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addTargetWithActionForControlEvents {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addTargetWithActionForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addTargetWithActionForControlEvents))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addTargetWithActionForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addTargetWithActionForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addTargetWithActionForControlEvents))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addTargetWithActionForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeTargetWithActionForControlEvents {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeTargetWithActionForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeTargetWithActionForControlEvents))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeTargetWithActionForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeTargetWithActionForControlEvents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeTargetWithActionForControlEvents))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeTargetWithActionForControlEvents(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSelected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSelected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSelected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct clear {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clear<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clear))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::clear(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clear<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clear))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::clear(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct drawPolygon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawPolygon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawPolygon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::drawPolygon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawPolygon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawPolygon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::drawPolygon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct drawSegment {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawSegment<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawSegment))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::drawSegment(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawSegment<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawSegment))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::drawSegment(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBlendFunc {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBlendFunc))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBlendFunc))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setBlendFunc {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBlendFunc))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBlendFunc))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAlphaThreshold {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAlphaThreshold<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAlphaThreshold))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAlphaThreshold(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAlphaThreshold<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAlphaThreshold))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAlphaThreshold(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStencil {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStencil<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStencil))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStencil(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStencil<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStencil))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStencil(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isInverted {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isInverted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isInverted))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isInverted(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isInverted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isInverted))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isInverted(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onEnterTransitionDidFinish {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEnterTransitionDidFinish<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnterTransitionDidFinish))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onEnterTransitionDidFinish(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEnterTransitionDidFinish<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnterTransitionDidFinish))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onEnterTransitionDidFinish(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onExitTransitionDidStart {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitTransitionDidStart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitTransitionDidStart))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onExitTransitionDidStart(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitTransitionDidStart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitTransitionDidStart))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onExitTransitionDidStart(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAlphaThreshold {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAlphaThreshold<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAlphaThreshold))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAlphaThreshold(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAlphaThreshold<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAlphaThreshold))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAlphaThreshold(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setInverted {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInverted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInverted))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setInverted(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInverted<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInverted))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setInverted(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setStencil {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStencil<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStencil))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setStencil(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStencil<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStencil))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setStencil(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct visit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct visit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::visit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct visit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::visit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct attachWithIME {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct attachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::attachWithIME))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::attachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct attachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::attachWithIME))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::attachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct detachWithIME {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct detachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::detachWithIME))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::detachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct detachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::detachWithIME))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::detachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct allKeys {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct allKeys<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allKeys))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::allKeys(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct allKeys<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allKeys))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::allKeys(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeObjectForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeObjectForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeObjectForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct valueForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct valueForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::valueForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::valueForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct valueForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::valueForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::valueForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct handlerWithDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handlerWithDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handlerWithDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::handlerWithDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handlerWithDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handlerWithDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::handlerWithDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addSpriteFramesWithFile {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addSpriteFramesWithFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpriteFramesWithFile))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addSpriteFramesWithFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addSpriteFramesWithFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpriteFramesWithFile))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addSpriteFramesWithFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedSpriteFrameCache {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedSpriteFrameCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedSpriteFrameCache))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedSpriteFrameCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedSpriteFrameCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedSpriteFrameCache))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedSpriteFrameCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spriteFrameByName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spriteFrameByName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spriteFrameByName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spriteFrameByName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spriteFrameByName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spriteFrameByName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spriteFrameByName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getScheduler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScheduler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScheduler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getScheduler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScheduler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScheduler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getScheduler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setScheduler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScheduler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScheduler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setScheduler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setScheduler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScheduler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setScheduler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getActionManager {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActionManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionManager))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getActionManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActionManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionManager))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getActionManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setActionManager {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setActionManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setActionManager))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setActionManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setActionManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setActionManager))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setActionManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTouchDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTouchDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTouchDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getKeypadDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getKeypadDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeypadDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getKeypadDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getKeypadDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeypadDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getKeypadDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setKeypadDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setKeypadDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setKeypadDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getKeyboardDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getKeyboardDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeyboardDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getKeyboardDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getKeyboardDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeyboardDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getKeyboardDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setKeyboardDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setKeyboardDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setKeyboardDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMouseDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMouseDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMouseDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMouseDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMouseDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMouseDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMouseDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMouseDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMouseDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMouseDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMouseDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMouseDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAccelerometer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAccelerometer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAccelerometer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAccelerometer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAccelerometer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAccelerometer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAccelerometer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAccelerometer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAccelerometer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAccelerometer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDeltaTime {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDeltaTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDeltaTime))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDeltaTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDeltaTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDeltaTime))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDeltaTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSceneDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSceneDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSceneDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSceneDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSceneDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSceneDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSceneDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSceneDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSceneDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSceneDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSceneDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSceneDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSceneDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSceneDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getWinSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getWinSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getWinSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getWinSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getWinSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getWinSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getWinSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pushScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pushScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pushScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pushScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct replaceScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct replaceScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::replaceScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct replaceScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::replaceScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetSmoothFixCounter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetSmoothFixCounter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSmoothFixCounter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetSmoothFixCounter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetSmoothFixCounter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSmoothFixCounter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetSmoothFixCounter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedDirector {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedDirector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDirector))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedDirector(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedDirector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDirector))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedDirector(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateDeltaTime {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateDeltaTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateDeltaTime))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateDeltaTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateDeltaTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateDeltaTime))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateDeltaTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateMPF {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateMPF<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateMPF))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateMPF(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateMPF<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateMPF))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateMPF(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct convertToGL {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToGL<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToGL))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::convertToGL(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToGL<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToGL))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::convertToGL(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct drawScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::drawScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct drawScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::drawScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setNextScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setNextScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNextScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setNextScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setNextScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNextScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setNextScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showStats {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showStats<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showStats))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showStats(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showStats<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showStats))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showStats(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateContentScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateContentScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateContentScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateContentScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateContentScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateContentScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateContentScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct popSceneWithTransition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct popSceneWithTransition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::popSceneWithTransition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::popSceneWithTransition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct popSceneWithTransition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::popSceneWithTransition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::popSceneWithTransition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setParentLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setParentLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParentLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setParentLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setParentLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParentLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setParentLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFade {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFade))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFade))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct show {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct show<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::show))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::show(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct show<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::show))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::show(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fadeAndRemove {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeAndRemove<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeAndRemove))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fadeAndRemove(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeAndRemove<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeAndRemove))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fadeAndRemove(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithImageData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithImageData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImageData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithImageData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithImageData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImageData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithImageData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unselected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unselected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unselected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unselected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unselected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unselected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unselected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDisabledColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDisabledColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDisabledColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDisabledColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDisabledColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDisabledColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct useAnimationType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct useAnimationType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::useAnimationType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::useAnimationType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct useAnimationType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::useAnimationType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::useAnimationType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDestination {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDestination<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDestination))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDestination(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDestination<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDestination))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDestination(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSizeMult {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSizeMult<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSizeMult))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSizeMult(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSizeMult<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSizeMult))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSizeMult(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBlending {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlending<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlending))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBlending(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlending<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlending))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBlending(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCopyLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCopyLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCopyLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCopyLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCopyLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCopyLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCopyLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct acceptVisitor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct acceptVisitor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::acceptVisitor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::acceptVisitor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct acceptVisitor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::acceptVisitor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::acceptVisitor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct customSetup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct customSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customSetup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::customSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct customSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customSetup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::customSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedDispatcher {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDispatcher))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedDispatcher<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDispatcher))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedDispatcher(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupCommentsBrowser {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCommentsBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCommentsBrowser))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupCommentsBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCommentsBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCommentsBrowser))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupCommentsBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onMore {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMore<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMore))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onMore(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMore<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMore))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onMore(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onLevelInfo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onLevelInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLevelInfo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onLevelInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onLevelInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLevelInfo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onLevelInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setContentSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setContentSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setContentSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFromComment {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromComment<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromComment))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFromComment(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromComment<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromComment))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFromComment(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFromObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFromObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFromObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onNewgrounds {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNewgrounds<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNewgrounds))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onNewgrounds(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNewgrounds<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNewgrounds))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onNewgrounds(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBGColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBGColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBGColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createFromString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFromString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFromString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct dispatchKeyboardMSG {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dispatchKeyboardMSG<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dispatchKeyboardMSG))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::dispatchKeyboardMSG(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dispatchKeyboardMSG<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dispatchKeyboardMSG))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::dispatchKeyboardMSG(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyToString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyToString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyToString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyToString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyToString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct listButtonBarSwitchedPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct listButtonBarSwitchedPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::listButtonBarSwitchedPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::listButtonBarSwitchedPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct listButtonBarSwitchedPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::listButtonBarSwitchedPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::listButtonBarSwitchedPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithStandardSprites {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithStandardSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithStandardSprites))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithStandardSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithStandardSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithStandardSprites))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithStandardSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isOn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isOn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isOn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isOn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isOn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isToggled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isToggled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isToggled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isToggled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isToggled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isToggled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isToggled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setClickable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setClickable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setClickable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setClickable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setClickable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setClickable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setClickable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleWithCallback {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleWithCallback<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleWithCallback))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleWithCallback(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleWithCallback<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleWithCallback))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleWithCallback(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchBegan {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchBegan))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchBegan))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchCancelled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchCancelled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchCancelled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchCancelled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchCancelled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchCancelled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchCancelled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchEnded {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchEnded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchEnded))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchEnded(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchEnded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchEnded))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchEnded(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchMoved {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchMoved))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchMoved))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchesBegan {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesBegan))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchesBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesBegan))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchesBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchesCancelled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesCancelled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesCancelled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchesCancelled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesCancelled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesCancelled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchesCancelled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchesEnded {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesEnded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesEnded))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchesEnded(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesEnded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesEnded))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchesEnded(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccTouchesMoved {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesMoved))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccTouchesMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesMoved))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccTouchesMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct didAccelerate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didAccelerate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didAccelerate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::didAccelerate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didAccelerate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didAccelerate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::didAccelerate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTouchMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTouchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTouchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTouchPriority {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPriority<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPriority))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTouchPriority(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPriority<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPriority))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTouchPriority(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isAccelerometerEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isAccelerometerEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isAccelerometerEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isAccelerometerEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isAccelerometerEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isAccelerometerEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isAccelerometerEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isKeyboardEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isKeyboardEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeyboardEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isKeyboardEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isKeyboardEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeyboardEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isKeyboardEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isKeypadEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isKeypadEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeypadEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isKeypadEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isKeypadEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeypadEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isKeypadEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isMouseEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isMouseEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isMouseEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isMouseEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isMouseEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isMouseEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isMouseEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isTouchEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isTouchEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isTouchEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isTouchEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isTouchEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyBackClicked {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyBackClicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyBackClicked))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyBackClicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyBackClicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyBackClicked))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyBackClicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyMenuClicked {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyMenuClicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyMenuClicked))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyMenuClicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyMenuClicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyMenuClicked))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyMenuClicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerScriptTouchHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTouchHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTouchHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerScriptTouchHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTouchHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTouchHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerScriptTouchHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAccelerometerEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAccelerometerEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAccelerometerEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAccelerometerInterval {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerInterval<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerInterval))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAccelerometerInterval(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerInterval<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerInterval))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAccelerometerInterval(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setKeyboardEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setKeyboardEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setKeyboardEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setKeypadEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setKeypadEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setKeypadEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMouseEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMouseEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMouseEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMouseEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMouseEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTouchEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTouchEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTouchEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTouchMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTouchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTouchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTouchPriority {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchPriority<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchPriority))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTouchPriority(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTouchPriority<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchPriority))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTouchPriority(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unregisterScriptTouchHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTouchHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTouchHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unregisterScriptTouchHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTouchHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTouchHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unregisterScriptTouchHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetSystem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSystem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSystem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resumeSystem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSystem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resumeSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSystem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resumeSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopSystem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopSystem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopSystem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopSystem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopSystem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct alignItemsHorizontallyWithPadding {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorizontallyWithPadding<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorizontallyWithPadding))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::alignItemsHorizontallyWithPadding(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorizontallyWithPadding<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorizontallyWithPadding))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::alignItemsHorizontallyWithPadding(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct alignItemsVerticallyWithPadding {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsVerticallyWithPadding<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsVerticallyWithPadding))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::alignItemsVerticallyWithPadding(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsVerticallyWithPadding<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsVerticallyWithPadding))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::alignItemsVerticallyWithPadding(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithArray {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithArray))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithArray))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addChild {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addChild))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addChild))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeChild {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChild))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChild))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithArray {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithArray))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithArray<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithArray))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithArray(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerScriptTapHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTapHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTapHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerScriptTapHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTapHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTapHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerScriptTapHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unregisterScriptTapHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTapHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTapHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unregisterScriptTapHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTapHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTapHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unregisterScriptTapHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct rect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::rect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::rect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct incrementPriorityForSong {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementPriorityForSong<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementPriorityForSong))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::incrementPriorityForSong(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementPriorityForSong<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementPriorityForSong))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::incrementPriorityForSong(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pathForSong {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pathForSong<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pathForSong))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pathForSong(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pathForSong<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pathForSong))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pathForSong(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDownloadedSongs {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDownloadedSongs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDownloadedSongs))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDownloadedSongs(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDownloadedSongs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDownloadedSongs))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDownloadedSongs(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct songStateChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct songStateChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::songStateChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::songStateChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct songStateChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::songStateChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::songStateChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isEqual {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isEqual<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEqual))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isEqual(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isEqual<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEqual))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isEqual(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct copyWithZone {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyWithZone<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyWithZone))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::copyWithZone(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyWithZone<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyWithZone))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::copyWithZone(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct boolValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct boolValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boolValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::boolValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct boolValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boolValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::boolValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct doubleValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doubleValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doubleValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::doubleValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doubleValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doubleValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::doubleValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct floatValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct floatValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::floatValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::floatValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct floatValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::floatValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::floatValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct intValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct intValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::intValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct intValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::intValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNormalImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNormalImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNormalImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNormalImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNormalImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setNormalImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setNormalImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNormalImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setNormalImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setNormalImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNormalImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setNormalImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSelectedImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSelectedImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSelectedImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSelectedImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSelectedImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelectedImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSelectedImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSelectedImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelectedImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSelectedImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDisabledImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDisabledImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDisabledImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDisabledImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDisabledImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDisabledImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateImagesVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateImagesVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateImagesVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateImagesVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateImagesVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateImagesVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateImagesVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithNormalSprite {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithNormalSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithNormalSprite))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithNormalSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithNormalSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithNormalSprite))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithNormalSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resumeStroke {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeStroke))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resumeStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeStroke))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resumeStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopStroke {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopStroke))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopStroke))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithFade {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFade))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFade))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct _setZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct _setZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::_setZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::_setZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct _setZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::_setZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::_setZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addComponent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addComponent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addComponent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addComponent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addComponent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addComponent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addComponent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct cleanup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cleanup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::cleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cleanup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::cleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct convertToNodeSpace {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToNodeSpace<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToNodeSpace))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::convertToNodeSpace(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToNodeSpace<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToNodeSpace))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::convertToNodeSpace(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct convertToWorldSpace {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToWorldSpace<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToWorldSpace))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::convertToWorldSpace(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct convertToWorldSpace<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToWorldSpace))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::convertToWorldSpace(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getActionByTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActionByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionByTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getActionByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActionByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionByTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getActionByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAnchorPoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAnchorPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAnchorPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAnchorPointInPoints {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPointInPoints<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPointInPoints))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAnchorPointInPoints(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPointInPoints<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPointInPoints))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAnchorPointInPoints(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCamera {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCamera))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCamera))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getChildByTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildByTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getChildByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildByTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getChildByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getChildren {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildren))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildren))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getChildrenCount {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildrenCount<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildrenCount))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getChildrenCount(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getChildrenCount<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildrenCount))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getChildrenCount(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getContentSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getContentSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getContentSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGLServerState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGLServerState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGLServerState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGLServerState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGLServerState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGLServerState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGLServerState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGrid {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGrid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGrid))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGrid(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGrid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGrid))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGrid(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOrderOfArrival {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrderOfArrival<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrderOfArrival))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOrderOfArrival(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrderOfArrival<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrderOfArrival))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOrderOfArrival(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getParent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPositionX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPositionX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPositionX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPositionX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPositionX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPositionY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPositionY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPositionY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPositionY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPositionY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRotation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRotation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRotationX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotationX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRotationX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotationX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRotationX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRotationY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotationY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRotationY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRotationY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRotationY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getScaleX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getScaleY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getScaledContentSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaledContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaledContentSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getScaledContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getScaledContentSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaledContentSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getScaledContentSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getShaderProgram {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getShaderProgram<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getShaderProgram))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getShaderProgram(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getShaderProgram<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getShaderProgram))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getShaderProgram(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSkewX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSkewX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSkewX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSkewX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSkewX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSkewY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSkewY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSkewY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSkewY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSkewY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getUserData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUserData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getUserData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUserData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getUserData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getUserObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUserObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getUserObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUserObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getUserObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getVertexZ {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getVertexZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getVertexZ))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getVertexZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getVertexZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getVertexZ))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getVertexZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ignoreAnchorPointForPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreAnchorPointForPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreAnchorPointForPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ignoreAnchorPointForPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreAnchorPointForPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreAnchorPointForPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ignoreAnchorPointForPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isIgnoreAnchorPointForPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isIgnoreAnchorPointForPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIgnoreAnchorPointForPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isIgnoreAnchorPointForPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isIgnoreAnchorPointForPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIgnoreAnchorPointForPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isIgnoreAnchorPointForPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isRunning {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isRunning<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isRunning))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isRunning(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isRunning<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isRunning))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isRunning(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isVisible {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isVisible))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isVisible<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isVisible))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isVisible(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct nodeToParentTransform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct nodeToParentTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToParentTransform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::nodeToParentTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct nodeToParentTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToParentTransform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::nodeToParentTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct nodeToWorldTransform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct nodeToWorldTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToWorldTransform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::nodeToWorldTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct nodeToWorldTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToWorldTransform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::nodeToWorldTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct parentToNodeTransform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct parentToNodeTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentToNodeTransform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::parentToNodeTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct parentToNodeTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentToNodeTransform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::parentToNodeTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pauseSchedulerAndActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pauseSchedulerAndActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseSchedulerAndActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pauseSchedulerAndActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pauseSchedulerAndActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseSchedulerAndActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pauseSchedulerAndActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerScriptHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerScriptHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerScriptHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllChildren {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildren))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildren))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllChildrenWithCleanup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildrenWithCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildrenWithCleanup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllChildrenWithCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildrenWithCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildrenWithCleanup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllChildrenWithCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllComponents {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllComponents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllComponents))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllComponents(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllComponents<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllComponents))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllComponents(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeChildByTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeChildByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChildByTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeChildByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeChildByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChildByTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeChildByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeComponent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeComponent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeComponent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeComponent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeComponent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeComponent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeComponent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeFromParent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeFromParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeFromParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeFromParentAndCleanup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParentAndCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParentAndCleanup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeFromParentAndCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParentAndCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParentAndCleanup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeFromParentAndCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeMeAndCleanup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeMeAndCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeMeAndCleanup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeMeAndCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeMeAndCleanup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeMeAndCleanup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeMeAndCleanup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reorderChild {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reorderChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderChild))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reorderChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reorderChild<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderChild))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reorderChild(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resumeSchedulerAndActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeSchedulerAndActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSchedulerAndActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resumeSchedulerAndActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeSchedulerAndActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSchedulerAndActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resumeSchedulerAndActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct schedule {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct schedule<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::schedule))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::schedule(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct schedule<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::schedule))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::schedule(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scheduleUpdate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scheduleUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scheduleUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGLServerState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGLServerState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGLServerState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGLServerState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGLServerState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGLServerState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGLServerState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGrid {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGrid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGrid))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGrid(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGrid<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGrid))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGrid(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setOrderOfArrival {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOrderOfArrival<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrderOfArrival))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setOrderOfArrival(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOrderOfArrival<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrderOfArrival))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setOrderOfArrival(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setParent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPositionX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPositionX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPositionX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPositionX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPositionX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPositionY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPositionY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPositionY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPositionY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPositionY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRotationX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotationX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRotationX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotationX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRotationX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRotationY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotationY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRotationY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRotationY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRotationY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setShaderProgram {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setShaderProgram<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setShaderProgram))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setShaderProgram(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setShaderProgram<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setShaderProgram))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setShaderProgram(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSkewX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSkewX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSkewX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSkewX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSkewX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSkewY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSkewY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSkewY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSkewY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSkewY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setUserData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUserData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setUserData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUserData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setUserData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setUserObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUserObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setUserObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUserObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setUserObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setVertexZ {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVertexZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexZ))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setVertexZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVertexZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexZ))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setVertexZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sortAllChildren {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortAllChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortAllChildren))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sortAllChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortAllChildren<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortAllChildren))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sortAllChildren(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopActionByTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopActionByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionByTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopActionByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopActionByTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionByTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopActionByTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopAllActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopAllActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopAllActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopAllActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopAllActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopAllActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopAllActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unregisterScriptHandler {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptHandler))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unregisterScriptHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptHandler<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptHandler))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unregisterScriptHandler(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unschedule {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unschedule<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unschedule))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unschedule(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unschedule<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unschedule))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unschedule(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unscheduleAllSelectors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllSelectors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllSelectors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unscheduleAllSelectors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllSelectors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllSelectors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unscheduleAllSelectors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unscheduleUpdate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleUpdate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unscheduleUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleUpdate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unscheduleUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateTransform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTransform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTransform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateTweenAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTweenAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTweenAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateTweenAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateTweenAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTweenAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateTweenAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct worldToNodeTransform {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct worldToNodeTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::worldToNodeTransform))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::worldToNodeTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct worldToNodeTransform<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::worldToNodeTransform))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::worldToNodeTransform(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct begin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct begin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::begin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::begin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct begin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::begin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::begin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct end {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct end<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::end))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::end(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct end<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::end))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::end(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct newCCImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct newCCImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::newCCImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::newCCImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct newCCImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::newCCImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::newCCImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct autorelease {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct autorelease<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::autorelease))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::autorelease(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct autorelease<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::autorelease))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::autorelease(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct canEncode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct canEncode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canEncode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::canEncode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct canEncode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canEncode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::canEncode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct encodeWithCoder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct encodeWithCoder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeWithCoder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::encodeWithCoder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct encodeWithCoder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeWithCoder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::encodeWithCoder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct release {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct release<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::release))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::release(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct release<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::release))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::release(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct retain {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct retain<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::retain))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::retain(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct retain<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::retain))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::retain(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTag {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTag))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTag<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTag))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTag(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getHighestChildZ {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getHighestChildZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getHighestChildZ))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getHighestChildZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getHighestChildZ<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getHighestChildZ))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getHighestChildZ(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scheduleSelector {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleSelector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleSelector))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scheduleSelector(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleSelector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleSelector))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scheduleSelector(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scheduleUpdateForTarget {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdateForTarget<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdateForTarget))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scheduleUpdateForTarget(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdateForTarget<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdateForTarget))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scheduleUpdateForTarget(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unscheduleAllForTarget {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllForTarget<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllForTarget))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unscheduleAllForTarget(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllForTarget<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllForTarget))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unscheduleAllForTarget(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithSpriteFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithSpriteFrameName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrameName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrameName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithSpriteFrameName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrameName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrameName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithSpriteFrameName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithFile {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFile))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFile))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setChildColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setChildColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setChildColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setChildColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setChildColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setChildOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setChildOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setChildOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setChildOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setChildOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBatchNode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBatchNode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBatchNode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setBatchNode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBatchNode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBatchNode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct refreshTextureRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshTextureRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::refreshTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshTextureRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::refreshTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTextureRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setVertexRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVertexRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setVertexRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setVertexRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setVertexRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDisplayFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDisplayFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDisplayFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isFrameDisplayed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFrameDisplayed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFrameDisplayed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isFrameDisplayed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFrameDisplayed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFrameDisplayed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isFrameDisplayed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct displayFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct displayFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::displayFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::displayFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct displayFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::displayFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::displayFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDisplayFrameWithAnimationName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrameWithAnimationName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrameWithAnimationName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDisplayFrameWithAnimationName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrameWithAnimationName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrameWithAnimationName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDisplayFrameWithAnimationName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTextureCoords {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTextureCoords<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureCoords))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTextureCoords(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTextureCoords<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureCoords))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTextureCoords(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBlendFunc {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendFunc))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendFunc))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setReorderChildDirtyRecursively {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setReorderChildDirtyRecursively<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setReorderChildDirtyRecursively))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setReorderChildDirtyRecursively(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setReorderChildDirtyRecursively<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setReorderChildDirtyRecursively))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setReorderChildDirtyRecursively(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDirtyRecursively {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDirtyRecursively<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDirtyRecursively))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDirtyRecursively(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDirtyRecursively<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDirtyRecursively))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDirtyRecursively(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithSpriteFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithSpriteFrameName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrameName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrameName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithSpriteFrameName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrameName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrameName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithSpriteFrameName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getUsedAtlasCapacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUsedAtlasCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUsedAtlasCapacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getUsedAtlasCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUsedAtlasCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUsedAtlasCapacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getUsedAtlasCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct increaseAtlasCapacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct increaseAtlasCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::increaseAtlasCapacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::increaseAtlasCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct increaseAtlasCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::increaseAtlasCapacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::increaseAtlasCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getIconType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIconType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIconType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerCube {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerCube<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerCube))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerCube(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerCube<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerCube))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerCube(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerShip {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerShip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerShip))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerShip(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerShip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerShip))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerShip(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerBall {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBall))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerBall(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBall))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerBall(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerUfo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerUfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerUfo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerUfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerUfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerUfo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerUfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerWave {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerWave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerWave))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerWave(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerWave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerWave))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerWave(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerRobot {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerRobot<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerRobot))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerRobot(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerRobot<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerRobot))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerRobot(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerSpider {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerSpider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerSpider))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerSpider(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerSpider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerSpider))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerSpider(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGlowEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGlowEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGlowEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGlowEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGlowEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGlowEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGlowEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerExplosion {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerExplosion<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerExplosion))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerExplosion(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerExplosion<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerExplosion))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerExplosion(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerColor1 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor1))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerColor1(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor1))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerColor1(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerColor2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMaxS {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxS<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxS))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMaxS(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxS<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxS))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMaxS(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMaxT {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxT<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxT))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMaxT(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxT<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxT))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMaxT(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPixelFormat {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelFormat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelFormat))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPixelFormat(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelFormat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelFormat))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPixelFormat(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPixelsHigh {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsHigh<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsHigh))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPixelsHigh(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsHigh<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsHigh))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPixelsHigh(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPixelsWide {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsWide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsWide))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPixelsWide(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsWide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsWide))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPixelsWide(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initPremultipliedATextureWithImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initPremultipliedATextureWithImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initPremultipliedATextureWithImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initPremultipliedATextureWithImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initPremultipliedATextureWithImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initPremultipliedATextureWithImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initPremultipliedATextureWithImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAliasTexParameters {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAliasTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAliasTexParameters))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAliasTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAliasTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAliasTexParameters))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAliasTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAntiAliasTexParameters {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAntiAliasTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAntiAliasTexParameters))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAntiAliasTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAntiAliasTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAntiAliasTexParameters))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAntiAliasTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMaxS {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxS<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxS))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMaxS(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxS<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxS))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMaxS(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMaxT {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxT<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxT))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMaxT(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxT<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxT))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMaxT(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setTexParameters {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexParameters))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setTexParameters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexParameters))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setTexParameters(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct circleWaveWillBeRemoved {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct circleWaveWillBeRemoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::circleWaveWillBeRemoved))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::circleWaveWillBeRemoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct circleWaveWillBeRemoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::circleWaveWillBeRemoved))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::circleWaveWillBeRemoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedTextureCache {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedTextureCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedTextureCache))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedTextureCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedTextureCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedTextureCache))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedTextureCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct gettimeofdayCocos2d {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gettimeofdayCocos2d<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gettimeofdayCocos2d))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::gettimeofdayCocos2d(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gettimeofdayCocos2d<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gettimeofdayCocos2d))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::gettimeofdayCocos2d(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onEdit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEdit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEdit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onEdit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onEdit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEdit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onEdit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createToggleButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createToggleButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createToggleButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createToggleButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createToggleButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createToggleButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createToggleButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct disableMetering {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableMetering<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMetering))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::disableMetering(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableMetering<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMetering))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::disableMetering(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enableMetering {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableMetering<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMetering))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enableMetering(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableMetering<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMetering))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enableMetering(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMeteringValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMeteringValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMeteringValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMeteringValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMeteringValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMeteringValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMeteringValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playBackgroundMusic {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playBackgroundMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBackgroundMusic))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playBackgroundMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playBackgroundMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBackgroundMusic))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playBackgroundMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopBackgroundMusic {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopBackgroundMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBackgroundMusic))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopBackgroundMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopBackgroundMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBackgroundMusic))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopBackgroundMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedManager {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedManager))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedManager<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedManager))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedManager(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDelta {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDelta<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelta))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDelta(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDelta<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelta))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDelta(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLocationInView {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLocationInView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocationInView))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLocationInView(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLocationInView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocationInView))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLocationInView(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPreviousLocationInView {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPreviousLocationInView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreviousLocationInView))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPreviousLocationInView(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPreviousLocationInView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreviousLocationInView))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPreviousLocationInView(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLocation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLocation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLocation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLocation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLocation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct decrementForcePrio {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct decrementForcePrio<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::decrementForcePrio))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::decrementForcePrio(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct decrementForcePrio<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::decrementForcePrio))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::decrementForcePrio(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct incrementForcePrio {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementForcePrio<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementForcePrio))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::incrementForcePrio(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementForcePrio<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementForcePrio))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::incrementForcePrio(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct touches {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct touches<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touches))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::touches(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct touches<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touches))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::touches(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createNewLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createNewLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createNewLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createNewLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createNewLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createNewLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createNewLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPageInfo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPageInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPageInfo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPageInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPageInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPageInfo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPageInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStoredOnlineLevels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStoredOnlineLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStoredOnlineLevels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStoredOnlineLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStoredOnlineLevels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStoredOnlineLevels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStoredOnlineLevels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTopArtists {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtists))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTopArtists(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtists))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTopArtists(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTopArtistsKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtistsKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtistsKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTopArtistsKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtistsKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtistsKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTopArtistsKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct makeTimeStamp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct makeTimeStamp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::makeTimeStamp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::makeTimeStamp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct makeTimeStamp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::makeTimeStamp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::makeTimeStamp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMainLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMainLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMainLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMainLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMainLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setColorValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColorValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setColorValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColorValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setColorValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct HSVfromRGB {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct HSVfromRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::HSVfromRGB))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::HSVfromRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct HSVfromRGB<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::HSVfromRGB))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::HSVfromRGB(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct RGBfromHSV {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct RGBfromHSV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::RGBfromHSV))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::RGBfromHSV(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct RGBfromHSV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::RGBfromHSV))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::RGBfromHSV(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPreferredSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPreferredSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreferredSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPreferredSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPreferredSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreferredSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPreferredSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPreferredSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPreferredSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPreferredSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPreferredSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPreferredSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPreferredSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPreferredSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCapInsets {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCapInsets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapInsets))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCapInsets(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCapInsets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapInsets))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCapInsets(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setCapInsets {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCapInsets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCapInsets))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setCapInsets(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setCapInsets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCapInsets))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setCapInsets(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getInsetLeft {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetLeft))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getInsetLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetLeft))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getInsetLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setInsetLeft {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetLeft))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setInsetLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetLeft))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setInsetLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getInsetTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getInsetTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getInsetTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setInsetTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setInsetTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setInsetTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getInsetRight {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetRight<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetRight))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getInsetRight(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetRight<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetRight))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getInsetRight(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setInsetRight {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetRight<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetRight))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setInsetRight(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetRight<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetRight))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setInsetRight(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getInsetBottom {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetBottom))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getInsetBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getInsetBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetBottom))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getInsetBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setInsetBottom {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetBottom))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setInsetBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setInsetBottom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetBottom))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setInsetBottom(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct initWithBatchNode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithBatchNode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::initWithBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct initWithBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithBatchNode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::initWithBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateWithBatchNode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateWithBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWithBatchNode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateWithBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateWithBatchNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWithBatchNode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateWithBatchNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSpriteFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSpriteFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSpriteFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSpriteFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSpriteFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccGLBlendFunc {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccGLBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccGLBlendFunc))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccGLBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccGLBlendFunc<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccGLBlendFunc))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccGLBlendFunc(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ccDrawSolidRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccDrawSolidRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccDrawSolidRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ccDrawSolidRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ccDrawSolidRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccDrawSolidRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ccDrawSolidRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct doUnlink {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doUnlink))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::doUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doUnlink))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::doUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onAccountManagement {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onAccountManagement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAccountManagement))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onAccountManagement(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onAccountManagement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAccountManagement))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onAccountManagement(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onReLogin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onReLogin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onReLogin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onReLogin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onReLogin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onReLogin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onReLogin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onUnlink {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUnlink))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUnlink))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct verifyUnlink {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct verifyUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::verifyUnlink))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::verifyUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct verifyUnlink<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::verifyUnlink))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::verifyUnlink(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct FLAlert_Clicked {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct FLAlert_Clicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::FLAlert_Clicked))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::FLAlert_Clicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct FLAlert_Clicked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::FLAlert_Clicked))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::FLAlert_Clicked(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct accountStatusChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct accountStatusChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::accountStatusChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::accountStatusChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct accountStatusChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::accountStatusChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::accountStatusChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct doBackup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doBackup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doBackup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::doBackup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doBackup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doBackup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::doBackup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct doSync {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doSync<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doSync))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::doSync(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doSync<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doSync))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::doSync(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hideLoadingUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideLoadingUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLoadingUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hideLoadingUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideLoadingUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLoadingUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hideLoadingUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBackup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBackup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBackup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBackup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBackup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBackup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBackup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onHelp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onHelp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onHelp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onHelp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onHelp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onHelp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onHelp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onLogin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onLogin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLogin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onLogin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onLogin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLogin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onLogin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onRegister {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRegister<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRegister))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onRegister(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRegister<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRegister))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onRegister(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSync {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSync<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSync))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSync(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSync<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSync))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSync(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showLoadingUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showLoadingUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLoadingUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showLoadingUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showLoadingUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLoadingUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showLoadingUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct backupAccountFailed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFailed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::backupAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFailed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::backupAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct backupAccountFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::backupAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::backupAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct syncAccountFailed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFailed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::syncAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFailed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::syncAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct syncAccountFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::syncAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::syncAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFromDict {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromDict))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromDict))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAllAchievements {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllAchievements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllAchievements))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAllAchievements(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllAchievements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllAchievements))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAllAchievements(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct notifyAchievement {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct notifyAchievement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::notifyAchievement))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::notifyAchievement(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct notifyAchievement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::notifyAchievement))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::notifyAchievement(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct willSwitchToScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::willSwitchToScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::willSwitchToScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showNextAchievement {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showNextAchievement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNextAchievement))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showNextAchievement(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showNextAchievement<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNextAchievement))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showNextAchievement(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hideCursor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideCursor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideCursor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hideCursor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideCursor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideCursor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hideCursor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showCursor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCursor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCursor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showCursor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCursor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCursor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showCursor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isControllerConnected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isControllerConnected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isControllerConnected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isControllerConnected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isControllerConnected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isControllerConnected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isControllerConnected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playAnimation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateChildSpriteColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateChildSpriteColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateChildSpriteColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateChildSpriteColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateChildSpriteColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateChildSpriteColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateChildSpriteColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startAnimating {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startAnimating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startAnimating))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startAnimating(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startAnimating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startAnimating))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startAnimating(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct bgScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct bgScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bgScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::bgScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct bgScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bgScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::bgScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applicationDidFinishLaunching {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidFinishLaunching<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidFinishLaunching))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applicationDidFinishLaunching(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidFinishLaunching<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidFinishLaunching))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applicationDidFinishLaunching(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applicationDidEnterBackground {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidEnterBackground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidEnterBackground))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applicationDidEnterBackground(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidEnterBackground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidEnterBackground))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applicationDidEnterBackground(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applicationWillEnterForeground {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillEnterForeground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillEnterForeground))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applicationWillEnterForeground(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillEnterForeground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillEnterForeground))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applicationWillEnterForeground(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applicationWillBecomeActive {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillBecomeActive<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillBecomeActive))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applicationWillBecomeActive(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillBecomeActive<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillBecomeActive))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applicationWillBecomeActive(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applicationWillResignActive {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillResignActive<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillResignActive))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applicationWillResignActive(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillResignActive<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillResignActive))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applicationWillResignActive(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct trySaveGame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct trySaveGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::trySaveGame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::trySaveGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct trySaveGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::trySaveGame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::trySaveGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct get {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct get<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::get))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::get(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct get<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::get))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::get(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct audioStep {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct audioStep<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::audioStep))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::audioStep(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct audioStep<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::audioStep))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::audioStep(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetAudioVars {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetAudioVars<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAudioVars))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetAudioVars(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetAudioVars<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAudioVars))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetAudioVars(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct googlePlaySignedIn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct googlePlaySignedIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::googlePlaySignedIn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::googlePlaySignedIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct googlePlaySignedIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::googlePlaySignedIn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::googlePlaySignedIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onMoreGames {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMoreGames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMoreGames))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onMoreGames(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMoreGames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMoreGames))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onMoreGames(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGarage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGarage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGarage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGarage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGarage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGarage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGarage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onQuit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onQuit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onQuit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onQuit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onQuit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onQuit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onQuit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onMyProfile {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMyProfile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyProfile))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onMyProfile(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onMyProfile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyProfile))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onMyProfile(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlay {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlay))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlay(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlay))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlay(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onCreator {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCreator<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreator))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onCreator(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCreator<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreator))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onCreator(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onRobTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRobTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onRobTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRobTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onRobTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDaily {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDaily<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDaily))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDaily(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDaily<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDaily))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDaily(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onOptions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onOptions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onOptions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onOptions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onOptions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onOptions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onOptions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onAchievements {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onAchievements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAchievements))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onAchievements(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onAchievements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAchievements))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onAchievements(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onStats {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStats<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStats))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onStats(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStats<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStats))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onStats(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onFacebook {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onFacebook<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onFacebook))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onFacebook(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onFacebook<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onFacebook))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onFacebook(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onTwitter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTwitter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTwitter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onTwitter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTwitter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTwitter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onTwitter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onYouTube {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onYouTube<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onYouTube))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onYouTube(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onYouTube<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onYouTube))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onYouTube(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct node {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct node<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::node))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::node(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct node<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::node))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::node(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupList {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupList))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupList(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupList))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupList(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct TableViewWillDisplayCellForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillDisplayCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillDisplayCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::TableViewWillDisplayCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillDisplayCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillDisplayCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::TableViewWillDisplayCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct cellHeightForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cellHeightForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellHeightForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::cellHeightForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cellHeightForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellHeightForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::cellHeightForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct didSelectRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didSelectRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didSelectRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::didSelectRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didSelectRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didSelectRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::didSelectRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct numberOfRowsInSection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct numberOfRowsInSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfRowsInSection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::numberOfRowsInSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct numberOfRowsInSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfRowsInSection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::numberOfRowsInSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct numberOfSectionsInTableView {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct numberOfSectionsInTableView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfSectionsInTableView))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::numberOfSectionsInTableView(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct numberOfSectionsInTableView<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfSectionsInTableView))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::numberOfSectionsInTableView(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct cellForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::cellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::cellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct TableViewCommitCellEditingStyleForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewCommitCellEditingStyleForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewCommitCellEditingStyleForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::TableViewCommitCellEditingStyleForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewCommitCellEditingStyleForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewCommitCellEditingStyleForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::TableViewCommitCellEditingStyleForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct TableViewWillReloadCellForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillReloadCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillReloadCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::TableViewWillReloadCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillReloadCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillReloadCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::TableViewWillReloadCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getListCell {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getListCell<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getListCell))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getListCell(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getListCell<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getListCell))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getListCell(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadCell {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadCell<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadCell))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadCell(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadCell<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadCell))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadCell(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct instantMoveToPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct instantMoveToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::instantMoveToPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::instantMoveToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct instantMoveToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::instantMoveToPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::instantMoveToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveToPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBGImage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGImage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBGImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGImage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGImage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBGImage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSpriteBGSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpriteBGSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpriteBGSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSpriteBGSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpriteBGSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpriteBGSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSpriteBGSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runAnimation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAnimation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAnimation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct tweenToAnimation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tweenToAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tweenToAnimation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::tweenToAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tweenToAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tweenToAnimation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::tweenToAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct followObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct followObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::followObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::followObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct followObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::followObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::followObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorAllCharactersTo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorAllCharactersTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorAllCharactersTo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorAllCharactersTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorAllCharactersTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorAllCharactersTo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorAllCharactersTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct transformColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transformColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::transformColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transformColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::transformColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct alignItemsHorisontally {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorisontally<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorisontally))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::alignItemsHorisontally(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorisontally<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorisontally))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::alignItemsHorisontally(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMinY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMinY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMinY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMinY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMinY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMaxY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMaxY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMaxY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct preVisitWithClippingRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preVisitWithClippingRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preVisitWithClippingRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::preVisitWithClippingRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preVisitWithClippingRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preVisitWithClippingRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::preVisitWithClippingRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct postVisit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postVisit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postVisit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::postVisit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postVisit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postVisit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::postVisit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveToTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveToTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveToTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveToTopWithOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToTopWithOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTopWithOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveToTopWithOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveToTopWithOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTopWithOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveToTopWithOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrllViewWillBeginDecelerating {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrllViewWillBeginDecelerating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrllViewWillBeginDecelerating))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrllViewWillBeginDecelerating(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrllViewWillBeginDecelerating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrllViewWillBeginDecelerating))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrllViewWillBeginDecelerating(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollViewDidEndDecelerating {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndDecelerating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndDecelerating))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollViewDidEndDecelerating(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndDecelerating<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndDecelerating))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollViewDidEndDecelerating(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollViewTouchMoving {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchMoving))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollViewTouchMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchMoving))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollViewTouchMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollViewDidEndMoving {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndMoving))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollViewDidEndMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndMoving<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndMoving))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollViewDidEndMoving(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollViewTouchBegin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchBegin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchBegin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollViewTouchBegin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchBegin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchBegin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollViewTouchBegin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scrollViewTouchEnd {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchEnd<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchEnd))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scrollViewTouchEnd(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchEnd<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchEnd))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scrollViewTouchEnd(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textForColorIdx {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textForColorIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textForColorIdx))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textForColorIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textForColorIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textForColorIdx))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textForColorIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setLabelNormalColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelNormalColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelNormalColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setLabelNormalColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelNormalColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelNormalColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setLabelNormalColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setLabelPlaceholderColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setLabelPlaceholderColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setLabelPlaceholderColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setLabelPlaceholderScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setLabelPlaceholderScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setLabelPlaceholderScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMaxLabelScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMaxLabelScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMaxLabelScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMaxLabelWidth {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelWidth))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMaxLabelWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelWidth))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMaxLabelWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAllowedChars {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAllowedChars<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAllowedChars))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAllowedChars(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAllowedChars<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAllowedChars))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAllowedChars(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct forceOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct forceOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::forceOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::forceOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct forceOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::forceOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::forceOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTextField {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTextField<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTextField))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTextField(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTextField<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTextField))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTextField(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlaceholderLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlaceholderLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlaceholderLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlaceholderLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlaceholderLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlaceholderLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlaceholderLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDelegate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDelegate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDelegate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDelegate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDelegate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct refreshLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::refreshLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::refreshLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onClickTrackNode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onClickTrackNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClickTrackNode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onClickTrackNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onClickTrackNode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClickTrackNode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onClickTrackNode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyboardWillShow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillShow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillShow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyboardWillShow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillShow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillShow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyboardWillShow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyboardWillHide {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillHide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillHide))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyboardWillHide(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillHide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillHide))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyboardWillHide(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onTextFieldInsertText {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldInsertText<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldInsertText))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onTextFieldInsertText(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldInsertText<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldInsertText))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onTextFieldInsertText(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onTextFieldAttachWithIME {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldAttachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldAttachWithIME))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onTextFieldAttachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldAttachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldAttachWithIME))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onTextFieldAttachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onTextFieldDetachWithIME {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldDetachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldDetachWithIME))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onTextFieldDetachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldDetachWithIME<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldDetachWithIME))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onTextFieldDetachWithIME(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateWithCenter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateWithCenter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateWithCenter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateWithCenter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateWithCenter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateWithCenter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateWithCenter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBoundingRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBoundingRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoundingRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBoundingRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBoundingRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoundingRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBoundingRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct overlaps {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct overlaps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::overlaps(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct overlaps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::overlaps(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct overlaps1Way {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct overlaps1Way<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps1Way))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::overlaps1Way(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct overlaps1Way<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps1Way))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::overlaps1Way(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onNextItemID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextItemID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onNextItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextItemID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onNextItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSaveString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSaveString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSaveString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSaveString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSaveString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSaveString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSaveString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupFromDict {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromDict))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromDict))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupFromString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorValueChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorValueChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorValueChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorValueChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorValueChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorValueChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorValueChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onStop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onStop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onStop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createDialogLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createDialogLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createDialogLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createDialogLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createDialogLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createDialogLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createDialogLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animateIn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateIn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animateIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateIn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animateIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fadeInTextFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeInTextFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInTextFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fadeInTextFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeInTextFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInTextFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fadeInTextFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct dialogClosed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dialogClosed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dialogClosed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::dialogClosed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dialogClosed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dialogClosed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::dialogClosed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct currencyWillExit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct currencyWillExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::currencyWillExit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::currencyWillExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct currencyWillExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::currencyWillExit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::currencyWillExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadSongInfoFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadSongInfoFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSongInfoFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadSongInfoFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadSongInfoFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSongInfoFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadSongInfoFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSongObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSongObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSongObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSongObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSongObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSongObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSongObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onNextColorChannel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextColorChannel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextColorChannel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onNextColorChannel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextColorChannel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextColorChannel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onNextColorChannel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSelectColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSelectColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSelectColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllItems {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllItems))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllItems))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadItems {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItems))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItems))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadItemsInNormalSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadItemsInNormalSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItemsInNormalSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadItemsInNormalSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadItemsInNormalSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItemsInNormalSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadItemsInNormalSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFromItems {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromItems))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFromItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFromItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromItems))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFromItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onExitEditor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitEditor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitEditor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onExitEditor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitEditor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitEditor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onExitEditor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playStep2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playStep2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playStep2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playStep2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playStep2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playStep2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playStep2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onResume {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onResume<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onResume))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onResume(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onResume<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onResume))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onResume(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSaveAndPlay {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndPlay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndPlay))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSaveAndPlay(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndPlay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndPlay))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSaveAndPlay(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSaveAndExit {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndExit))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSaveAndExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndExit<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndExit))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSaveAndExit(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSave {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSave))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSave))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onExitNoSave {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitNoSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitNoSave))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onExitNoSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onExitNoSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitNoSave))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onExitNoSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct uncheckAllPortals {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct uncheckAllPortals<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::uncheckAllPortals))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::uncheckAllPortals(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct uncheckAllPortals<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::uncheckAllPortals))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::uncheckAllPortals(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct constrainGameLayerPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct constrainGameLayerPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::constrainGameLayerPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::constrainGameLayerPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct constrainGameLayerPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::constrainGameLayerPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::constrainGameLayerPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct deselectAll {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deselectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectAll))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::deselectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deselectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectAll))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::deselectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDeselectAll {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeselectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeselectAll))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDeselectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeselectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeselectAll))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDeselectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct disableButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::disableButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::disableButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct editButtonUsable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editButtonUsable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editButtonUsable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::editButtonUsable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editButtonUsable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editButtonUsable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::editButtonUsable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct editObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::editObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::editObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enableButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enableButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enableButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCreateBtn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCreateBtn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCreateBtn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCreateBtn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCreateBtn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCreateBtn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCreateBtn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroupCenter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupCenter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupCenter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroupCenter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupCenter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupCenter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroupCenter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSelectedObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSelectedObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSelectedObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDuplicate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDuplicate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDuplicate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDuplicate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDuplicate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDuplicate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDuplicate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pasteObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pasteObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pasteObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pasteObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pasteObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerTouchBegan {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchBegan))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerTouchBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchBegan<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchBegan))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerTouchBegan(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playtestStopped {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playtestStopped<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playtestStopped))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playtestStopped(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playtestStopped<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playtestStopped))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playtestStopped(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct redoLastAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct redoLastAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::redoLastAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::redoLastAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct redoLastAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::redoLastAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::redoLastAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct replaceGroupID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct replaceGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceGroupID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::replaceGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct replaceGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceGroupID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::replaceGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scaleChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scaleChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scaleChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scaleChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scaleChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct scaleObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scaleObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::scaleObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct scaleObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::scaleObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selectObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selectObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selectObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupCreateMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCreateMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCreateMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupCreateMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCreateMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCreateMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupCreateMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct undoLastAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct undoLastAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::undoLastAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::undoLastAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct undoLastAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::undoLastAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::undoLastAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateButtons {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateButtons<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateButtons))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateButtons(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateButtons<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateButtons))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateButtons(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateObjectInfoLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateObjectInfoLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateObjectInfoLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateObjectInfoLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateObjectInfoLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateObjectInfoLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateObjectInfoLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSlider {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlider))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSlider(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSlider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlider))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSlider(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateZoom {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateZoom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZoom))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateZoom(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateZoom<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZoom))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateZoom(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selectObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selectObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selectObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selectAll {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAll))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAll))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selectAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selectAllWithDirection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectAllWithDirection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAllWithDirection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selectAllWithDirection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectAllWithDirection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAllWithDirection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selectAllWithDirection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTouchPoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTouchPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTouchPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSelectBuildTab {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectBuildTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectBuildTab))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSelectBuildTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectBuildTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectBuildTab))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSelectBuildTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onCreateButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCreateButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreateButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onCreateButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCreateButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreateButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onCreateButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSpriteButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSpriteButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSpriteButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSpriteButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSpriteButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSpriteButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSpriteButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct offsetForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct offsetForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::offsetForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::offsetForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct offsetForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::offsetForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::offsetForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDeleteMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDeleteMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDeleteMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDeleteMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDeleteMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDeleteMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDeleteMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCreateMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCreateMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCreateMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCreateMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCreateMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCreateMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCreateMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct zoomIn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct zoomIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomIn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::zoomIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct zoomIn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomIn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::zoomIn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct zoomOut {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct zoomOut<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomOut))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::zoomOut(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct zoomOut<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomOut))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::zoomOut(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct rotateObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rotateObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotateObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::rotateObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rotateObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotateObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::rotateObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGridNodeSize {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGridNodeSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGridNodeSize))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGridNodeSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGridNodeSize<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGridNodeSize))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGridNodeSize(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSpecialUIElements {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecialUIElements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecialUIElements))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSpecialUIElements(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecialUIElements<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecialUIElements))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSpecialUIElements(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveGameLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveGameLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveGameLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveGameLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveGameLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveGameLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveGameLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showUI {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showUI))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showUI<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showUI))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showUI(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct editObject2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editObject2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::editObject2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editObject2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::editObject2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct editGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::editGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::editGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveObjectCall {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveObjectCall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObjectCall))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveObjectCall(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveObjectCall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObjectCall))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveObjectCall(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct transformObjectCall {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transformObjectCall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformObjectCall))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::transformObjectCall(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transformObjectCall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformObjectCall))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::transformObjectCall(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDeleteSelected {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteSelected))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDeleteSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteSelected<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteSelected))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDeleteSelected(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onCopy {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCopy<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopy))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onCopy(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCopy<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopy))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onCopy(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPaste {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPaste<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPaste))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPaste(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPaste<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPaste))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPaste(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleEnableRotate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleEnableRotate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleEnableRotate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleEnableRotate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleEnableRotate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleEnableRotate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleEnableRotate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleFreeMove {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFreeMove<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFreeMove))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleFreeMove(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFreeMove<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFreeMove))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleFreeMove(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleSwipe {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSwipe<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSwipe))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleSwipe(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSwipe<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSwipe))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleSwipe(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleSnap {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSnap<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSnap))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleSnap(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleSnap<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSnap))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleSnap(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlayback {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayback<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayback))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlayback(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayback<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayback))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlayback(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlaytest {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlaytest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlaytest))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlaytest(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlaytest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlaytest))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlaytest(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onStopPlaytest {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStopPlaytest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStopPlaytest))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onStopPlaytest(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onStopPlaytest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStopPlaytest))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onStopPlaytest(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGroupUp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupUp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGroupUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupUp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGroupUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGroupDown {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupDown))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGroupDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupDown<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupDown))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGroupDown(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct selectBuildTab {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectBuildTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectBuildTab))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::selectBuildTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct selectBuildTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectBuildTab))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::selectBuildTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPause {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPause<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPause))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPause(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPause<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPause))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPause(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSettings {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSettings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSettings))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSettings(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSettings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSettings))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSettings(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activateRotationControl {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateRotationControl<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateRotationControl))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activateRotationControl(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateRotationControl<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateRotationControl))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activateRotationControl(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activateScaleControl {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateScaleControl<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateScaleControl))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activateScaleControl(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateScaleControl<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateScaleControl))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activateScaleControl(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct dynamicGroupUpdate {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dynamicGroupUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dynamicGroupUpdate))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::dynamicGroupUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dynamicGroupUpdate<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dynamicGroupUpdate))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::dynamicGroupUpdate(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createRockOutline {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockOutline))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createRockOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockOutline))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createRockOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createRockEdges {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockEdges<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockEdges))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createRockEdges(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockEdges<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockEdges))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createRockEdges(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createRockBase {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockBase<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockBase))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createRockBase(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRockBase<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockBase))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createRockBase(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onCopyState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCopyState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopyState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onCopyState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCopyState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopyState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onCopyState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPasteColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPasteColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPasteColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPasteColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPasteColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPasteState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPasteState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPasteState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPasteState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPasteState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGroupSticky {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupSticky<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupSticky))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGroupSticky(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGroupSticky<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupSticky))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGroupSticky(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onUngroupSticky {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onUngroupSticky<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUngroupSticky))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onUngroupSticky(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onUngroupSticky<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUngroupSticky))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onUngroupSticky(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGoToLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGoToLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGoToLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGoToLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGoToLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onGoToBaseLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGoToBaseLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToBaseLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onGoToBaseLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onGoToBaseLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToBaseLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onGoToBaseLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct editColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::editColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct editColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::editColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct alignObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::alignObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct alignObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::alignObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyUp {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyUp))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyUp<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyUp))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyUp(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTargetColorIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTargetColorIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetColorIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTargetColorIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTargetColorIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetColorIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTargetColorIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct triggerObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::triggerObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::triggerObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setAngle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAngle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAngle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setAngle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setAngle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAngle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setAngle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSliderPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSliderPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSliderPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSliderPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSliderPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSliderPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSliderPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct encodeDataTo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct encodeDataTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeDataTo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::encodeDataTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct encodeDataTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeDataTo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::encodeDataTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct dataLoaded {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dataLoaded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dataLoaded))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::dataLoaded(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct dataLoaded<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dataLoaded))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::dataLoaded(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct firstLoad {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct firstLoad<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstLoad))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::firstLoad(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct firstLoad<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstLoad))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::firstLoad(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct save {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct save<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::save))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::save(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct save<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::save))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::save(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveData {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveData))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveData(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveData<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveData))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveData(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveGMTo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveGMTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveGMTo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveGMTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveGMTo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveGMTo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveGMTo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBtn1 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBtn1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn1))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBtn1(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBtn1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn1))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBtn1(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBtn2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBtn2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBtn2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBtn2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBtn2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sharedEngine {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedEngine<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedEngine))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sharedEngine(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sharedEngine<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedEngine))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sharedEngine(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct preloadEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preloadEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preloadEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::preloadEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preloadEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preloadEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::preloadEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isBackgroundMusicPlaying {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBackgroundMusicPlaying<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBackgroundMusicPlaying))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isBackgroundMusicPlaying(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBackgroundMusicPlaying<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBackgroundMusicPlaying))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isBackgroundMusicPlaying(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loginAccountFailed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFailed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loginAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFailed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loginAccountFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loginAccountFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loginAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loginAccountFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAllObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAllObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAllObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectsCollided {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectsCollided<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsCollided))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectsCollided(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectsCollided<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsCollided))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectsCollided(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createMoveCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createMoveCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createMoveCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createMoveCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createMoveCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createMoveCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createMoveCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateColorValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateColorValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateColorValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateColorValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateColorValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateColorValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateColorValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGroupTriggered {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupTriggered))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGroupTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupTriggered))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGroupTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToSection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeFromGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeFromGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeFromGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addObjectCounter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectCounter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectCounter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addObjectCounter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectCounter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectCounter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addObjectCounter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct atlasValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct atlasValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::atlasValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::atlasValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct atlasValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::atlasValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::atlasValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateOpacityValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateOpacityValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOpacityValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateOpacityValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateOpacityValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOpacityValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateOpacityValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct checkSpawnObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkSpawnObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSpawnObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::checkSpawnObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkSpawnObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSpawnObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::checkSpawnObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct collectItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collectItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::collectItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collectItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::collectItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct collectedObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collectedObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectedObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::collectedObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct collectedObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectedObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::collectedObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createTextLayers {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createTextLayers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createTextLayers))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createTextLayers(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createTextLayers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createTextLayers))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createTextLayers(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct damagingObjectsInRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct damagingObjectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::damagingObjectsInRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::damagingObjectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct damagingObjectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::damagingObjectsInRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::damagingObjectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enableHighCapacityMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableHighCapacityMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableHighCapacityMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enableHighCapacityMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableHighCapacityMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableHighCapacityMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enableHighCapacityMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCapacityString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCapacityString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapacityString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCapacityString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCapacityString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapacityString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCapacityString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroundHeightForMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroundHeightForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroundHeightForMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroundHeightForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroundHeightForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroundHeightForMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroundHeightForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMoveDeltaForObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMoveDeltaForObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMoveDeltaForObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMoveDeltaForObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMoveDeltaForObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMoveDeltaForObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMoveDeltaForObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOptimizedGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOptimizedGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOptimizedGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOptimizedGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOptimizedGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOptimizedGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOptimizedGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStaticGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStaticGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStaticGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStaticGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStaticGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStaticGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStaticGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isGroupDisabledForObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isGroupDisabledForObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isGroupDisabledForObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isGroupDisabledForObjectFull {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObjectFull<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObjectFull))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isGroupDisabledForObjectFull(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObjectFull<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObjectFull))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isGroupDisabledForObjectFull(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadUpToPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadUpToPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadUpToPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadUpToPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadUpToPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadUpToPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadUpToPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectIntersectsCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectIntersectsCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectIntersectsCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectIntersectsCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectIntersectsCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectIntersectsCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectIntersectsCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectTriggered {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectTriggered))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectTriggered))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct optimizeMoveGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeMoveGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeMoveGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::optimizeMoveGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeMoveGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeMoveGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::optimizeMoveGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct parentForZLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct parentForZLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentForZLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::parentForZLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct parentForZLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentForZLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::parentForZLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerTouchedRing {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchedRing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchedRing))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerTouchedRing(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchedRing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchedRing))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerTouchedRing(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processColorObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processColorObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColorObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processColorObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processColorObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColorObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processColorObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processFollowActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processFollowActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processFollowActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processFollowActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processFollowActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processFollowActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processFollowActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processMoveActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processMoveActionsStep {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActionsStep<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActionsStep))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processMoveActionsStep(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActionsStep<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActionsStep))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processMoveActionsStep(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processOpacityObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processOpacityObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processOpacityObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processOpacityObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processOpacityObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processOpacityObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processOpacityObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processPlayerFollowActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processPlayerFollowActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPlayerFollowActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processPlayerFollowActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processPlayerFollowActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPlayerFollowActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processPlayerFollowActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processRotationActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processRotationActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processRotationActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processRotationActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processRotationActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processRotationActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processRotationActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct rectIntersectsCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rectIntersectsCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rectIntersectsCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::rectIntersectsCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rectIntersectsCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rectIntersectsCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::rectIntersectsCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct refreshCounterLabels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshCounterLabels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshCounterLabels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::refreshCounterLabels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct refreshCounterLabels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshCounterLabels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::refreshCounterLabels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeFromGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeFromGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeFromGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeObjectFromSection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectFromSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectFromSection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeObjectFromSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectFromSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectFromSection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeObjectFromSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reorderObjectSection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reorderObjectSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderObjectSection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reorderObjectSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reorderObjectSection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderObjectSection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reorderObjectSection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetGroupCounters {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupCounters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupCounters))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetGroupCounters(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupCounters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupCounters))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetGroupCounters(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetMoveOptimizedValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveOptimizedValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveOptimizedValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetMoveOptimizedValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveOptimizedValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveOptimizedValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetMoveOptimizedValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sectionForPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sectionForPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sectionForPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sectionForPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sectionForPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sectionForPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sectionForPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupLayers {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLayers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLayers))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupLayers(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLayers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLayers))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupLayers(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct shouldExitHackedLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shouldExitHackedLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldExitHackedLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::shouldExitHackedLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shouldExitHackedLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldExitHackedLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::shouldExitHackedLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnGroupTriggered {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroupTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroupTriggered))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnGroupTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroupTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroupTriggered))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnGroupTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct staticObjectsInRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct staticObjectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::staticObjectsInRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::staticObjectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct staticObjectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::staticObjectsInRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::staticObjectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct testInstantCountTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct testInstantCountTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testInstantCountTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::testInstantCountTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct testInstantCountTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testInstantCountTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::testInstantCountTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct togglePlayerVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::togglePlayerVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::togglePlayerVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct triggerMoveCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerMoveCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerMoveCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::triggerMoveCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerMoveCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerMoveCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::triggerMoveCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCollisionBlocks {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollisionBlocks<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollisionBlocks))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCollisionBlocks(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCollisionBlocks<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollisionBlocks))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCollisionBlocks(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCounters {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCounters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCounters))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCounters(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCounters<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCounters))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCounters(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDisabledObjectsLastPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisabledObjectsLastPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisabledObjectsLastPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDisabledObjectsLastPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDisabledObjectsLastPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisabledObjectsLastPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDisabledObjectsLastPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateLayerCapacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLayerCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLayerCapacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateLayerCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLayerCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLayerCapacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateLayerCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateLegacyLayerCapacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLegacyLayerCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLegacyLayerCapacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateLegacyLayerCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLegacyLayerCapacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLegacyLayerCapacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateLegacyLayerCapacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOBB2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOBB2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOBB2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOBB2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOBB2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOBB2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOBB2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateQueuedLabels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateQueuedLabels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateQueuedLabels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateQueuedLabels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateQueuedLabels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateQueuedLabels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateQueuedLabels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activeColorForIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activeColorForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeColorForIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activeColorForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activeColorForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeColorForIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activeColorForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activeOpacityForIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activeOpacityForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeOpacityForIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activeOpacityForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activeOpacityForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeOpacityForIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activeOpacityForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addAllInheritedColorActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addAllInheritedColorActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllInheritedColorActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addAllInheritedColorActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addAllInheritedColorActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllInheritedColorActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addAllInheritedColorActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addGroupPulseEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addGroupPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addGroupPulseEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addGroupPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addGroupPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addGroupPulseEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addGroupPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateBaseActiveColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateBaseActiveColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateBaseActiveColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateBaseActiveColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateBaseActiveColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateBaseActiveColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateBaseActiveColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateInheritedColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateInheritedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateInheritedColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateInheritedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateInheritedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateInheritedColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateInheritedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateLightBGColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateLightBGColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateLightBGColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateLightBGColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateLightBGColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateLightBGColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateLightBGColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorActionChanged {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorActionChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorActionChanged))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorActionChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorActionChanged<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorActionChanged))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorActionChanged(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorExists {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorExists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorExists))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorExists(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorExists<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorExists))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorExists(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForGroupID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForGroupID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForGroupID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForPulseEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForPulseEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForPulseEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct countChangedForItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct countChangedForItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countChangedForItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::countChangedForItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct countChangedForItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countChangedForItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::countChangedForItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct countForItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct countForItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countForItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::countForItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct countForItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countForItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::countForItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createFollowCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createFollowCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFollowCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createFollowCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createFollowCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFollowCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createFollowCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createPlayerFollowCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createPlayerFollowCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createPlayerFollowCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createPlayerFollowCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createPlayerFollowCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createPlayerFollowCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createPlayerFollowCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createRotateCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRotateCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createRotateCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRotateCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createRotateCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAllColorActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAllColorActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAllColorActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAllColorSprites {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorSprites))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAllColorSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorSprites))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAllColorSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getColorAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getColorSprite {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorSprite))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getColorSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorSprite))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getColorSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCurrentStateString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentStateString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentStateString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCurrentStateString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentStateString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentStateString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCurrentStateString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLoadedMoveOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLoadedMoveOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadedMoveOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLoadedMoveOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLoadedMoveOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadedMoveOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLoadedMoveOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMixedColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMixedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMixedColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMixedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMixedColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMixedColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMixedColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOpacityActionForGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOpacityActionForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacityActionForGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOpacityActionForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOpacityActionForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacityActionForGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOpacityActionForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct handleObjectCollision {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handleObjectCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleObjectCollision))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::handleObjectCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handleObjectCollision<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleObjectCollision))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::handleObjectCollision(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasActiveDualTouch {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasActiveDualTouch<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasActiveDualTouch))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasActiveDualTouch(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasActiveDualTouch<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasActiveDualTouch))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasActiveDualTouch(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasBeenTriggered {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenTriggered))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasBeenTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenTriggered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenTriggered))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasBeenTriggered(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasPulseEffectForGroupID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasPulseEffectForGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPulseEffectForGroupID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasPulseEffectForGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasPulseEffectForGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPulseEffectForGroupID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasPulseEffectForGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isGroupEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isGroupEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isGroupEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isGroupEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyForGroupIDColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyForGroupIDColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyForGroupIDColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyForGroupIDColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyForGroupIDColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyForGroupIDColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyForGroupIDColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct opacityForIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct opacityForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityForIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::opacityForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct opacityForIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityForIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::opacityForIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct opacityModForGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct opacityModForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityModForGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::opacityModForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct opacityModForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityModForGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::opacityModForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerButton {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerButton))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerButton<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerButton))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerButton(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerDied {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerDied<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDied))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerDied(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerDied<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDied))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerDied(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct postCollisionCheck {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postCollisionCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollisionCheck))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::postCollisionCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct postCollisionCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollisionCheck))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::postCollisionCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct preCollisionCheck {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preCollisionCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollisionCheck))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::preCollisionCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct preCollisionCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollisionCheck))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::preCollisionCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct prepareMoveActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct prepareMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareMoveActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::prepareMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct prepareMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareMoveActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::prepareMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processCopyColorPulseActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processCopyColorPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processCopyColorPulseActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processCopyColorPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processCopyColorPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processCopyColorPulseActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processCopyColorPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processInheritedColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processInheritedColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processInheritedColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processInheritedColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processInheritedColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processInheritedColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processInheritedColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processPulseActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPulseActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPulseActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerCollisionTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerCollisionTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerCollisionTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerCollisionTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerCollisionTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerCollisionTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerCollisionTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllPulseActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllPulseActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllPulseActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllPulseActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllPulseActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeColorAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeColorAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeColorAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetColorCache {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetColorCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetColorCache))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetColorCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetColorCache<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetColorCache))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetColorCache(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetMoveActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetToggledGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetToggledGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetToggledGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetTriggeredIDs {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetTriggeredIDs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetTriggeredIDs))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetTriggeredIDs(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetTriggeredIDs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetTriggeredIDs))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetTriggeredIDs(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runCountTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runCountTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runCountTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runCountTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runCountTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runCountTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runCountTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runDeathTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runDeathTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runDeathTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runDeathTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runDeathTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runDeathTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runDeathTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runOpacityActionOnGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runOpacityActionOnGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runOpacityActionOnGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runOpacityActionOnGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runOpacityActionOnGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runOpacityActionOnGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runOpacityActionOnGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runPulseEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runPulseEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runPulseEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runPulseEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runPulseEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runTouchTriggerCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runTouchTriggerCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runTouchTriggerCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runTouchTriggerCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runTouchTriggerCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runTouchTriggerCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runTouchTriggerCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setColorAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFollowing {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFollowing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFollowing))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFollowing(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFollowing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFollowing))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFollowing(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct shouldBlend {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shouldBlend<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldBlend))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::shouldBlend(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shouldBlend<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldBlend))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::shouldBlend(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopActionsForTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopActionsForTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionsForTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopActionsForTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopActionsForTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionsForTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopActionsForTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopMoveActionsForGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopMoveActionsForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopMoveActionsForGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopMoveActionsForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopMoveActionsForGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopMoveActionsForGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopMoveActionsForGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storeTriggeredID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeTriggeredID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeTriggeredID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storeTriggeredID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeTriggeredID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeTriggeredID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storeTriggeredID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct traverseInheritanceChain {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct traverseInheritanceChain<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::traverseInheritanceChain))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::traverseInheritanceChain(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct traverseInheritanceChain<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::traverseInheritanceChain))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::traverseInheritanceChain(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateActiveOpacityEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateActiveOpacityEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateActiveOpacityEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateActiveOpacityEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateActiveOpacityEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateActiveOpacityEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateActiveOpacityEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateColorAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColorAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateColorAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateColorEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColorEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateColorEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColorEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateColorEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOpacityAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOpacityAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOpacityAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOpacityEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOpacityEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOpacityEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updatePulseEffects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePulseEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePulseEffects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updatePulseEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updatePulseEffects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePulseEffects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updatePulseEffects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSpawnTriggers {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpawnTriggers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpawnTriggers))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSpawnTriggers(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSpawnTriggers<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpawnTriggers))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSpawnTriggers(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct wasFollowing {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct wasFollowing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wasFollowing))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::wasFollowing(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct wasFollowing<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wasFollowing))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::wasFollowing(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct wouldCreateLoop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct wouldCreateLoop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wouldCreateLoop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::wouldCreateLoop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct wouldCreateLoop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wouldCreateLoop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::wouldCreateLoop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithCoder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithCoder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithCoder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithCoder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithCoder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithCoder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithCoder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAudioFileName {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAudioFileName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAudioFileName))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAudioFileName(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAudioFileName<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAudioFileName))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAudioFileName(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getCoinKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCoinKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCoinKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getCoinKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getCoinKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCoinKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getCoinKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLengthKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLengthKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLengthKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLengthKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLengthKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLengthKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLengthKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNormalPercent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNormalPercent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalPercent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNormalPercent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNormalPercent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalPercent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNormalPercent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelWasAltered {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelWasAltered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWasAltered))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelWasAltered(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelWasAltered<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWasAltered))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelWasAltered(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct savePercentage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct savePercentage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::savePercentage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::savePercentage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct savePercentage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::savePercentage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::savePercentage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getAverageDifficulty {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAverageDifficulty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAverageDifficulty))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getAverageDifficulty(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getAverageDifficulty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAverageDifficulty))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getAverageDifficulty(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlayerColor1 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor1))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlayerColor1(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor1))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlayerColor1(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlayerColor2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSelectTab {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectTab))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSelectTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSelectTab<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectTab))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSelectTab(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPlayerIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPlayerIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPlayerIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onShipIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShipIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShipIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onShipIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShipIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShipIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onShipIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBallIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBallIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBallIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBallIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBallIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBallIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBallIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBirdIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBirdIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBirdIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBirdIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBirdIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBirdIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBirdIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDartIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDartIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDartIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDartIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDartIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDartIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDartIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onRobotIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRobotIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobotIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onRobotIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onRobotIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobotIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onRobotIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onSpiderIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSpiderIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSpiderIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onSpiderIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onSpiderIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSpiderIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onSpiderIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onShards {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShards<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShards))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onShards(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShards<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShards))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onShards(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onBack {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBack<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBack))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onBack(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onBack<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBack))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onBack(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onShop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onShop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onShop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onShop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGroundWidth {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGroundWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroundWidth))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGroundWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGroundWidth<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroundWidth))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGroundWidth(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createBrowserIcon {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createBrowserIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBrowserIcon))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createBrowserIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createBrowserIcon<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBrowserIcon))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createBrowserIcon(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupLevelBrowser {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelBrowser))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupLevelBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelBrowser<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelBrowser))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupLevelBrowser(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hideSecondary {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideSecondary<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideSecondary))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hideSecondary(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hideSecondary<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideSecondary))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hideSecondary(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateColor02 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColor02<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor02))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateColor02(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateColor02<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor02))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateColor02(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerBird {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBird<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBird))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerBird(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBird<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBird))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerBird(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerDart {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDart))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerDart(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDart))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerDart(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerDeathEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDeathEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDeathEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerGlow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerGlow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerGlow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayerIconType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerIconType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayerIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerIconType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayerIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerShip {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerShip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerShip))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerShip(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerShip<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerShip))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerShip(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerBall {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBall))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerBall(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBall<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBall))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerBall(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerBird {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBird<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBird))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerBird(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBird<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBird))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerBird(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerDart {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDart))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerDart(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDart))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerDart(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerRobot {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerRobot<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerRobot))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerRobot(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerRobot<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerRobot))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerRobot(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerSpider {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerSpider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerSpider))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerSpider(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerSpider<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerSpider))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerSpider(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerStreak {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerStreak))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerStreak<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerStreak))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerStreak(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerDeathEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDeathEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDeathEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerColor2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerColor2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerGlow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerGlow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerGlow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setPlayerIconType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerIconType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setPlayerIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerIconType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerIconType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setPlayerIconType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setQuality {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setQuality<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setQuality))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setQuality(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setQuality<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setQuality))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setQuality(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getPlayLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getPlayLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getPlayLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getPlayLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getEditorLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getEditorLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getEditorLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getEditorLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getEditorLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getEditorLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getEditorLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGameVariableDefault {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariableDefault<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariableDefault))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGameVariableDefault(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariableDefault<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariableDefault))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGameVariableDefault(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getIntGameVariableDefault {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariableDefault<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariableDefault))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getIntGameVariableDefault(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariableDefault<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariableDefault))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getIntGameVariableDefault(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForIdx {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIdx))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIdx))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct didExitPlayscene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didExitPlayscene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didExitPlayscene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::didExitPlayscene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didExitPlayscene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didExitPlayscene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::didExitPlayscene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct doQuickSave {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doQuickSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doQuickSave))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::doQuickSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct doQuickSave<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doQuickSave))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::doQuickSave(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fadeInMusic {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeInMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInMusic))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fadeInMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fadeInMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInMusic))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fadeInMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBGTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBGTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBGTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBGTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBGTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBGTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBGTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getFontFile {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getFontFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getFontFile))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getFontFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getFontFile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getFontFile))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getFontFile(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGameVariable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getIntGameVariable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getIntGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getIntGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getUGV {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUGV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUGV))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getUGV(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUGV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUGV))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getUGV(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadDeathEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDeathEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadDeathEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDeathEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadDeathEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadFont {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFont<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFont))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadFont(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadFont<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFont))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadFont(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadAll {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAll))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAll<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAll))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadAll(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadAllStep2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadAllStep2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadAllStep2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reloadAllStep5 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep5<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep5))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reloadAllStep5(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep5<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep5))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reloadAllStep5(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reportPercentageForLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reportPercentageForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportPercentageForLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reportPercentageForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reportPercentageForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportPercentageForLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reportPercentageForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGameVariable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameVariable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameVariable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setIntGameVariable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setIntGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setIntGameVariable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setIntGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setIntGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setIntGameVariable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setIntGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setUGV {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUGV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUGV))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setUGV(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setUGV<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUGV))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setUGV(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGTexture {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGTexture))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGTexture<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGTexture))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGTexture(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct reportAchievementWithID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reportAchievementWithID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportAchievementWithID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::reportAchievementWithID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct reportAchievementWithID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportAchievementWithID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::reportAchievementWithID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resolutionForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resolutionForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resolutionForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resolutionForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resolutionForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resolutionForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resolutionForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isColorUnlocked {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isColorUnlocked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorUnlocked))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isColorUnlocked(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isColorUnlocked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorUnlocked))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isColorUnlocked(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isIconUnlocked {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isIconUnlocked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIconUnlocked))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isIconUnlocked(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isIconUnlocked<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIconUnlocked))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isIconUnlocked(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGameVariable {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGameVariable))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGameVariable<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGameVariable))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGameVariable(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct returnToLastScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct returnToLastScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::returnToLastScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::returnToLastScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct returnToLastScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::returnToLastScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::returnToLastScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStartPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStartPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStartPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStartPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStartPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setStartPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStartPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setStartPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStartPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setStartPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getUniqueID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUniqueID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUniqueID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getUniqueID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getUniqueID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUniqueID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getUniqueID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroupID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroupIDCount {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDCount<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDCount))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroupIDCount(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDCount<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDCount))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroupIDCount(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGroupIDs {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDs))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGroupIDs(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDs<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDs))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGroupIDs(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getGameZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getGameZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getGameZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getGameZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGameZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGameZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGameZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGameObjType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameObjType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameObjType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGameObjType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGameObjType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameObjType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGameObjType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBaseColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBaseColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBaseColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBaseColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBaseColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBaseColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBaseColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDetailColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDetailColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDetailColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDetailColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDetailColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDetailColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDetailColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupCustomSprites {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCustomSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCustomSprites))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupCustomSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCustomSprites<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCustomSprites))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupCustomSprites(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addMainSpriteToParent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addMainSpriteToParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addMainSpriteToParent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addMainSpriteToParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addMainSpriteToParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addMainSpriteToParent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addMainSpriteToParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activateObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct deactivateObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::deactivateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deactivateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::deactivateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectRect2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectRect2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectRect2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectTextureRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectTextureRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectTextureRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectTextureRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectTextureRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setStartPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateStartValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStartValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateStartValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStartValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateStartValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct customObjectSetup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct customObjectSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customObjectSetup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::customObjectSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct customObjectSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customObjectSetup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::customObjectSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isFlipX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isFlipX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isFlipX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isFlipY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isFlipY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isFlipY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRScaleX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRScaleY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setRScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setRScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setRScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setRScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRScaleX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRScaleX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRScaleY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRScaleY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateSpawnXPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateSpawnXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateSpawnXPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateSpawnXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateSpawnXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateSpawnXPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateSpawnXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct triggerActivated {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerActivated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerActivated))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::triggerActivated(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct triggerActivated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerActivated))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::triggerActivated(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct powerOnObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct powerOnObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOnObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::powerOnObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct powerOnObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOnObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::powerOnObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct powerOffObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct powerOffObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOffObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::powerOffObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct powerOffObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOffObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::powerOffObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGlowColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGlowColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGlowColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnXPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnXPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnXPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnXPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnXPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnXPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnXPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectRectDirty {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRectDirty))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRectDirty))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setObjectRectDirty {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObjectRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectRectDirty))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setObjectRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setObjectRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectRectDirty))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setObjectRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOrientedRectDirty {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedRectDirty))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOrientedRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedRectDirty))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOrientedRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setOrientedRectDirty {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOrientedRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrientedRectDirty))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setOrientedRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setOrientedRectDirty<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrientedRectDirty))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setOrientedRectDirty(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStartPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activatedByPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activatedByPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activatedByPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activatedByPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activatedByPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activatedByPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activatedByPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addColorSprite {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addColorSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSprite))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addColorSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addColorSprite<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSprite))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addColorSprite(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addColorSpriteToParent {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addColorSpriteToParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSpriteToParent))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addColorSpriteToParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addColorSpriteToParent<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSpriteToParent))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addColorSpriteToParent(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToTempOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToTempOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTempOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToTempOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToTempOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTempOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToTempOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct calculateOrientedBox {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOrientedBox))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::calculateOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct calculateOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOrientedBox))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::calculateOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct canChangeCustomColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct canChangeCustomColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canChangeCustomColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::canChangeCustomColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct canChangeCustomColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canChangeCustomColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::canChangeCustomColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorForMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct commonSetup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct commonSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commonSetup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::commonSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct commonSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commonSetup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::commonSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct copyGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::copyGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct copyGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::copyGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct destroyObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct destroyObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::destroyObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct destroyObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::destroyObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct determineSlopeDirection {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct determineSlopeDirection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::determineSlopeDirection))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::determineSlopeDirection(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct determineSlopeDirection<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::determineSlopeDirection))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::determineSlopeDirection(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getActiveColorForMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActiveColorForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveColorForMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getActiveColorForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getActiveColorForMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveColorForMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getActiveColorForMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBallFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBallFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBallFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBallFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBallFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBallFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBallFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getBoxOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBoxOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoxOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getBoxOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getBoxOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoxOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getBoxOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getColorIndex {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorIndex))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getColorIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getColorIndex<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorIndex))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getColorIndex(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getDidUpdateLastPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDidUpdateLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDidUpdateLastPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getDidUpdateLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getDidUpdateLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDidUpdateLastPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getDidUpdateLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLastPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMainColorMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainColorMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainColorMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectRadius {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRadius<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRadius))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectRadius(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRadius<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRadius))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectRadius(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSecondaryColorMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecondaryColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondaryColorMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSecondaryColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecondaryColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondaryColorMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSecondaryColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSectionIdx {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSectionIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSectionIdx))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSectionIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSectionIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSectionIdx))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSectionIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct groupWasDisabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct groupWasDisabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasDisabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::groupWasDisabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct groupWasDisabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasDisabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::groupWasDisabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct groupWasEnabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct groupWasEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasEnabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::groupWasEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct groupWasEnabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasEnabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::groupWasEnabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasBeenActivated {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivated))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasBeenActivated(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivated))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasBeenActivated(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasBeenActivatedByPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivatedByPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivatedByPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasBeenActivatedByPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivatedByPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivatedByPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasBeenActivatedByPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasSecondaryColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasSecondaryColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecondaryColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasSecondaryColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasSecondaryColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecondaryColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasSecondaryColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ignoreEnter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreEnter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreEnter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ignoreEnter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreEnter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreEnter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ignoreEnter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct ignoreFade {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreFade))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::ignoreFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct ignoreFade<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreFade))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::ignoreFade(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isBasicTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBasicTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBasicTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isBasicTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isBasicTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBasicTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isBasicTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isColorTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isColorTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isColorTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isColorTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isColorTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSpawnableTrigger {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSpawnableTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpawnableTrigger))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSpawnableTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSpawnableTrigger<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpawnableTrigger))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSpawnableTrigger(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isSpecialObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSpecialObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpecialObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isSpecialObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isSpecialObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpecialObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isSpecialObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectFromString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playShineEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playShineEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playShineEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playShineEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playShineEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playShineEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playShineEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct quickUpdatePosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct quickUpdatePosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quickUpdatePosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::quickUpdatePosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct quickUpdatePosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quickUpdatePosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::quickUpdatePosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeGlow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeGlow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeGlow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeGlow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeGlow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetGroupDisabled {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupDisabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupDisabled))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetGroupDisabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupDisabled<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupDisabled))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetGroupDisabled(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveActiveColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveActiveColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveActiveColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveActiveColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveActiveColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveActiveColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveActiveColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDefaultMainColorMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDefaultMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDefaultMainColorMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDefaultMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDefaultMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDefaultMainColorMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDefaultMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setDidUpdateLastPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDidUpdateLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDidUpdateLastPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setDidUpdateLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setDidUpdateLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDidUpdateLastPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setDidUpdateLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGlowOpacity {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOpacity))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGlowOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOpacity<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOpacity))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGlowOpacity(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setLastPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLastPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLastPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMainColorMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMainColorMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMainColorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMainColorMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMainColorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setSectionIdx {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSectionIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSectionIdx))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setSectionIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setSectionIdx<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSectionIdx))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setSectionIdx(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupCoinArt {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCoinArt<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCoinArt))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupCoinArt(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupCoinArt<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCoinArt))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupCoinArt(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct slopeFloorTop {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct slopeFloorTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeFloorTop))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::slopeFloorTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct slopeFloorTop<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeFloorTop))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::slopeFloorTop(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct slopeWallLeft {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct slopeWallLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeWallLeft))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::slopeWallLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct slopeWallLeft<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeWallLeft))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::slopeWallLeft(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCustomScale {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCustomScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCustomScale))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCustomScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCustomScale<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCustomScale))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCustomScale(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateMainColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateMainColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMainColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateMainColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateMainColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMainColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateMainColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOrientedBox {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOrientedBox))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOrientedBox<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOrientedBox))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOrientedBox(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSecondaryColor {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSecondaryColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSecondaryColor))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSecondaryColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSecondaryColor<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSecondaryColor))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSecondaryColor(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateStartPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStartPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateStartPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateSyncedAnimation {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSyncedAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSyncedAnimation))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateSyncedAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateSyncedAnimation<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSyncedAnimation))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateSyncedAnimation(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct deselectObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deselectObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::deselectObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct deselectObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::deselectObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createRotateAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRotateAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createRotateAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createRotateAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createRotateAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setMyAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMyAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMyAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setMyAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setMyAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMyAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setMyAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct awardCurrencyForLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardCurrencyForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardCurrencyForLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::awardCurrencyForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardCurrencyForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardCurrencyForLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::awardCurrencyForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct awardDiamondsForLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardDiamondsForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardDiamondsForLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::awardDiamondsForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardDiamondsForLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardDiamondsForLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::awardDiamondsForLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct awardSecretKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardSecretKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardSecretKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::awardSecretKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct awardSecretKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardSecretKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::awardSecretKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getSecretCoinKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecretCoinKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecretCoinKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getSecretCoinKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getSecretCoinKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecretCoinKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getSecretCoinKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getStat {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStat))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getStat(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getStat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStat))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getStat(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasPendingUserCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasPendingUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPendingUserCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasPendingUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasPendingUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPendingUserCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasPendingUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasSecretCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasSecretCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecretCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasSecretCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasSecretCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecretCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasSecretCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasUserCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUserCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUserCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct incrementStat {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementStat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementStat))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::incrementStat(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct incrementStat<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementStat))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::incrementStat(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storePendingUserCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storePendingUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storePendingUserCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storePendingUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storePendingUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storePendingUserCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storePendingUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storeSecretCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeSecretCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeSecretCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storeSecretCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeSecretCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeSecretCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storeSecretCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storeUserCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeUserCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storeUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeUserCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeUserCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storeUserCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addPoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addPoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addPoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addPoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addPoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct clearBehindXPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clearBehindXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearBehindXPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::clearBehindXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clearBehindXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearBehindXPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::clearBehindXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct firstSetup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct firstSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstSetup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::firstSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct firstSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstSetup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::firstSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct normalizeAngle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct normalizeAngle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::normalizeAngle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::normalizeAngle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct normalizeAngle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::normalizeAngle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::normalizeAngle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct quadCornerOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct quadCornerOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quadCornerOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::quadCornerOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct quadCornerOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quadCornerOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::quadCornerOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateStroke {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStroke))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateStroke<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStroke))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateStroke(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onPrevPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPrevPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPrevPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onPrevPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onPrevPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPrevPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onPrevPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onNextPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onNextPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onNextPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct goToPage {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct goToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::goToPage))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::goToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct goToPage<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::goToPage))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::goToPage(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct downloadFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct downloadFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::downloadFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct downloadFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::downloadFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct downloadFailed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct downloadFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFailed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::downloadFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct downloadFailed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFailed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::downloadFailed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct timeForXPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::timeForXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::timeForXPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct xPosForTime {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct xPosForTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::xPosForTime))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::xPosForTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct xPosForTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::xPosForTime))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::xPosForTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelSettingsUpdated {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelSettingsUpdated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelSettingsUpdated))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelSettingsUpdated(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelSettingsUpdated<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelSettingsUpdated))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelSettingsUpdated(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct activateTriggerEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateTriggerEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateTriggerEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::activateTriggerEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct activateTriggerEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateTriggerEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::activateTriggerEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addObjectFromString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectFromString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addObjectFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addObjectFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectFromString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addObjectFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addSpecial {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpecial))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpecial))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToRedoList {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToRedoList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToRedoList))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToRedoList(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToRedoList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToRedoList))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToRedoList(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToUndoList {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToUndoList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToUndoList))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToUndoList(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToUndoList<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToUndoList))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToUndoList(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animateInDualGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateInDualGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInDualGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animateInDualGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateInDualGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInDualGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animateInDualGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct checkCollisions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkCollisions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkCollisions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::checkCollisions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct checkCollisions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkCollisions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::checkCollisions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createBackground {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createBackground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBackground))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createBackground(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createBackground<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBackground))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createBackground(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createGroundLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createGroundLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createGroundLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createGroundLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createGroundLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createGroundLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createGroundLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createObjectsFromSetup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromSetup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createObjectsFromSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromSetup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromSetup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createObjectsFromSetup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createObjectsFromString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createObjectsFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createObjectsFromString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLastObjectX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastObjectX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastObjectX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLastObjectX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastObjectX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastObjectX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLastObjectX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLevelString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLevelString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLevelString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLevelString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLevelString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLevelString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLevelString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNextColorChannel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextColorChannel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextColorChannel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNextColorChannel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextColorChannel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextColorChannel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNextColorChannel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNextFreeBlockID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeBlockID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeBlockID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNextFreeBlockID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeBlockID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeBlockID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNextFreeBlockID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNextFreeGroupID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeGroupID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNextFreeGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeGroupID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeGroupID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNextFreeGroupID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getNextFreeItemID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeItemID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getNextFreeItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeItemID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getNextFreeItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRelativeOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRelativeOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRelativeOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct handleAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handleAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::handleAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct handleAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::handleAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectAtPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectAtPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectAtPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectAtPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectAtPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectMoved {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectMoved))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectMoved<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectMoved))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectMoved(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectsInRect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsInRect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectsInRect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsInRect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectsInRect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pasteAttributeState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pasteAttributeState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteAttributeState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pasteAttributeState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pasteAttributeState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteAttributeState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pasteAttributeState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playMusic {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playMusic))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playMusic))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct recreateGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct recreateGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recreateGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::recreateGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct recreateGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recreateGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::recreateGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeAllObjectsOfType {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjectsOfType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjectsOfType))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeAllObjectsOfType(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjectsOfType<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjectsOfType))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeAllObjectsOfType(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeSpecial {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeSpecial))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeSpecial<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeSpecial))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeSpecial(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetMovingObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMovingObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMovingObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetMovingObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetMovingObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMovingObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetMovingObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetObjectVector {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetObjectVector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObjectVector))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetObjectVector(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetObjectVector<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObjectVector))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetObjectVector(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetToggledGroupsAndObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroupsAndObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroupsAndObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetToggledGroupsAndObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroupsAndObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroupsAndObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetToggledGroupsAndObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetUnusedColorChannels {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetUnusedColorChannels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetUnusedColorChannels))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetUnusedColorChannels(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetUnusedColorChannels<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetUnusedColorChannels))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetUnusedColorChannels(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct rotationForSlopeNearObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rotationForSlopeNearObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotationForSlopeNearObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::rotationForSlopeNearObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct rotationForSlopeNearObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotationForSlopeNearObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::rotationForSlopeNearObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct runColorEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runColorEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runColorEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::runColorEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct runColorEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runColorEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::runColorEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupLevelStart {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelStart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelStart))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupLevelStart(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelStart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelStart))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupLevelStart(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sortStickyGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortStickyGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortStickyGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sortStickyGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortStickyGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortStickyGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sortStickyGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopTriggersInGroup {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopTriggersInGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopTriggersInGroup))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopTriggersInGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopTriggersInGroup<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopTriggersInGroup))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopTriggersInGroup(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleDualMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleDualMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDualMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleDualMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleDualMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDualMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleDualMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGroupPreview {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupPreview<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupPreview))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGroupPreview(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupPreview<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupPreview))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGroupPreview(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct transferDefaultColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transferDefaultColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transferDefaultColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::transferDefaultColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct transferDefaultColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transferDefaultColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::transferDefaultColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBGAndGColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGAndGColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGAndGColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBGAndGColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBGAndGColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGAndGColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBGAndGColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBlendValues {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendValues))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBlendValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendValues<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendValues))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBlendValues(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateDualGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDualGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDualGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateDualGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateDualGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDualGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateDualGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateEditorMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateEditorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateEditorMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGameObjectsNew {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGameObjectsNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGameObjectsNew))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGameObjectsNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGameObjectsNew<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGameObjectsNew))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGameObjectsNew(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateOptions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOptions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOptions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateOptions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateOptions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOptions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateOptions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateToggledGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateToggledGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateToggledGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateToggledGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateToggledGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateToggledGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateToggledGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onViewProfile {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onViewProfile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onViewProfile))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onViewProfile(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onViewProfile<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onViewProfile))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onViewProfile(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct objectFromDict {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromDict))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::objectFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct objectFromDict<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromDict))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::objectFromDict(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupColorsFromLegacyMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupColorsFromLegacyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupColorsFromLegacyMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupColorsFromLegacyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupColorsFromLegacyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupColorsFromLegacyMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupColorsFromLegacyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct willTweenToIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willTweenToIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willTweenToIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::willTweenToIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willTweenToIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willTweenToIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::willTweenToIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct didEndTweenToIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didEndTweenToIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didEndTweenToIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::didEndTweenToIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct didEndTweenToIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didEndTweenToIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::didEndTweenToIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct TableViewDidDisplayCellForRowAtIndexPath {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewDidDisplayCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewDidDisplayCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::TableViewDidDisplayCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct TableViewDidDisplayCellForRowAtIndexPath<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewDidDisplayCellForRowAtIndexPath))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::TableViewDidDisplayCellForRowAtIndexPath(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFromRefresh {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFromRefresh<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFromRefresh))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFromRefresh(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFromRefresh<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFromRefresh))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFromRefresh(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLoadingString {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLoadingString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadingString))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLoadingString(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLoadingString<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadingString))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLoadingString(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadAssets {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadAssets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadAssets))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadAssets(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadAssets<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadAssets))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadAssets(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadingFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadingFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadingFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadingFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadingFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadingFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadingFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToggle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToggle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToggle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToggle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToggle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToggle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToggle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onKeybindings {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onKeybindings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onKeybindings))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onKeybindings(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onKeybindings<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onKeybindings))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onKeybindings(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct frameToKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct frameToKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::frameToKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::frameToKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct frameToKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::frameToKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::frameToKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct intKeyToFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct intKeyToFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intKeyToFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::intKeyToFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct intKeyToFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intKeyToFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::intKeyToFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct keyToFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyToFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::keyToFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct keyToFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::keyToFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct gridNodeSizeForKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gridNodeSizeForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gridNodeSizeForKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::gridNodeSizeForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gridNodeSizeForKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gridNodeSizeForKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::gridNodeSizeForKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct perspectiveBlockFrame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct perspectiveBlockFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::perspectiveBlockFrame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::perspectiveBlockFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct perspectiveBlockFrame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::perspectiveBlockFrame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::perspectiveBlockFrame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct step {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct step<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::step))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::step(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct step<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::step))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::step(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToCurrentScene {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToCurrentScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToCurrentScene))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToCurrentScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToCurrentScene<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToCurrentScene))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToCurrentScene(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addCircle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addCircle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addCircle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addCircle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addCircle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToGroupOld {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroupOld<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroupOld))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToGroupOld(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToGroupOld<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroupOld))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToGroupOld(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct addToSpeedObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToSpeedObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSpeedObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::addToSpeedObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct addToSpeedObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSpeedObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::addToSpeedObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animateInGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateInGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animateInGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateInGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animateInGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animateOutGround {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGround))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animateOutGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGround<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGround))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animateOutGround(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct animateOutGroundFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGroundFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGroundFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::animateOutGroundFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGroundFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGroundFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::animateOutGroundFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct applyEnterEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applyEnterEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applyEnterEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::applyEnterEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct applyEnterEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applyEnterEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::applyEnterEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct cameraMoveX {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveX))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::cameraMoveX(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveX<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveX))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::cameraMoveX(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct cameraMoveY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::cameraMoveY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::cameraMoveY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct claimParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct claimParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::claimParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::claimParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct claimParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::claimParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::claimParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct clearPickedUpItems {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clearPickedUpItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearPickedUpItems))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::clearPickedUpItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct clearPickedUpItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearPickedUpItems))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::clearPickedUpItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct colorObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::colorObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct colorObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::colorObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct commitJumps {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct commitJumps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commitJumps))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::commitJumps(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct commitJumps<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commitJumps))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::commitJumps(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct delayedResetLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct delayedResetLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::delayedResetLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::delayedResetLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct delayedResetLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::delayedResetLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::delayedResetLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct destroyPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct destroyPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::destroyPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct destroyPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::destroyPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enterDualMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterDualMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterDualMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enterDualMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enterDualMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterDualMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enterDualMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitAirMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitAirMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitAirMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitAirMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitAirMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitAirMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitAirMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitBirdMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitBirdMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitBirdMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitBirdMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitBirdMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitBirdMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitBirdMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitDartMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitDartMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitDartMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitDartMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitDartMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitDartMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitDartMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitFlyMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitFlyMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitFlyMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitRobotMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRobotMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRobotMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitRollMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRollMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRollMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct exitSpiderMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitSpiderMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::exitSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct exitSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitSpiderMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::exitSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct flipFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::flipFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::flipFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct flipObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::flipObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct flipObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::flipObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct fullReset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fullReset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fullReset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::fullReset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct fullReset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fullReset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::fullReset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getLastCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMaxPortalY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxPortalY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxPortalY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMaxPortalY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMaxPortalY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxPortalY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMaxPortalY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getMinPortalY {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMinPortalY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinPortalY))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getMinPortalY(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getMinPortalY<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinPortalY))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getMinPortalY(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getObjectsState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectsState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectsState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getObjectsState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getObjectsState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectsState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getObjectsState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getOtherPlayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOtherPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOtherPlayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getOtherPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getOtherPlayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOtherPlayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getOtherPlayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getParticleKey {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getParticleKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getParticleKey(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getParticleKey2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getParticleKey2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getParticleKey2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getRelativeMod {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeMod))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getRelativeMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeMod<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeMod))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getRelativeMod(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getTempMilliTime {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTempMilliTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTempMilliTime))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getTempMilliTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getTempMilliTime<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTempMilliTime))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getTempMilliTime(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct gravityEffectFinished {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityEffectFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityEffectFinished))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::gravityEffectFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct gravityEffectFinished<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityEffectFinished))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::gravityEffectFinished(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasUniqueCoin {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasUniqueCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUniqueCoin))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasUniqueCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasUniqueCoin<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUniqueCoin))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasUniqueCoin(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct isFlipping {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipping<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipping))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::isFlipping(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct isFlipping<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipping))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::isFlipping(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct levelComplete {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelComplete<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelComplete))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::levelComplete(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct levelComplete<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelComplete))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::levelComplete(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct lightningFlash {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lightningFlash<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lightningFlash))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::lightningFlash(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct lightningFlash<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lightningFlash))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::lightningFlash(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadDefaultColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadDefaultColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDefaultColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadDefaultColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadDefaultColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDefaultColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadDefaultColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadLastCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadLastCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadLastCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct loadSavedObjectsState {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadSavedObjectsState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSavedObjectsState))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::loadSavedObjectsState(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct loadSavedObjectsState<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSavedObjectsState))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::loadSavedObjectsState(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct markCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct markCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::markCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::markCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct markCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::markCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::markCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct moveCameraToPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveCameraToPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveCameraToPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::moveCameraToPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct moveCameraToPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveCameraToPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::moveCameraToPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct optimizeColorGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeColorGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeColorGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::optimizeColorGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeColorGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeColorGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::optimizeColorGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct optimizeOpacityGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeOpacityGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeOpacityGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::optimizeOpacityGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeOpacityGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeOpacityGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::optimizeOpacityGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct optimizeSaveRequiredGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeSaveRequiredGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeSaveRequiredGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::optimizeSaveRequiredGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct optimizeSaveRequiredGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeSaveRequiredGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::optimizeSaveRequiredGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pauseGame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pauseGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseGame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pauseGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pauseGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseGame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pauseGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pickupItem {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pickupItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pickupItem))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pickupItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pickupItem<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pickupItem))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pickupItem(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playAnimationCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playAnimationCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimationCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playAnimationCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playAnimationCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimationCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playAnimationCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playEndAnimationToPos {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playEndAnimationToPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEndAnimationToPos))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playEndAnimationToPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playEndAnimationToPos<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEndAnimationToPos))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playEndAnimationToPos(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playExitDualEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playExitDualEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playExitDualEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playExitDualEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playExitDualEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playExitDualEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playExitDualEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playFlashEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playFlashEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playFlashEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playFlashEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playFlashEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playFlashEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playFlashEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playGravityEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playGravityEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playGravityEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playGravityEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playGravityEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playGravityEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playGravityEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playSpeedParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playSpeedParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playSpeedParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playSpeedParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playSpeedParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playSpeedParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playSpeedParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct playerWillSwitchMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerWillSwitchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerWillSwitchMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::playerWillSwitchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct playerWillSwitchMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerWillSwitchMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::playerWillSwitchMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct prepareSpawnObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct prepareSpawnObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareSpawnObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::prepareSpawnObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct prepareSpawnObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareSpawnObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::prepareSpawnObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processItems {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processItems))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processItems<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processItems))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processItems(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct processLoadedMoveActions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processLoadedMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processLoadedMoveActions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::processLoadedMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct processLoadedMoveActions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processLoadedMoveActions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::processLoadedMoveActions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct recordAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct recordAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recordAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::recordAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct recordAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recordAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::recordAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerActiveObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerActiveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerActiveObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerActiveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerActiveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerActiveObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerActiveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct registerStateObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerStateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerStateObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::registerStateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct registerStateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerStateObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::registerStateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeFromGroupOld {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroupOld<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroupOld))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeFromGroupOld(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroupOld<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroupOld))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeFromGroupOld(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removeLastCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removeLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removeLastCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removeLastCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct removePlayer2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removePlayer2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePlayer2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::removePlayer2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct removePlayer2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePlayer2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::removePlayer2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resetLevel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetLevel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resetLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resetLevel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetLevel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resetLevel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resume {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resume<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resume))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resume(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resume<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resume))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resume(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct resumeAndRestart {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeAndRestart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeAndRestart))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::resumeAndRestart(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct resumeAndRestart<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeAndRestart))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::resumeAndRestart(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct saveRecordAction {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveRecordAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveRecordAction))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::saveRecordAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct saveRecordAction<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveRecordAction))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::saveRecordAction(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupReplay {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupReplay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupReplay))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupReplay(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupReplay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupReplay))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupReplay(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct shakeCamera {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shakeCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shakeCamera))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::shakeCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct shakeCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shakeCamera))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::shakeCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showCompleteEffect {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteEffect))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showCompleteEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteEffect<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteEffect))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showCompleteEffect(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showCompleteText {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteText<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteText))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showCompleteText(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteText<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteText))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showCompleteText(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showEndLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showEndLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showEndLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showEndLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showEndLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showEndLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showEndLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showHint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showHint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showHint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showHint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showHint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showHint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showHint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showNewBest {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showNewBest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNewBest))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showNewBest(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showNewBest<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNewBest))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showNewBest(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showRetryLayer {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showRetryLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showRetryLayer))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showRetryLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showRetryLayer<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showRetryLayer))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showRetryLayer(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct showTwoPlayerGuide {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showTwoPlayerGuide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showTwoPlayerGuide))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::showTwoPlayerGuide(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct showTwoPlayerGuide<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showTwoPlayerGuide))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::showTwoPlayerGuide(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct sortGroups {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortGroups))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::sortGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct sortGroups<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortGroups))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::sortGroups(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnFirework {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnFirework<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFirework))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnFirework(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnFirework<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFirework))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnFirework(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct spawnPlayer2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnPlayer2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPlayer2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::spawnPlayer2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct spawnPlayer2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPlayer2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::spawnPlayer2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startGame {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startGame))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startGame<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startGame))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startGame(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startMusic {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startMusic))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startMusic<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startMusic))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startMusic(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startRecording {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startRecording<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecording))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startRecording(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startRecording<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecording))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startRecording(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct startRecordingDelayed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startRecordingDelayed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecordingDelayed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::startRecordingDelayed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct startRecordingDelayed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecordingDelayed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::startRecordingDelayed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopCameraShake {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopCameraShake<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopCameraShake))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopCameraShake(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopCameraShake<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopCameraShake))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopCameraShake(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct stopRecording {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopRecording<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRecording))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::stopRecording(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct stopRecording<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRecording))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::stopRecording(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct storeCheckpoint {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCheckpoint))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::storeCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct storeCheckpoint<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCheckpoint))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::storeCheckpoint(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct switchToFlyMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToFlyMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::switchToFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToFlyMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToFlyMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::switchToFlyMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct switchToRobotMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRobotMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::switchToRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToRobotMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRobotMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::switchToRobotMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct switchToRollMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRollMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::switchToRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToRollMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRollMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::switchToRollMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct switchToSpiderMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToSpiderMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::switchToSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct switchToSpiderMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToSpiderMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::switchToSpiderMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct timeForXPos2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::timeForXPos2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::timeForXPos2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleBGEffectVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleBGEffectVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBGEffectVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleBGEffectVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleBGEffectVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBGEffectVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleBGEffectVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleFlipped {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlipped<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlipped))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleFlipped(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlipped<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlipped))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleFlipped(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleGlitter {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGlitter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGlitter))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleGlitter(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleGlitter<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGlitter))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleGlitter(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct togglePracticeMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePracticeMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePracticeMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::togglePracticeMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct togglePracticeMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePracticeMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::togglePracticeMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleProgressbar {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleProgressbar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleProgressbar))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleProgressbar(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleProgressbar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleProgressbar))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleProgressbar(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct tryStartRecord {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tryStartRecord<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryStartRecord))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::tryStartRecord(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct tryStartRecord<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryStartRecord))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::tryStartRecord(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unclaimParticle {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unclaimParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unclaimParticle))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unclaimParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unclaimParticle<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unclaimParticle))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unclaimParticle(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unregisterActiveObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterActiveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterActiveObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unregisterActiveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterActiveObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterActiveObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unregisterActiveObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct unregisterStateObject {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterStateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterStateObject))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::unregisterStateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct unregisterStateObject<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterStateObject))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::unregisterStateObject(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateAttempts {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateAttempts<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateAttempts))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateAttempts(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateAttempts<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateAttempts))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateAttempts(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateCamera {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCamera))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateCamera<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCamera))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateCamera(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateEffectPositions {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEffectPositions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffectPositions))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateEffectPositions(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEffectPositions<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffectPositions))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateEffectPositions(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateLevelColors {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLevelColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLevelColors))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateLevelColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateLevelColors<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLevelColors))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateLevelColors(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateMoveObjectsLastPosition {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateMoveObjectsLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMoveObjectsLastPosition))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateMoveObjectsLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateMoveObjectsLastPosition<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMoveObjectsLastPosition))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateMoveObjectsLastPosition(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateProgressbar {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateProgressbar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateProgressbar))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateProgressbar(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateProgressbar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateProgressbar))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateProgressbar(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateReplay {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateReplay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateReplay))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateReplay(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateReplay<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateReplay))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateReplay(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct vfDChk {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct vfDChk<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::vfDChk))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::vfDChk(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct vfDChk<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::vfDChk))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::vfDChk(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct visitWithColorFlash {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct visitWithColorFlash<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visitWithColorFlash))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::visitWithColorFlash(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct visitWithColorFlash<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visitWithColorFlash))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::visitWithColorFlash(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct willSwitchToMode {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToMode))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::willSwitchToMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToMode<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToMode))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::willSwitchToMode(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onNextGroupID1 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextGroupID1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextGroupID1))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onNextGroupID1(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onNextGroupID1<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextGroupID1))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onNextGroupID1(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateGroupIDLabel {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGroupIDLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroupIDLabel))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateGroupIDLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateGroupIDLabel<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroupIDLabel))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateGroupIDLabel(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateEditorLayerID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateEditorLayerID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateEditorLayerID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateEditorLayerID2 {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID2))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateEditorLayerID2(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID2<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID2))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateEditorLayerID2(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateZOrder {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZOrder))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateZOrder<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZOrder))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateZOrder(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onItemIDArrow {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onItemIDArrow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onItemIDArrow))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onItemIDArrow(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onItemIDArrow<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onItemIDArrow))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onItemIDArrow(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateItemID {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateItemID))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateItemID<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateItemID))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateItemID(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct hasGlowOutline {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasGlowOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasGlowOutline))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::hasGlowOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct hasGlowOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasGlowOutline))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::hasGlowOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setGlowOutline {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOutline))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setGlowOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOutline<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOutline))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setGlowOutline(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setFrames {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFrames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFrames))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setFrames(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setFrames<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFrames))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setFrames(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setBarVisibility {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBarVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBarVisibility))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setBarVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setBarVisibility<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBarVisibility))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setBarVisibility(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getValue {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getValue))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getValue<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getValue))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getValue(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct updateBar {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBar))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::updateBar(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct updateBar<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBar))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::updateBar(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct getThumb {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getThumb<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getThumb))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::getThumb(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct getThumb<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getThumb))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::getThumb(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textInputOpened {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputOpened<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputOpened))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textInputOpened(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputOpened<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputOpened))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textInputOpened(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textInputClosed {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputClosed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputClosed))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textInputClosed(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputClosed<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputClosed))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textInputClosed(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textInputShouldOffset {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputShouldOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputShouldOffset))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textInputShouldOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputShouldOffset<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputShouldOffset))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textInputShouldOffset(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct textInputReturn {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputReturn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputReturn))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::textInputReturn(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct textInputReturn<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputReturn))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::textInputReturn(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct allowTextInput {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct allowTextInput<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allowTextInput))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::allowTextInput(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct allowTextInput<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allowTextInput))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::allowTextInput(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupLeaderboard {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLeaderboard<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLeaderboard))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupLeaderboard(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupLeaderboard<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLeaderboard))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupLeaderboard(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct setupPageInfo {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupPageInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupPageInfo))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::setupPageInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct setupPageInfo<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupPageInfo))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::setupPageInfo(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct disableMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::disableMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct disableMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::disableMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct enableMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::enableMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct enableMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::enableMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct pCommand {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pCommand))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::pCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct pCommand<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pCommand))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::pCommand(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct toggleCheckpointsMenu {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleCheckpointsMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleCheckpointsMenu))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::toggleCheckpointsMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct toggleCheckpointsMenu<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleCheckpointsMenu))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::toggleCheckpointsMenu(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onCheck {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCheck))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCheck))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct onDeleteCheck {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteCheck))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::onDeleteCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteCheck<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteCheck))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::onDeleteCheck(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};


template <template <class, class...> class, class, class, class, class = void>
struct createWithTransformObjects {
private:
	static void wrapper(...) {}
public:
	constexpr static inline auto value = &wrapper;
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithTransformObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	std::is_member_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTransformObjects))>
>> {
private:
	static Ret wrapper(Derived* self, Parameters... ps) {
		return self->Derived::createWithTransformObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Derived*, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

template <template <class, class...> class Conv, class Derived, class Base, class Ret, class ...Parameters>
struct createWithTransformObjects<Conv, Derived, Base, Ret(Parameters...), std::enable_if_t<
	is_function_pointer_v<decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTransformObjects))>
>> {
private:
	static Ret wrapper(Parameters... ps) {
		return Derived::createWithTransformObjects(ps...);
	}
public:
	using MyConv = Conv<Ret, Parameters...>;
	constexpr static inline auto value = MyConv::template get_wrapper<&wrapper>();
};

