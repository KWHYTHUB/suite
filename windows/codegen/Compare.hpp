
template <class, class, class, class = void>
struct pop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pop>::value != 
		function_uuid<(base_type)&Base::pop>::value;
};


template <class, class, class, class = void>
struct sharedPoolManager {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedPoolManager<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedPoolManager)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedPoolManager))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedPoolManager));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedPoolManager));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedPoolManager>::value != 
		function_uuid<(base_type)&Base::sharedPoolManager>::value;
};


template <class, class, class, class = void>
struct update {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct update<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::update)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::update))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::update));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::update));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::update>::value != 
		function_uuid<(base_type)&Base::update>::value;
};


template <class, class, class, class = void>
struct setScaleX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setScaleX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScaleX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScaleX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setScaleX>::value != 
		function_uuid<(base_type)&Base::setScaleX>::value;
};


template <class, class, class, class = void>
struct setScaleY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setScaleY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScaleY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScaleY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScaleY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setScaleY>::value != 
		function_uuid<(base_type)&Base::setScaleY>::value;
};


template <class, class, class, class = void>
struct setScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setScale>::value != 
		function_uuid<(base_type)&Base::setScale>::value;
};


template <class, class, class, class = void>
struct setPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPosition>::value != 
		function_uuid<(base_type)&Base::setPosition>::value;
};


template <class, class, class, class = void>
struct setVisible {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setVisible<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVisible)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVisible))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVisible));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVisible));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setVisible>::value != 
		function_uuid<(base_type)&Base::setVisible>::value;
};


template <class, class, class, class = void>
struct setRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRotation>::value != 
		function_uuid<(base_type)&Base::setRotation>::value;
};


template <class, class, class, class = void>
struct setOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setOpacity>::value != 
		function_uuid<(base_type)&Base::setOpacity>::value;
};


template <class, class, class, class = void>
struct setColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setColor>::value != 
		function_uuid<(base_type)&Base::setColor>::value;
};


template <class, class, class, class = void>
struct setFlipX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFlipX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFlipX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFlipX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFlipX>::value != 
		function_uuid<(base_type)&Base::setFlipX>::value;
};


template <class, class, class, class = void>
struct setFlipY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFlipY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFlipY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFlipY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFlipY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFlipY>::value != 
		function_uuid<(base_type)&Base::setFlipY>::value;
};


template <class, class, class, class = void>
struct resetObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetObject>::value != 
		function_uuid<(base_type)&Base::resetObject>::value;
};


template <class, class, class, class = void>
struct getRealPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRealPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRealPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRealPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRealPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRealPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRealPosition>::value != 
		function_uuid<(base_type)&Base::getRealPosition>::value;
};


template <class, class, class, class = void>
struct getOrientedBox {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedBox<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrientedBox)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedBox))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrientedBox));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedBox));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOrientedBox>::value != 
		function_uuid<(base_type)&Base::getOrientedBox>::value;
};


template <class, class, class, class = void>
struct animationFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animationFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animationFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animationFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animationFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animationFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animationFinished>::value != 
		function_uuid<(base_type)&Base::animationFinished>::value;
};


template <class, class, class, class = void>
struct activateStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activateStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activateStreak>::value != 
		function_uuid<(base_type)&Base::activateStreak>::value;
};


template <class, class, class, class = void>
struct addAllParticles {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addAllParticles<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addAllParticles)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllParticles))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addAllParticles));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllParticles));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addAllParticles>::value != 
		function_uuid<(base_type)&Base::addAllParticles>::value;
};


template <class, class, class, class = void>
struct addToTouchedRings {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToTouchedRings<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToTouchedRings)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTouchedRings))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToTouchedRings));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTouchedRings));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToTouchedRings>::value != 
		function_uuid<(base_type)&Base::addToTouchedRings>::value;
};


template <class, class, class, class = void>
struct boostPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct boostPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::boostPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boostPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::boostPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boostPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::boostPlayer>::value != 
		function_uuid<(base_type)&Base::boostPlayer>::value;
};


template <class, class, class, class = void>
struct bumpPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct bumpPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::bumpPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bumpPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::bumpPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bumpPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::bumpPlayer>::value != 
		function_uuid<(base_type)&Base::bumpPlayer>::value;
};


template <class, class, class, class = void>
struct buttonDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct buttonDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::buttonDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::buttonDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::buttonDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::buttonDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::buttonDown>::value != 
		function_uuid<(base_type)&Base::buttonDown>::value;
};


template <class, class, class, class = void>
struct checkSnapJumpToObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct checkSnapJumpToObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkSnapJumpToObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSnapJumpToObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkSnapJumpToObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSnapJumpToObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::checkSnapJumpToObject>::value != 
		function_uuid<(base_type)&Base::checkSnapJumpToObject>::value;
};


template <class, class, class, class = void>
struct collidedWithObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collidedWithObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collidedWithObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::collidedWithObject>::value != 
		function_uuid<(base_type)&Base::collidedWithObject>::value;
};


template <class, class, class, class = void>
struct collidedWithSlope {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct collidedWithSlope<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collidedWithSlope)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithSlope))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collidedWithSlope));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collidedWithSlope));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::collidedWithSlope>::value != 
		function_uuid<(base_type)&Base::collidedWithSlope>::value;
};


template <class, class, class, class = void>
struct convertToClosestRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct convertToClosestRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToClosestRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToClosestRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToClosestRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToClosestRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::convertToClosestRotation>::value != 
		function_uuid<(base_type)&Base::convertToClosestRotation>::value;
};


template <class, class, class, class = void>
struct copyAttributes {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct copyAttributes<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyAttributes)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyAttributes))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyAttributes));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyAttributes));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::copyAttributes>::value != 
		function_uuid<(base_type)&Base::copyAttributes>::value;
};


template <class, class, class, class = void>
struct create {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct create<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::create)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::create))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::create));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::create));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::create>::value != 
		function_uuid<(base_type)&Base::create>::value;
};


template <class, class, class, class = void>
struct deactivateParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct deactivateParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::deactivateParticle>::value != 
		function_uuid<(base_type)&Base::deactivateParticle>::value;
};


template <class, class, class, class = void>
struct deactivateStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct deactivateStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::deactivateStreak>::value != 
		function_uuid<(base_type)&Base::deactivateStreak>::value;
};


template <class, class, class, class = void>
struct fadeOutStreak2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fadeOutStreak2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeOutStreak2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeOutStreak2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeOutStreak2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeOutStreak2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fadeOutStreak2>::value != 
		function_uuid<(base_type)&Base::fadeOutStreak2>::value;
};


template <class, class, class, class = void>
struct flashPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct flashPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flashPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flashPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flashPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flashPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::flashPlayer>::value != 
		function_uuid<(base_type)&Base::flashPlayer>::value;
};


template <class, class, class, class = void>
struct flipGravity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct flipGravity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipGravity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipGravity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipGravity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipGravity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::flipGravity>::value != 
		function_uuid<(base_type)&Base::flipGravity>::value;
};


template <class, class, class, class = void>
struct flipMod {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct flipMod<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipMod)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipMod))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipMod));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipMod));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::flipMod>::value != 
		function_uuid<(base_type)&Base::flipMod>::value;
};


template <class, class, class, class = void>
struct getActiveMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getActiveMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActiveMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActiveMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getActiveMode>::value != 
		function_uuid<(base_type)&Base::getActiveMode>::value;
};


template <class, class, class, class = void>
struct getModifiedSlopeYVel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getModifiedSlopeYVel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getModifiedSlopeYVel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getModifiedSlopeYVel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getModifiedSlopeYVel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getModifiedSlopeYVel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getModifiedSlopeYVel>::value != 
		function_uuid<(base_type)&Base::getModifiedSlopeYVel>::value;
};


template <class, class, class, class = void>
struct getOldPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOldPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOldPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOldPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOldPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOldPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOldPosition>::value != 
		function_uuid<(base_type)&Base::getOldPosition>::value;
};


template <class, class, class, class = void>
struct getSecondColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSecondColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecondColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecondColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSecondColor>::value != 
		function_uuid<(base_type)&Base::getSecondColor>::value;
};


template <class, class, class, class = void>
struct gravityDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct gravityDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::gravityDown>::value != 
		function_uuid<(base_type)&Base::gravityDown>::value;
};


template <class, class, class, class = void>
struct gravityUp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct gravityUp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityUp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityUp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityUp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityUp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::gravityUp>::value != 
		function_uuid<(base_type)&Base::gravityUp>::value;
};


template <class, class, class, class = void>
struct hardFlipGravity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hardFlipGravity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hardFlipGravity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hardFlipGravity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hardFlipGravity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hardFlipGravity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hardFlipGravity>::value != 
		function_uuid<(base_type)&Base::hardFlipGravity>::value;
};


template <class, class, class, class = void>
struct hitGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hitGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hitGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hitGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hitGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hitGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hitGround>::value != 
		function_uuid<(base_type)&Base::hitGround>::value;
};


template <class, class, class, class = void>
struct incrementJumps {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct incrementJumps<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementJumps)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementJumps))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementJumps));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementJumps));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::incrementJumps>::value != 
		function_uuid<(base_type)&Base::incrementJumps>::value;
};


template <class, class, class, class = void>
struct init {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct init<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::init)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::init))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::init));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::init));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::init>::value != 
		function_uuid<(base_type)&Base::init>::value;
};


template <class, class, class, class = void>
struct isBoostValid {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isBoostValid<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBoostValid)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBoostValid))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBoostValid));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBoostValid));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isBoostValid>::value != 
		function_uuid<(base_type)&Base::isBoostValid>::value;
};


template <class, class, class, class = void>
struct isFlying {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isFlying<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlying)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlying))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlying));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlying));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isFlying>::value != 
		function_uuid<(base_type)&Base::isFlying>::value;
};


template <class, class, class, class = void>
struct isSafeFlip {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSafeFlip<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeFlip)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeFlip))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeFlip));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeFlip));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSafeFlip>::value != 
		function_uuid<(base_type)&Base::isSafeFlip>::value;
};


template <class, class, class, class = void>
struct isSafeMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSafeMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSafeMode>::value != 
		function_uuid<(base_type)&Base::isSafeMode>::value;
};


template <class, class, class, class = void>
struct isSafeSpiderFlip {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSafeSpiderFlip<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeSpiderFlip)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeSpiderFlip))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSafeSpiderFlip));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSafeSpiderFlip));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSafeSpiderFlip>::value != 
		function_uuid<(base_type)&Base::isSafeSpiderFlip>::value;
};


template <class, class, class, class = void>
struct levelFlipFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelFlipFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelFlipFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelFlipFinished>::value != 
		function_uuid<(base_type)&Base::levelFlipFinished>::value;
};


template <class, class, class, class = void>
struct levelFlipping {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelFlipping<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelFlipping)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipping))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelFlipping));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelFlipping));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelFlipping>::value != 
		function_uuid<(base_type)&Base::levelFlipping>::value;
};


template <class, class, class, class = void>
struct levelWillFlip {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelWillFlip<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelWillFlip)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWillFlip))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelWillFlip));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWillFlip));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelWillFlip>::value != 
		function_uuid<(base_type)&Base::levelWillFlip>::value;
};


template <class, class, class, class = void>
struct loadFromCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFromCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFromCheckpoint>::value != 
		function_uuid<(base_type)&Base::loadFromCheckpoint>::value;
};


template <class, class, class, class = void>
struct lockPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct lockPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lockPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lockPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lockPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lockPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::lockPlayer>::value != 
		function_uuid<(base_type)&Base::lockPlayer>::value;
};


template <class, class, class, class = void>
struct logValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct logValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::logValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::logValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::logValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::logValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::logValues>::value != 
		function_uuid<(base_type)&Base::logValues>::value;
};


template <class, class, class, class = void>
struct modeDidChange {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct modeDidChange<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::modeDidChange)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::modeDidChange))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::modeDidChange));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::modeDidChange));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::modeDidChange>::value != 
		function_uuid<(base_type)&Base::modeDidChange>::value;
};


template <class, class, class, class = void>
struct placeStreakPoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct placeStreakPoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::placeStreakPoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::placeStreakPoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::placeStreakPoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::placeStreakPoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::placeStreakPoint>::value != 
		function_uuid<(base_type)&Base::placeStreakPoint>::value;
};


template <class, class, class, class = void>
struct playBurstEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playBurstEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playBurstEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBurstEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playBurstEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBurstEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playBurstEffect>::value != 
		function_uuid<(base_type)&Base::playBurstEffect>::value;
};


template <class, class, class, class = void>
struct playDeathEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playDeathEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playDeathEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDeathEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playDeathEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDeathEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playDeathEffect>::value != 
		function_uuid<(base_type)&Base::playDeathEffect>::value;
};


template <class, class, class, class = void>
struct playDynamicSpiderRun {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playDynamicSpiderRun<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playDynamicSpiderRun)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDynamicSpiderRun))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playDynamicSpiderRun));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playDynamicSpiderRun));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playDynamicSpiderRun>::value != 
		function_uuid<(base_type)&Base::playDynamicSpiderRun>::value;
};


template <class, class, class, class = void>
struct playerDestroyed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerDestroyed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerDestroyed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDestroyed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerDestroyed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDestroyed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerDestroyed>::value != 
		function_uuid<(base_type)&Base::playerDestroyed>::value;
};


template <class, class, class, class = void>
struct playerIsFalling {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerIsFalling<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerIsFalling)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerIsFalling))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerIsFalling));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerIsFalling));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerIsFalling>::value != 
		function_uuid<(base_type)&Base::playerIsFalling>::value;
};


template <class, class, class, class = void>
struct playerTeleported {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerTeleported<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTeleported)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTeleported))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTeleported));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTeleported));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerTeleported>::value != 
		function_uuid<(base_type)&Base::playerTeleported>::value;
};


template <class, class, class, class = void>
struct playingEndEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playingEndEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playingEndEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playingEndEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playingEndEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playingEndEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playingEndEffect>::value != 
		function_uuid<(base_type)&Base::playingEndEffect>::value;
};


template <class, class, class, class = void>
struct postCollision {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct postCollision<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postCollision)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollision))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postCollision));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollision));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::postCollision>::value != 
		function_uuid<(base_type)&Base::postCollision>::value;
};


template <class, class, class, class = void>
struct preCollision {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct preCollision<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preCollision)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollision))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preCollision));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollision));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::preCollision>::value != 
		function_uuid<(base_type)&Base::preCollision>::value;
};


template <class, class, class, class = void>
struct preSlopeCollision {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct preSlopeCollision<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preSlopeCollision)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preSlopeCollision))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preSlopeCollision));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preSlopeCollision));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::preSlopeCollision>::value != 
		function_uuid<(base_type)&Base::preSlopeCollision>::value;
};


template <class, class, class, class = void>
struct propellPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct propellPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::propellPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::propellPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::propellPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::propellPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::propellPlayer>::value != 
		function_uuid<(base_type)&Base::propellPlayer>::value;
};


template <class, class, class, class = void>
struct pushButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pushButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pushButton>::value != 
		function_uuid<(base_type)&Base::pushButton>::value;
};


template <class, class, class, class = void>
struct pushDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pushDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pushDown>::value != 
		function_uuid<(base_type)&Base::pushDown>::value;
};


template <class, class, class, class = void>
struct pushPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pushPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pushPlayer>::value != 
		function_uuid<(base_type)&Base::pushPlayer>::value;
};


template <class, class, class, class = void>
struct releaseButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct releaseButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::releaseButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::releaseButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::releaseButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::releaseButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::releaseButton>::value != 
		function_uuid<(base_type)&Base::releaseButton>::value;
};


template <class, class, class, class = void>
struct removeAllParticles {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllParticles<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllParticles)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllParticles))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllParticles));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllParticles));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllParticles>::value != 
		function_uuid<(base_type)&Base::removeAllParticles>::value;
};


template <class, class, class, class = void>
struct removePendingCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removePendingCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removePendingCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePendingCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removePendingCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePendingCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removePendingCheckpoint>::value != 
		function_uuid<(base_type)&Base::removePendingCheckpoint>::value;
};


template <class, class, class, class = void>
struct resetAllParticles {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetAllParticles<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetAllParticles)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAllParticles))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetAllParticles));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAllParticles));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetAllParticles>::value != 
		function_uuid<(base_type)&Base::resetAllParticles>::value;
};


template <class, class, class, class = void>
struct resetCollisionLog {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetCollisionLog<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetCollisionLog)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetCollisionLog))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetCollisionLog));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetCollisionLog));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetCollisionLog>::value != 
		function_uuid<(base_type)&Base::resetCollisionLog>::value;
};


template <class, class, class, class = void>
struct resetPlayerIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayerIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetPlayerIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayerIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetPlayerIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayerIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetPlayerIcon>::value != 
		function_uuid<(base_type)&Base::resetPlayerIcon>::value;
};


template <class, class, class, class = void>
struct resetStateVariables {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetStateVariables<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetStateVariables)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStateVariables))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetStateVariables));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStateVariables));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetStateVariables>::value != 
		function_uuid<(base_type)&Base::resetStateVariables>::value;
};


template <class, class, class, class = void>
struct resetStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetStreak>::value != 
		function_uuid<(base_type)&Base::resetStreak>::value;
};


template <class, class, class, class = void>
struct ringJump {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ringJump<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ringJump)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ringJump))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ringJump));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ringJump));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ringJump>::value != 
		function_uuid<(base_type)&Base::ringJump>::value;
};


template <class, class, class, class = void>
struct runBallRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runBallRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runBallRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runBallRotation>::value != 
		function_uuid<(base_type)&Base::runBallRotation>::value;
};


template <class, class, class, class = void>
struct runBallRotation2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runBallRotation2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runBallRotation2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runBallRotation2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runBallRotation2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runBallRotation2>::value != 
		function_uuid<(base_type)&Base::runBallRotation2>::value;
};


template <class, class, class, class = void>
struct runNormalRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runNormalRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runNormalRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runNormalRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runNormalRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runNormalRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runNormalRotation>::value != 
		function_uuid<(base_type)&Base::runNormalRotation>::value;
};


template <class, class, class, class = void>
struct runRotateAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runRotateAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runRotateAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runRotateAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runRotateAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runRotateAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runRotateAction>::value != 
		function_uuid<(base_type)&Base::runRotateAction>::value;
};


template <class, class, class, class = void>
struct saveToCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveToCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveToCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveToCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveToCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveToCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveToCheckpoint>::value != 
		function_uuid<(base_type)&Base::saveToCheckpoint>::value;
};


template <class, class, class, class = void>
struct setSecondColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSecondColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSecondColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSecondColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSecondColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSecondColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSecondColor>::value != 
		function_uuid<(base_type)&Base::setSecondColor>::value;
};


template <class, class, class, class = void>
struct setupStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupStreak>::value != 
		function_uuid<(base_type)&Base::setupStreak>::value;
};


template <class, class, class, class = void>
struct spawnCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnCircle>::value != 
		function_uuid<(base_type)&Base::spawnCircle>::value;
};


template <class, class, class, class = void>
struct spawnCircle2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnCircle2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnCircle2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnCircle2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnCircle2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnCircle2>::value != 
		function_uuid<(base_type)&Base::spawnCircle2>::value;
};


template <class, class, class, class = void>
struct spawnDualCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnDualCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnDualCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnDualCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnDualCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnDualCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnDualCircle>::value != 
		function_uuid<(base_type)&Base::spawnDualCircle>::value;
};


template <class, class, class, class = void>
struct spawnFromPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnFromPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnFromPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFromPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnFromPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFromPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnFromPlayer>::value != 
		function_uuid<(base_type)&Base::spawnFromPlayer>::value;
};


template <class, class, class, class = void>
struct spawnPortalCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnPortalCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnPortalCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPortalCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnPortalCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPortalCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnPortalCircle>::value != 
		function_uuid<(base_type)&Base::spawnPortalCircle>::value;
};


template <class, class, class, class = void>
struct spawnScaleCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnScaleCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnScaleCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnScaleCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnScaleCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnScaleCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnScaleCircle>::value != 
		function_uuid<(base_type)&Base::spawnScaleCircle>::value;
};


template <class, class, class, class = void>
struct specialGroundHit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct specialGroundHit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::specialGroundHit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::specialGroundHit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::specialGroundHit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::specialGroundHit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::specialGroundHit>::value != 
		function_uuid<(base_type)&Base::specialGroundHit>::value;
};


template <class, class, class, class = void>
struct speedDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct speedDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::speedDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::speedDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::speedDown>::value != 
		function_uuid<(base_type)&Base::speedDown>::value;
};


template <class, class, class, class = void>
struct speedUp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct speedUp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::speedUp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedUp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::speedUp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::speedUp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::speedUp>::value != 
		function_uuid<(base_type)&Base::speedUp>::value;
};


template <class, class, class, class = void>
struct spiderTestJump {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spiderTestJump<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spiderTestJump)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spiderTestJump))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spiderTestJump));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spiderTestJump));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spiderTestJump>::value != 
		function_uuid<(base_type)&Base::spiderTestJump>::value;
};


template <class, class, class, class = void>
struct startDashing {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startDashing<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startDashing)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startDashing))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startDashing));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startDashing));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startDashing>::value != 
		function_uuid<(base_type)&Base::startDashing>::value;
};


template <class, class, class, class = void>
struct stopBurstEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopBurstEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopBurstEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBurstEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopBurstEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBurstEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopBurstEffect>::value != 
		function_uuid<(base_type)&Base::stopBurstEffect>::value;
};


template <class, class, class, class = void>
struct stopDashing {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopDashing<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopDashing)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopDashing))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopDashing));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopDashing));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopDashing>::value != 
		function_uuid<(base_type)&Base::stopDashing>::value;
};


template <class, class, class, class = void>
struct stopRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopRotation>::value != 
		function_uuid<(base_type)&Base::stopRotation>::value;
};


template <class, class, class, class = void>
struct storeCollision {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storeCollision<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeCollision)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCollision))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeCollision));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCollision));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storeCollision>::value != 
		function_uuid<(base_type)&Base::storeCollision>::value;
};


template <class, class, class, class = void>
struct switchedToMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct switchedToMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchedToMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchedToMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchedToMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchedToMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::switchedToMode>::value != 
		function_uuid<(base_type)&Base::switchedToMode>::value;
};


template <class, class, class, class = void>
struct testForMoving {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct testForMoving<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::testForMoving)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testForMoving))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::testForMoving));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testForMoving));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::testForMoving>::value != 
		function_uuid<(base_type)&Base::testForMoving>::value;
};


template <class, class, class, class = void>
struct toggleBirdMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleBirdMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleBirdMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBirdMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleBirdMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBirdMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleBirdMode>::value != 
		function_uuid<(base_type)&Base::toggleBirdMode>::value;
};


template <class, class, class, class = void>
struct toggleDartMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleDartMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleDartMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDartMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleDartMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDartMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleDartMode>::value != 
		function_uuid<(base_type)&Base::toggleDartMode>::value;
};


template <class, class, class, class = void>
struct toggleFlyMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlyMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFlyMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlyMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFlyMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlyMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleFlyMode>::value != 
		function_uuid<(base_type)&Base::toggleFlyMode>::value;
};


template <class, class, class, class = void>
struct toggleGhostEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGhostEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGhostEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGhostEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGhostEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGhostEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGhostEffect>::value != 
		function_uuid<(base_type)&Base::toggleGhostEffect>::value;
};


template <class, class, class, class = void>
struct togglePlayerScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePlayerScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePlayerScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::togglePlayerScale>::value != 
		function_uuid<(base_type)&Base::togglePlayerScale>::value;
};


template <class, class, class, class = void>
struct toggleRobotMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleRobotMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleRobotMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRobotMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleRobotMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRobotMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleRobotMode>::value != 
		function_uuid<(base_type)&Base::toggleRobotMode>::value;
};


template <class, class, class, class = void>
struct toggleRollMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleRollMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleRollMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRollMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleRollMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleRollMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleRollMode>::value != 
		function_uuid<(base_type)&Base::toggleRollMode>::value;
};


template <class, class, class, class = void>
struct toggleSpiderMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleSpiderMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSpiderMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSpiderMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSpiderMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSpiderMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleSpiderMode>::value != 
		function_uuid<(base_type)&Base::toggleSpiderMode>::value;
};


template <class, class, class, class = void>
struct toggleVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleVisibility>::value != 
		function_uuid<(base_type)&Base::toggleVisibility>::value;
};


template <class, class, class, class = void>
struct touchedObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct touchedObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::touchedObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touchedObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::touchedObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touchedObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::touchedObject>::value != 
		function_uuid<(base_type)&Base::touchedObject>::value;
};


template <class, class, class, class = void>
struct tryPlaceCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct tryPlaceCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tryPlaceCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryPlaceCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tryPlaceCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryPlaceCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::tryPlaceCheckpoint>::value != 
		function_uuid<(base_type)&Base::tryPlaceCheckpoint>::value;
};


template <class, class, class, class = void>
struct updateCheckpointMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCheckpointMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCheckpointMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCheckpointMode>::value != 
		function_uuid<(base_type)&Base::updateCheckpointMode>::value;
};


template <class, class, class, class = void>
struct updateCheckpointTest {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCheckpointTest<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCheckpointTest)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointTest))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCheckpointTest));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCheckpointTest));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCheckpointTest>::value != 
		function_uuid<(base_type)&Base::updateCheckpointTest>::value;
};


template <class, class, class, class = void>
struct updateCollide {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCollide<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollide)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollide))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollide));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollide));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCollide>::value != 
		function_uuid<(base_type)&Base::updateCollide>::value;
};


template <class, class, class, class = void>
struct updateCollideBottom {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideBottom<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollideBottom)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideBottom))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollideBottom));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideBottom));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCollideBottom>::value != 
		function_uuid<(base_type)&Base::updateCollideBottom>::value;
};


template <class, class, class, class = void>
struct updateCollideTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCollideTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollideTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollideTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollideTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCollideTop>::value != 
		function_uuid<(base_type)&Base::updateCollideTop>::value;
};


template <class, class, class, class = void>
struct updateDashAnimation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDashAnimation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDashAnimation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashAnimation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDashAnimation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashAnimation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDashAnimation>::value != 
		function_uuid<(base_type)&Base::updateDashAnimation>::value;
};


template <class, class, class, class = void>
struct updateDashArt {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDashArt<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDashArt)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashArt))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDashArt));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDashArt));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDashArt>::value != 
		function_uuid<(base_type)&Base::updateDashArt>::value;
};


template <class, class, class, class = void>
struct updateGlowColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGlowColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGlowColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGlowColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGlowColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGlowColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGlowColor>::value != 
		function_uuid<(base_type)&Base::updateGlowColor>::value;
};


template <class, class, class, class = void>
struct updateJump {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateJump<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateJump)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJump))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateJump));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJump));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateJump>::value != 
		function_uuid<(base_type)&Base::updateJump>::value;
};


template <class, class, class, class = void>
struct updateJumpVariables {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateJumpVariables<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateJumpVariables)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJumpVariables))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateJumpVariables));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateJumpVariables));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateJumpVariables>::value != 
		function_uuid<(base_type)&Base::updateJumpVariables>::value;
};


template <class, class, class, class = void>
struct updatePlayerBirdFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerBirdFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerBirdFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerBirdFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerBirdFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerBirdFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerBirdFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerBirdFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerDartFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerDartFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerDartFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerDartFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerDartFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerDartFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerDartFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerDartFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerGlow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerGlow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerGlow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerGlow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerGlow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerGlow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerGlow>::value != 
		function_uuid<(base_type)&Base::updatePlayerGlow>::value;
};


template <class, class, class, class = void>
struct updatePlayerRobotFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRobotFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerRobotFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRobotFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerRobotFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRobotFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerRobotFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerRobotFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerRollFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerRollFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerRollFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRollFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerRollFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerRollFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerRollFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerRollFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerScale>::value != 
		function_uuid<(base_type)&Base::updatePlayerScale>::value;
};


template <class, class, class, class = void>
struct updatePlayerShipFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerShipFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerShipFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerShipFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerShipFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerShipFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerShipFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerShipFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerSpiderFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpiderFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerSpiderFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpiderFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerSpiderFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpiderFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerSpiderFrame>::value != 
		function_uuid<(base_type)&Base::updatePlayerSpiderFrame>::value;
};


template <class, class, class, class = void>
struct updatePlayerSpriteExtra {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePlayerSpriteExtra<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerSpriteExtra)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpriteExtra))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePlayerSpriteExtra));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePlayerSpriteExtra));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePlayerSpriteExtra>::value != 
		function_uuid<(base_type)&Base::updatePlayerSpriteExtra>::value;
};


template <class, class, class, class = void>
struct updateRobotAnimationSpeed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateRobotAnimationSpeed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateRobotAnimationSpeed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRobotAnimationSpeed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateRobotAnimationSpeed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRobotAnimationSpeed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateRobotAnimationSpeed>::value != 
		function_uuid<(base_type)&Base::updateRobotAnimationSpeed>::value;
};


template <class, class, class, class = void>
struct updateRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateRotation>::value != 
		function_uuid<(base_type)&Base::updateRotation>::value;
};


template <class, class, class, class = void>
struct updateShipRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateShipRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateShipRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateShipRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateShipRotation>::value != 
		function_uuid<(base_type)&Base::updateShipRotation>::value;
};


template <class, class, class, class = void>
struct updateShipSpriteExtra {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateShipSpriteExtra<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateShipSpriteExtra)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipSpriteExtra))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateShipSpriteExtra));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateShipSpriteExtra));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateShipSpriteExtra>::value != 
		function_uuid<(base_type)&Base::updateShipSpriteExtra>::value;
};


template <class, class, class, class = void>
struct updateSlopeRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlopeRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlopeRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSlopeRotation>::value != 
		function_uuid<(base_type)&Base::updateSlopeRotation>::value;
};


template <class, class, class, class = void>
struct updateSlopeYVelocity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSlopeYVelocity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlopeYVelocity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeYVelocity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlopeYVelocity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlopeYVelocity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSlopeYVelocity>::value != 
		function_uuid<(base_type)&Base::updateSlopeYVelocity>::value;
};


template <class, class, class, class = void>
struct updateSpecial {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecial<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpecial)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecial))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpecial));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecial));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSpecial>::value != 
		function_uuid<(base_type)&Base::updateSpecial>::value;
};


template <class, class, class, class = void>
struct updateStateVariables {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateStateVariables<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStateVariables)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStateVariables))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStateVariables));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStateVariables));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateStateVariables>::value != 
		function_uuid<(base_type)&Base::updateStateVariables>::value;
};


template <class, class, class, class = void>
struct updateTimeMod {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateTimeMod<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTimeMod)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTimeMod))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTimeMod));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTimeMod));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateTimeMod>::value != 
		function_uuid<(base_type)&Base::updateTimeMod>::value;
};


template <class, class, class, class = void>
struct usingWallLimitedMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct usingWallLimitedMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::usingWallLimitedMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::usingWallLimitedMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::usingWallLimitedMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::usingWallLimitedMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::usingWallLimitedMode>::value != 
		function_uuid<(base_type)&Base::usingWallLimitedMode>::value;
};


template <class, class, class, class = void>
struct yStartDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct yStartDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::yStartDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::yStartDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::yStartDown>::value != 
		function_uuid<(base_type)&Base::yStartDown>::value;
};


template <class, class, class, class = void>
struct yStartUp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct yStartUp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::yStartUp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartUp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::yStartUp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::yStartUp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::yStartUp>::value != 
		function_uuid<(base_type)&Base::yStartUp>::value;
};


template <class, class, class, class = void>
struct onGLFWMouseCallBack {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGLFWMouseCallBack<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGLFWMouseCallBack)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGLFWMouseCallBack))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGLFWMouseCallBack));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGLFWMouseCallBack));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGLFWMouseCallBack>::value != 
		function_uuid<(base_type)&Base::onGLFWMouseCallBack>::value;
};


template <class, class, class, class = void>
struct swapBuffers {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct swapBuffers<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::swapBuffers)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::swapBuffers))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::swapBuffers));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::swapBuffers));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::swapBuffers>::value != 
		function_uuid<(base_type)&Base::swapBuffers>::value;
};


template <class, class, class, class = void>
struct updateWindow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateWindow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateWindow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWindow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateWindow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWindow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateWindow>::value != 
		function_uuid<(base_type)&Base::updateWindow>::value;
};


template <class, class, class, class = void>
struct toggleFullScreen {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleFullScreen<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFullScreen)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFullScreen))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFullScreen));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFullScreen));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleFullScreen>::value != 
		function_uuid<(base_type)&Base::toggleFullScreen>::value;
};


template <class, class, class, class = void>
struct pollEvents {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pollEvents<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pollEvents)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pollEvents))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pollEvents));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pollEvents));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pollEvents>::value != 
		function_uuid<(base_type)&Base::pollEvents>::value;
};


template <class, class, class, class = void>
struct sharedFileUtils {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedFileUtils<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedFileUtils)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedFileUtils))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedFileUtils));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedFileUtils));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedFileUtils>::value != 
		function_uuid<(base_type)&Base::sharedFileUtils>::value;
};


template <class, class, class, class = void>
struct disableUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct disableUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::disableUI>::value != 
		function_uuid<(base_type)&Base::disableUI>::value;
};


template <class, class, class, class = void>
struct draw {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct draw<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::draw)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::draw))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::draw));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::draw));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::draw>::value != 
		function_uuid<(base_type)&Base::draw>::value;
};


template <class, class, class, class = void>
struct enableUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enableUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enableUI>::value != 
		function_uuid<(base_type)&Base::enableUI>::value;
};


template <class, class, class, class = void>
struct enterAnimFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enterAnimFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterAnimFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterAnimFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterAnimFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterAnimFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enterAnimFinished>::value != 
		function_uuid<(base_type)&Base::enterAnimFinished>::value;
};


template <class, class, class, class = void>
struct enterLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enterLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enterLayer>::value != 
		function_uuid<(base_type)&Base::enterLayer>::value;
};


template <class, class, class, class = void>
struct exitLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitLayer>::value != 
		function_uuid<(base_type)&Base::exitLayer>::value;
};


template <class, class, class, class = void>
struct hideLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hideLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hideLayer>::value != 
		function_uuid<(base_type)&Base::hideLayer>::value;
};


template <class, class, class, class = void>
struct layerHidden {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct layerHidden<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::layerHidden)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerHidden))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::layerHidden));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerHidden));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::layerHidden>::value != 
		function_uuid<(base_type)&Base::layerHidden>::value;
};


template <class, class, class, class = void>
struct layerVisible {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct layerVisible<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::layerVisible)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerVisible))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::layerVisible));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::layerVisible));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::layerVisible>::value != 
		function_uuid<(base_type)&Base::layerVisible>::value;
};


template <class, class, class, class = void>
struct registerWithTouchDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerWithTouchDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerWithTouchDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerWithTouchDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerWithTouchDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerWithTouchDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerWithTouchDispatcher>::value != 
		function_uuid<(base_type)&Base::registerWithTouchDispatcher>::value;
};


template <class, class, class, class = void>
struct showLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showLayer>::value != 
		function_uuid<(base_type)&Base::showLayer>::value;
};


template <class, class, class, class = void>
struct onTargetIDArrow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onTargetIDArrow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTargetIDArrow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTargetIDArrow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTargetIDArrow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTargetIDArrow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onTargetIDArrow>::value != 
		function_uuid<(base_type)&Base::onTargetIDArrow>::value;
};


template <class, class, class, class = void>
struct textChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textChanged>::value != 
		function_uuid<(base_type)&Base::textChanged>::value;
};


template <class, class, class, class = void>
struct updateTargetID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateTargetID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTargetID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTargetID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTargetID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTargetID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateTargetID>::value != 
		function_uuid<(base_type)&Base::updateTargetID>::value;
};


template <class, class, class, class = void>
struct getOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOpacity>::value != 
		function_uuid<(base_type)&Base::getOpacity>::value;
};


template <class, class, class, class = void>
struct getDisplayedOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisplayedOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisplayedOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDisplayedOpacity>::value != 
		function_uuid<(base_type)&Base::getDisplayedOpacity>::value;
};


template <class, class, class, class = void>
struct updateDisplayedOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisplayedOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisplayedOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDisplayedOpacity>::value != 
		function_uuid<(base_type)&Base::updateDisplayedOpacity>::value;
};


template <class, class, class, class = void>
struct isCascadeOpacityEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeOpacityEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isCascadeOpacityEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeOpacityEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isCascadeOpacityEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeOpacityEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isCascadeOpacityEnabled>::value != 
		function_uuid<(base_type)&Base::isCascadeOpacityEnabled>::value;
};


template <class, class, class, class = void>
struct setCascadeOpacityEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeOpacityEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCascadeOpacityEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeOpacityEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCascadeOpacityEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeOpacityEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setCascadeOpacityEnabled>::value != 
		function_uuid<(base_type)&Base::setCascadeOpacityEnabled>::value;
};


template <class, class, class, class = void>
struct getColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getColor>::value != 
		function_uuid<(base_type)&Base::getColor>::value;
};


template <class, class, class, class = void>
struct getDisplayedColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDisplayedColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisplayedColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisplayedColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisplayedColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDisplayedColor>::value != 
		function_uuid<(base_type)&Base::getDisplayedColor>::value;
};


template <class, class, class, class = void>
struct updateDisplayedColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDisplayedColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisplayedColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisplayedColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisplayedColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDisplayedColor>::value != 
		function_uuid<(base_type)&Base::updateDisplayedColor>::value;
};


template <class, class, class, class = void>
struct isCascadeColorEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isCascadeColorEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isCascadeColorEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeColorEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isCascadeColorEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isCascadeColorEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isCascadeColorEnabled>::value != 
		function_uuid<(base_type)&Base::isCascadeColorEnabled>::value;
};


template <class, class, class, class = void>
struct setCascadeColorEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setCascadeColorEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCascadeColorEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeColorEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCascadeColorEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCascadeColorEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setCascadeColorEnabled>::value != 
		function_uuid<(base_type)&Base::setCascadeColorEnabled>::value;
};


template <class, class, class, class = void>
struct onMyLevels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onMyLevels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMyLevels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyLevels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMyLevels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyLevels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onMyLevels>::value != 
		function_uuid<(base_type)&Base::onMyLevels>::value;
};


template <class, class, class, class = void>
struct onSavedLevels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSavedLevels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSavedLevels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSavedLevels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSavedLevels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSavedLevels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSavedLevels>::value != 
		function_uuid<(base_type)&Base::onSavedLevels>::value;
};


template <class, class, class, class = void>
struct onClose {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onClose<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onClose)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClose))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onClose));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClose));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onClose>::value != 
		function_uuid<(base_type)&Base::onClose>::value;
};


template <class, class, class, class = void>
struct getCurrentLanguage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentLanguage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCurrentLanguage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentLanguage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCurrentLanguage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentLanguage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCurrentLanguage>::value != 
		function_uuid<(base_type)&Base::getCurrentLanguage>::value;
};


template <class, class, class, class = void>
struct getTargetPlatform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTargetPlatform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTargetPlatform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetPlatform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTargetPlatform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetPlatform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTargetPlatform>::value != 
		function_uuid<(base_type)&Base::getTargetPlatform>::value;
};


template <class, class, class, class = void>
struct openURL {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct openURL<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::openURL)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::openURL))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::openURL));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::openURL));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::openURL>::value != 
		function_uuid<(base_type)&Base::openURL>::value;
};


template <class, class, class, class = void>
struct setAnimationInterval {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAnimationInterval<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAnimationInterval)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnimationInterval))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAnimationInterval));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnimationInterval));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAnimationInterval>::value != 
		function_uuid<(base_type)&Base::setAnimationInterval>::value;
};


template <class, class, class, class = void>
struct createWithSpriteFrames {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrames<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrames)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrames))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrames));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrames));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithSpriteFrames>::value != 
		function_uuid<(base_type)&Base::createWithSpriteFrames>::value;
};


template <class, class, class, class = void>
struct onButtonsPerRow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onButtonsPerRow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onButtonsPerRow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onButtonsPerRow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onButtonsPerRow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onButtonsPerRow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onButtonsPerRow>::value != 
		function_uuid<(base_type)&Base::onButtonsPerRow>::value;
};


template <class, class, class, class = void>
struct addObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addObject>::value != 
		function_uuid<(base_type)&Base::addObject>::value;
};


template <class, class, class, class = void>
struct addObjectNew {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addObjectNew<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectNew)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectNew))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectNew));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectNew));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addObjectNew>::value != 
		function_uuid<(base_type)&Base::addObjectNew>::value;
};


template <class, class, class, class = void>
struct addObjectsFromArray {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addObjectsFromArray<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectsFromArray)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectsFromArray))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectsFromArray));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectsFromArray));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addObjectsFromArray>::value != 
		function_uuid<(base_type)&Base::addObjectsFromArray>::value;
};


template <class, class, class, class = void>
struct containsObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct containsObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::containsObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::containsObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::containsObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::containsObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::containsObject>::value != 
		function_uuid<(base_type)&Base::containsObject>::value;
};


template <class, class, class, class = void>
struct count {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct count<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::count)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::count))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::count));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::count));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::count>::value != 
		function_uuid<(base_type)&Base::count>::value;
};


template <class, class, class, class = void>
struct createWithObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithObject>::value != 
		function_uuid<(base_type)&Base::createWithObject>::value;
};


template <class, class, class, class = void>
struct fastRemoveObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fastRemoveObject>::value != 
		function_uuid<(base_type)&Base::fastRemoveObject>::value;
};


template <class, class, class, class = void>
struct fastRemoveObjectAtIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObjectAtIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObjectAtIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fastRemoveObjectAtIndex>::value != 
		function_uuid<(base_type)&Base::fastRemoveObjectAtIndex>::value;
};


template <class, class, class, class = void>
struct fastRemoveObjectAtIndexNew {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fastRemoveObjectAtIndexNew<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObjectAtIndexNew)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndexNew))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fastRemoveObjectAtIndexNew));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fastRemoveObjectAtIndexNew));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fastRemoveObjectAtIndexNew>::value != 
		function_uuid<(base_type)&Base::fastRemoveObjectAtIndexNew>::value;
};


template <class, class, class, class = void>
struct lastObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct lastObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lastObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lastObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lastObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lastObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::lastObject>::value != 
		function_uuid<(base_type)&Base::lastObject>::value;
};


template <class, class, class, class = void>
struct objectAtIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectAtIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectAtIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectAtIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectAtIndex>::value != 
		function_uuid<(base_type)&Base::objectAtIndex>::value;
};


template <class, class, class, class = void>
struct removeAllObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllObjects>::value != 
		function_uuid<(base_type)&Base::removeAllObjects>::value;
};


template <class, class, class, class = void>
struct removeLastObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeLastObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeLastObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeLastObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeLastObject>::value != 
		function_uuid<(base_type)&Base::removeLastObject>::value;
};


template <class, class, class, class = void>
struct removeObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeObject>::value != 
		function_uuid<(base_type)&Base::removeObject>::value;
};


template <class, class, class, class = void>
struct removeObjectAtIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectAtIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectAtIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectAtIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectAtIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectAtIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeObjectAtIndex>::value != 
		function_uuid<(base_type)&Base::removeObjectAtIndex>::value;
};


template <class, class, class, class = void>
struct stringAtIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stringAtIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stringAtIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stringAtIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stringAtIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stringAtIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stringAtIndex>::value != 
		function_uuid<(base_type)&Base::stringAtIndex>::value;
};


template <class, class, class, class = void>
struct limitLabelWidth {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct limitLabelWidth<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::limitLabelWidth)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::limitLabelWidth))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::limitLabelWidth));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::limitLabelWidth));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::limitLabelWidth>::value != 
		function_uuid<(base_type)&Base::limitLabelWidth>::value;
};


template <class, class, class, class = void>
struct setString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setString>::value != 
		function_uuid<(base_type)&Base::setString>::value;
};


template <class, class, class, class = void>
struct setAnchorPoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAnchorPoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAnchorPoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnchorPoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAnchorPoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAnchorPoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAnchorPoint>::value != 
		function_uuid<(base_type)&Base::setAnchorPoint>::value;
};


template <class, class, class, class = void>
struct setObjectColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setObjectColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObjectColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObjectColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setObjectColor>::value != 
		function_uuid<(base_type)&Base::setObjectColor>::value;
};


template <class, class, class, class = void>
struct onArtists {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onArtists<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onArtists)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onArtists))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onArtists));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onArtists));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onArtists>::value != 
		function_uuid<(base_type)&Base::onArtists>::value;
};


template <class, class, class, class = void>
struct onSongBrowser {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSongBrowser<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSongBrowser)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSongBrowser))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSongBrowser));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSongBrowser));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSongBrowser>::value != 
		function_uuid<(base_type)&Base::onSongBrowser>::value;
};


template <class, class, class, class = void>
struct createWithTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithTexture>::value != 
		function_uuid<(base_type)&Base::createWithTexture>::value;
};


template <class, class, class, class = void>
struct sendActionsForControlEvents {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sendActionsForControlEvents<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sendActionsForControlEvents)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sendActionsForControlEvents))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sendActionsForControlEvents));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sendActionsForControlEvents));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sendActionsForControlEvents>::value != 
		function_uuid<(base_type)&Base::sendActionsForControlEvents>::value;
};


template <class, class, class, class = void>
struct setOpacityModifyRGB {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setOpacityModifyRGB<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOpacityModifyRGB)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacityModifyRGB))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOpacityModifyRGB));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOpacityModifyRGB));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setOpacityModifyRGB>::value != 
		function_uuid<(base_type)&Base::setOpacityModifyRGB>::value;
};


template <class, class, class, class = void>
struct onExit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onExit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onExit>::value != 
		function_uuid<(base_type)&Base::onExit>::value;
};


template <class, class, class, class = void>
struct isTouchInside {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isTouchInside<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isTouchInside)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchInside))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isTouchInside));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchInside));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isTouchInside>::value != 
		function_uuid<(base_type)&Base::isTouchInside>::value;
};


template <class, class, class, class = void>
struct setEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setEnabled>::value != 
		function_uuid<(base_type)&Base::setEnabled>::value;
};


template <class, class, class, class = void>
struct onEnter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onEnter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEnter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEnter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onEnter>::value != 
		function_uuid<(base_type)&Base::onEnter>::value;
};


template <class, class, class, class = void>
struct isEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isEnabled>::value != 
		function_uuid<(base_type)&Base::isEnabled>::value;
};


template <class, class, class, class = void>
struct setSelected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSelected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSelected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSelected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSelected>::value != 
		function_uuid<(base_type)&Base::setSelected>::value;
};


template <class, class, class, class = void>
struct isOpacityModifyRGB {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isOpacityModifyRGB<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isOpacityModifyRGB)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOpacityModifyRGB))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isOpacityModifyRGB));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOpacityModifyRGB));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isOpacityModifyRGB>::value != 
		function_uuid<(base_type)&Base::isOpacityModifyRGB>::value;
};


template <class, class, class, class = void>
struct setHighlighted {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setHighlighted<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setHighlighted)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setHighlighted))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setHighlighted));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setHighlighted));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setHighlighted>::value != 
		function_uuid<(base_type)&Base::setHighlighted>::value;
};


template <class, class, class, class = void>
struct needsLayout {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct needsLayout<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::needsLayout)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::needsLayout))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::needsLayout));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::needsLayout));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::needsLayout>::value != 
		function_uuid<(base_type)&Base::needsLayout>::value;
};


template <class, class, class, class = void>
struct getTouchLocation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTouchLocation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchLocation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchLocation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchLocation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchLocation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTouchLocation>::value != 
		function_uuid<(base_type)&Base::getTouchLocation>::value;
};


template <class, class, class, class = void>
struct isHighlighted {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isHighlighted<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isHighlighted)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isHighlighted))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isHighlighted));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isHighlighted));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isHighlighted>::value != 
		function_uuid<(base_type)&Base::isHighlighted>::value;
};


template <class, class, class, class = void>
struct addTargetWithActionForControlEvents {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addTargetWithActionForControlEvents<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addTargetWithActionForControlEvents)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addTargetWithActionForControlEvents))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addTargetWithActionForControlEvents));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addTargetWithActionForControlEvents));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addTargetWithActionForControlEvents>::value != 
		function_uuid<(base_type)&Base::addTargetWithActionForControlEvents>::value;
};


template <class, class, class, class = void>
struct removeTargetWithActionForControlEvents {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeTargetWithActionForControlEvents<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeTargetWithActionForControlEvents)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeTargetWithActionForControlEvents))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeTargetWithActionForControlEvents));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeTargetWithActionForControlEvents));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeTargetWithActionForControlEvents>::value != 
		function_uuid<(base_type)&Base::removeTargetWithActionForControlEvents>::value;
};


template <class, class, class, class = void>
struct isSelected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSelected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSelected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSelected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSelected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSelected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSelected>::value != 
		function_uuid<(base_type)&Base::isSelected>::value;
};


template <class, class, class, class = void>
struct clear {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct clear<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clear)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clear))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clear));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clear));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::clear>::value != 
		function_uuid<(base_type)&Base::clear>::value;
};


template <class, class, class, class = void>
struct drawPolygon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct drawPolygon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawPolygon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawPolygon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawPolygon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawPolygon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::drawPolygon>::value != 
		function_uuid<(base_type)&Base::drawPolygon>::value;
};


template <class, class, class, class = void>
struct drawSegment {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct drawSegment<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawSegment)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawSegment))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawSegment));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawSegment));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::drawSegment>::value != 
		function_uuid<(base_type)&Base::drawSegment>::value;
};


template <class, class, class, class = void>
struct getBlendFunc {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBlendFunc<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBlendFunc)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBlendFunc))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBlendFunc));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBlendFunc));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBlendFunc>::value != 
		function_uuid<(base_type)&Base::getBlendFunc>::value;
};


template <class, class, class, class = void>
struct setBlendFunc {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setBlendFunc<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBlendFunc)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBlendFunc))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBlendFunc));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBlendFunc));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setBlendFunc>::value != 
		function_uuid<(base_type)&Base::setBlendFunc>::value;
};


template <class, class, class, class = void>
struct getAlphaThreshold {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAlphaThreshold<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAlphaThreshold)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAlphaThreshold))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAlphaThreshold));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAlphaThreshold));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAlphaThreshold>::value != 
		function_uuid<(base_type)&Base::getAlphaThreshold>::value;
};


template <class, class, class, class = void>
struct getStencil {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStencil<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStencil)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStencil))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStencil));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStencil));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStencil>::value != 
		function_uuid<(base_type)&Base::getStencil>::value;
};


template <class, class, class, class = void>
struct isInverted {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isInverted<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isInverted)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isInverted))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isInverted));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isInverted));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isInverted>::value != 
		function_uuid<(base_type)&Base::isInverted>::value;
};


template <class, class, class, class = void>
struct onEnterTransitionDidFinish {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onEnterTransitionDidFinish<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEnterTransitionDidFinish)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnterTransitionDidFinish))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEnterTransitionDidFinish));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEnterTransitionDidFinish));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onEnterTransitionDidFinish>::value != 
		function_uuid<(base_type)&Base::onEnterTransitionDidFinish>::value;
};


template <class, class, class, class = void>
struct onExitTransitionDidStart {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onExitTransitionDidStart<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitTransitionDidStart)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitTransitionDidStart))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitTransitionDidStart));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitTransitionDidStart));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onExitTransitionDidStart>::value != 
		function_uuid<(base_type)&Base::onExitTransitionDidStart>::value;
};


template <class, class, class, class = void>
struct setAlphaThreshold {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAlphaThreshold<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAlphaThreshold)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAlphaThreshold))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAlphaThreshold));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAlphaThreshold));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAlphaThreshold>::value != 
		function_uuid<(base_type)&Base::setAlphaThreshold>::value;
};


template <class, class, class, class = void>
struct setInverted {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setInverted<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInverted)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInverted))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInverted));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInverted));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setInverted>::value != 
		function_uuid<(base_type)&Base::setInverted>::value;
};


template <class, class, class, class = void>
struct setStencil {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setStencil<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStencil)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStencil))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStencil));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStencil));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setStencil>::value != 
		function_uuid<(base_type)&Base::setStencil>::value;
};


template <class, class, class, class = void>
struct visit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct visit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::visit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::visit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::visit>::value != 
		function_uuid<(base_type)&Base::visit>::value;
};


template <class, class, class, class = void>
struct attachWithIME {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct attachWithIME<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::attachWithIME)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::attachWithIME))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::attachWithIME));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::attachWithIME));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::attachWithIME>::value != 
		function_uuid<(base_type)&Base::attachWithIME>::value;
};


template <class, class, class, class = void>
struct detachWithIME {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct detachWithIME<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::detachWithIME)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::detachWithIME))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::detachWithIME));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::detachWithIME));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::detachWithIME>::value != 
		function_uuid<(base_type)&Base::detachWithIME>::value;
};


template <class, class, class, class = void>
struct allKeys {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct allKeys<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::allKeys)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allKeys))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::allKeys));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allKeys));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::allKeys>::value != 
		function_uuid<(base_type)&Base::allKeys>::value;
};


template <class, class, class, class = void>
struct objectForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectForKey>::value != 
		function_uuid<(base_type)&Base::objectForKey>::value;
};


template <class, class, class, class = void>
struct removeObjectForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeObjectForKey>::value != 
		function_uuid<(base_type)&Base::removeObjectForKey>::value;
};


template <class, class, class, class = void>
struct setObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setObject>::value != 
		function_uuid<(base_type)&Base::setObject>::value;
};


template <class, class, class, class = void>
struct valueForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct valueForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::valueForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::valueForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::valueForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::valueForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::valueForKey>::value != 
		function_uuid<(base_type)&Base::valueForKey>::value;
};


template <class, class, class, class = void>
struct handlerWithDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct handlerWithDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handlerWithDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handlerWithDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handlerWithDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handlerWithDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::handlerWithDelegate>::value != 
		function_uuid<(base_type)&Base::handlerWithDelegate>::value;
};


template <class, class, class, class = void>
struct initWithDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithDelegate>::value != 
		function_uuid<(base_type)&Base::initWithDelegate>::value;
};


template <class, class, class, class = void>
struct updateTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateTexture>::value != 
		function_uuid<(base_type)&Base::updateTexture>::value;
};


template <class, class, class, class = void>
struct addSpriteFramesWithFile {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addSpriteFramesWithFile<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addSpriteFramesWithFile)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpriteFramesWithFile))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addSpriteFramesWithFile));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpriteFramesWithFile));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addSpriteFramesWithFile>::value != 
		function_uuid<(base_type)&Base::addSpriteFramesWithFile>::value;
};


template <class, class, class, class = void>
struct sharedSpriteFrameCache {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedSpriteFrameCache<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedSpriteFrameCache)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedSpriteFrameCache))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedSpriteFrameCache));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedSpriteFrameCache));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedSpriteFrameCache>::value != 
		function_uuid<(base_type)&Base::sharedSpriteFrameCache>::value;
};


template <class, class, class, class = void>
struct spriteFrameByName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spriteFrameByName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spriteFrameByName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spriteFrameByName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spriteFrameByName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spriteFrameByName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spriteFrameByName>::value != 
		function_uuid<(base_type)&Base::spriteFrameByName>::value;
};


template <class, class, class, class = void>
struct getScheduler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getScheduler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScheduler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScheduler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScheduler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScheduler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getScheduler>::value != 
		function_uuid<(base_type)&Base::getScheduler>::value;
};


template <class, class, class, class = void>
struct setScheduler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setScheduler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScheduler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScheduler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setScheduler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setScheduler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setScheduler>::value != 
		function_uuid<(base_type)&Base::setScheduler>::value;
};


template <class, class, class, class = void>
struct getActionManager {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getActionManager<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActionManager)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionManager))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActionManager));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionManager));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getActionManager>::value != 
		function_uuid<(base_type)&Base::getActionManager>::value;
};


template <class, class, class, class = void>
struct setActionManager {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setActionManager<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setActionManager)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setActionManager))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setActionManager));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setActionManager));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setActionManager>::value != 
		function_uuid<(base_type)&Base::setActionManager>::value;
};


template <class, class, class, class = void>
struct getTouchDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTouchDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTouchDispatcher>::value != 
		function_uuid<(base_type)&Base::getTouchDispatcher>::value;
};


template <class, class, class, class = void>
struct setTouchDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTouchDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTouchDispatcher>::value != 
		function_uuid<(base_type)&Base::setTouchDispatcher>::value;
};


template <class, class, class, class = void>
struct getKeypadDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getKeypadDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getKeypadDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeypadDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getKeypadDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeypadDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getKeypadDispatcher>::value != 
		function_uuid<(base_type)&Base::getKeypadDispatcher>::value;
};


template <class, class, class, class = void>
struct setKeypadDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeypadDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeypadDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setKeypadDispatcher>::value != 
		function_uuid<(base_type)&Base::setKeypadDispatcher>::value;
};


template <class, class, class, class = void>
struct getKeyboardDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getKeyboardDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getKeyboardDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeyboardDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getKeyboardDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getKeyboardDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getKeyboardDispatcher>::value != 
		function_uuid<(base_type)&Base::getKeyboardDispatcher>::value;
};


template <class, class, class, class = void>
struct setKeyboardDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeyboardDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeyboardDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setKeyboardDispatcher>::value != 
		function_uuid<(base_type)&Base::setKeyboardDispatcher>::value;
};


template <class, class, class, class = void>
struct getMouseDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMouseDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMouseDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMouseDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMouseDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMouseDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMouseDispatcher>::value != 
		function_uuid<(base_type)&Base::getMouseDispatcher>::value;
};


template <class, class, class, class = void>
struct setMouseDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMouseDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMouseDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMouseDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMouseDispatcher>::value != 
		function_uuid<(base_type)&Base::setMouseDispatcher>::value;
};


template <class, class, class, class = void>
struct getAccelerometer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAccelerometer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAccelerometer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAccelerometer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAccelerometer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAccelerometer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAccelerometer>::value != 
		function_uuid<(base_type)&Base::getAccelerometer>::value;
};


template <class, class, class, class = void>
struct setAccelerometer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAccelerometer>::value != 
		function_uuid<(base_type)&Base::setAccelerometer>::value;
};


template <class, class, class, class = void>
struct getDeltaTime {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDeltaTime<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDeltaTime)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDeltaTime))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDeltaTime));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDeltaTime));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDeltaTime>::value != 
		function_uuid<(base_type)&Base::getDeltaTime>::value;
};


template <class, class, class, class = void>
struct getSceneDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSceneDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSceneDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSceneDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSceneDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSceneDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSceneDelegate>::value != 
		function_uuid<(base_type)&Base::getSceneDelegate>::value;
};


template <class, class, class, class = void>
struct setSceneDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSceneDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSceneDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSceneDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSceneDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSceneDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSceneDelegate>::value != 
		function_uuid<(base_type)&Base::setSceneDelegate>::value;
};


template <class, class, class, class = void>
struct getWinSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getWinSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getWinSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getWinSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getWinSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getWinSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getWinSize>::value != 
		function_uuid<(base_type)&Base::getWinSize>::value;
};


template <class, class, class, class = void>
struct pushScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pushScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pushScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pushScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pushScene>::value != 
		function_uuid<(base_type)&Base::pushScene>::value;
};


template <class, class, class, class = void>
struct replaceScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct replaceScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::replaceScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::replaceScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::replaceScene>::value != 
		function_uuid<(base_type)&Base::replaceScene>::value;
};


template <class, class, class, class = void>
struct resetSmoothFixCounter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetSmoothFixCounter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetSmoothFixCounter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSmoothFixCounter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetSmoothFixCounter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSmoothFixCounter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetSmoothFixCounter>::value != 
		function_uuid<(base_type)&Base::resetSmoothFixCounter>::value;
};


template <class, class, class, class = void>
struct sharedDirector {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedDirector<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedDirector)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDirector))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedDirector));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDirector));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedDirector>::value != 
		function_uuid<(base_type)&Base::sharedDirector>::value;
};


template <class, class, class, class = void>
struct calculateDeltaTime {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateDeltaTime<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateDeltaTime)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateDeltaTime))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateDeltaTime));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateDeltaTime));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateDeltaTime>::value != 
		function_uuid<(base_type)&Base::calculateDeltaTime>::value;
};


template <class, class, class, class = void>
struct calculateMPF {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateMPF<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateMPF)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateMPF))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateMPF));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateMPF));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateMPF>::value != 
		function_uuid<(base_type)&Base::calculateMPF>::value;
};


template <class, class, class, class = void>
struct convertToGL {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct convertToGL<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToGL)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToGL))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToGL));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToGL));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::convertToGL>::value != 
		function_uuid<(base_type)&Base::convertToGL>::value;
};


template <class, class, class, class = void>
struct drawScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct drawScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::drawScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::drawScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::drawScene>::value != 
		function_uuid<(base_type)&Base::drawScene>::value;
};


template <class, class, class, class = void>
struct setNextScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setNextScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setNextScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNextScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setNextScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNextScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setNextScene>::value != 
		function_uuid<(base_type)&Base::setNextScene>::value;
};


template <class, class, class, class = void>
struct showStats {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showStats<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showStats)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showStats))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showStats));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showStats));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showStats>::value != 
		function_uuid<(base_type)&Base::showStats>::value;
};


template <class, class, class, class = void>
struct updateContentScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateContentScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateContentScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateContentScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateContentScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateContentScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateContentScale>::value != 
		function_uuid<(base_type)&Base::updateContentScale>::value;
};


template <class, class, class, class = void>
struct popSceneWithTransition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct popSceneWithTransition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::popSceneWithTransition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::popSceneWithTransition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::popSceneWithTransition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::popSceneWithTransition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::popSceneWithTransition>::value != 
		function_uuid<(base_type)&Base::popSceneWithTransition>::value;
};


template <class, class, class, class = void>
struct setParentLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setParentLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setParentLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParentLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setParentLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParentLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setParentLayer>::value != 
		function_uuid<(base_type)&Base::setParentLayer>::value;
};


template <class, class, class, class = void>
struct setFade {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFade<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFade)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFade))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFade));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFade));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFade>::value != 
		function_uuid<(base_type)&Base::setFade>::value;
};


template <class, class, class, class = void>
struct show {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct show<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::show)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::show))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::show));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::show));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::show>::value != 
		function_uuid<(base_type)&Base::show>::value;
};


template <class, class, class, class = void>
struct fadeAndRemove {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fadeAndRemove<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeAndRemove)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeAndRemove))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeAndRemove));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeAndRemove));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fadeAndRemove>::value != 
		function_uuid<(base_type)&Base::fadeAndRemove>::value;
};


template <class, class, class, class = void>
struct initWithImageData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithImageData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithImageData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImageData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithImageData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImageData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithImageData>::value != 
		function_uuid<(base_type)&Base::initWithImageData>::value;
};


template <class, class, class, class = void>
struct activate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activate>::value != 
		function_uuid<(base_type)&Base::activate>::value;
};


template <class, class, class, class = void>
struct selected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selected>::value != 
		function_uuid<(base_type)&Base::selected>::value;
};


template <class, class, class, class = void>
struct unselected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unselected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unselected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unselected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unselected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unselected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unselected>::value != 
		function_uuid<(base_type)&Base::unselected>::value;
};


template <class, class, class, class = void>
struct getDisabledColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisabledColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisabledColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDisabledColor>::value != 
		function_uuid<(base_type)&Base::getDisabledColor>::value;
};


template <class, class, class, class = void>
struct setDisabledColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisabledColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisabledColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDisabledColor>::value != 
		function_uuid<(base_type)&Base::setDisabledColor>::value;
};


template <class, class, class, class = void>
struct getLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLabel>::value != 
		function_uuid<(base_type)&Base::getLabel>::value;
};


template <class, class, class, class = void>
struct setLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setLabel>::value != 
		function_uuid<(base_type)&Base::setLabel>::value;
};


template <class, class, class, class = void>
struct useAnimationType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct useAnimationType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::useAnimationType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::useAnimationType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::useAnimationType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::useAnimationType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::useAnimationType>::value != 
		function_uuid<(base_type)&Base::useAnimationType>::value;
};


template <class, class, class, class = void>
struct setDestination {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDestination<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDestination)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDestination))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDestination));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDestination));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDestination>::value != 
		function_uuid<(base_type)&Base::setDestination>::value;
};


template <class, class, class, class = void>
struct setOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setOffset>::value != 
		function_uuid<(base_type)&Base::setOffset>::value;
};


template <class, class, class, class = void>
struct setSizeMult {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSizeMult<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSizeMult)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSizeMult))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSizeMult));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSizeMult));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSizeMult>::value != 
		function_uuid<(base_type)&Base::setSizeMult>::value;
};


template <class, class, class, class = void>
struct updateBlending {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBlending<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlending)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlending))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlending));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlending));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBlending>::value != 
		function_uuid<(base_type)&Base::updateBlending>::value;
};


template <class, class, class, class = void>
struct updateCopyLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCopyLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCopyLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCopyLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCopyLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCopyLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCopyLabel>::value != 
		function_uuid<(base_type)&Base::updateCopyLabel>::value;
};


template <class, class, class, class = void>
struct updateOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOpacity>::value != 
		function_uuid<(base_type)&Base::updateOpacity>::value;
};


template <class, class, class, class = void>
struct updateValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateValues>::value != 
		function_uuid<(base_type)&Base::updateValues>::value;
};


template <class, class, class, class = void>
struct acceptVisitor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct acceptVisitor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::acceptVisitor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::acceptVisitor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::acceptVisitor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::acceptVisitor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::acceptVisitor>::value != 
		function_uuid<(base_type)&Base::acceptVisitor>::value;
};


template <class, class, class, class = void>
struct reloadData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadData>::value != 
		function_uuid<(base_type)&Base::reloadData>::value;
};


template <class, class, class, class = void>
struct customSetup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct customSetup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::customSetup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customSetup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::customSetup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customSetup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::customSetup>::value != 
		function_uuid<(base_type)&Base::customSetup>::value;
};


template <class, class, class, class = void>
struct loadPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadPage>::value != 
		function_uuid<(base_type)&Base::loadPage>::value;
};


template <class, class, class, class = void>
struct sharedDispatcher {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedDispatcher<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedDispatcher)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDispatcher))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedDispatcher));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedDispatcher));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedDispatcher>::value != 
		function_uuid<(base_type)&Base::sharedDispatcher>::value;
};


template <class, class, class, class = void>
struct addDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addDelegate>::value != 
		function_uuid<(base_type)&Base::addDelegate>::value;
};


template <class, class, class, class = void>
struct removeDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeDelegate>::value != 
		function_uuid<(base_type)&Base::removeDelegate>::value;
};


template <class, class, class, class = void>
struct setupCommentsBrowser {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupCommentsBrowser<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCommentsBrowser)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCommentsBrowser))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCommentsBrowser));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCommentsBrowser));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupCommentsBrowser>::value != 
		function_uuid<(base_type)&Base::setupCommentsBrowser>::value;
};


template <class, class, class, class = void>
struct onMore {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onMore<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMore)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMore))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMore));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMore));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onMore>::value != 
		function_uuid<(base_type)&Base::onMore>::value;
};


template <class, class, class, class = void>
struct onLevelInfo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onLevelInfo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onLevelInfo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLevelInfo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onLevelInfo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLevelInfo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onLevelInfo>::value != 
		function_uuid<(base_type)&Base::onLevelInfo>::value;
};


template <class, class, class, class = void>
struct initWithColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithColor>::value != 
		function_uuid<(base_type)&Base::initWithColor>::value;
};


template <class, class, class, class = void>
struct setContentSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setContentSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setContentSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setContentSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setContentSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setContentSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setContentSize>::value != 
		function_uuid<(base_type)&Base::setContentSize>::value;
};


template <class, class, class, class = void>
struct updateColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateColor>::value != 
		function_uuid<(base_type)&Base::updateColor>::value;
};


template <class, class, class, class = void>
struct loadFromComment {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFromComment<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromComment)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromComment))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromComment));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromComment));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFromComment>::value != 
		function_uuid<(base_type)&Base::loadFromComment>::value;
};


template <class, class, class, class = void>
struct loadFromObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFromObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFromObject>::value != 
		function_uuid<(base_type)&Base::loadFromObject>::value;
};


template <class, class, class, class = void>
struct onNewgrounds {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onNewgrounds<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNewgrounds)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNewgrounds))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNewgrounds));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNewgrounds));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onNewgrounds>::value != 
		function_uuid<(base_type)&Base::onNewgrounds>::value;
};


template <class, class, class, class = void>
struct updateBGColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBGColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBGColor>::value != 
		function_uuid<(base_type)&Base::updateBGColor>::value;
};


template <class, class, class, class = void>
struct getDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDelegate>::value != 
		function_uuid<(base_type)&Base::getDelegate>::value;
};


template <class, class, class, class = void>
struct createFromString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createFromString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createFromString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFromString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createFromString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFromString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createFromString>::value != 
		function_uuid<(base_type)&Base::createFromString>::value;
};


template <class, class, class, class = void>
struct dispatchKeyboardMSG {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct dispatchKeyboardMSG<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dispatchKeyboardMSG)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dispatchKeyboardMSG))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dispatchKeyboardMSG));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dispatchKeyboardMSG));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::dispatchKeyboardMSG>::value != 
		function_uuid<(base_type)&Base::dispatchKeyboardMSG>::value;
};


template <class, class, class, class = void>
struct keyToString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyToString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyToString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyToString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyToString>::value != 
		function_uuid<(base_type)&Base::keyToString>::value;
};


template <class, class, class, class = void>
struct listButtonBarSwitchedPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct listButtonBarSwitchedPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::listButtonBarSwitchedPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::listButtonBarSwitchedPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::listButtonBarSwitchedPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::listButtonBarSwitchedPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::listButtonBarSwitchedPage>::value != 
		function_uuid<(base_type)&Base::listButtonBarSwitchedPage>::value;
};


template <class, class, class, class = void>
struct createWithSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithSize>::value != 
		function_uuid<(base_type)&Base::createWithSize>::value;
};


template <class, class, class, class = void>
struct createWithStandardSprites {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithStandardSprites<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithStandardSprites)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithStandardSprites))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithStandardSprites));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithStandardSprites));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithStandardSprites>::value != 
		function_uuid<(base_type)&Base::createWithStandardSprites>::value;
};


template <class, class, class, class = void>
struct isOn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isOn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isOn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isOn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isOn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isOn>::value != 
		function_uuid<(base_type)&Base::isOn>::value;
};


template <class, class, class, class = void>
struct isToggled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isToggled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isToggled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isToggled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isToggled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isToggled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isToggled>::value != 
		function_uuid<(base_type)&Base::isToggled>::value;
};


template <class, class, class, class = void>
struct setClickable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setClickable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setClickable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setClickable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setClickable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setClickable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setClickable>::value != 
		function_uuid<(base_type)&Base::setClickable>::value;
};


template <class, class, class, class = void>
struct toggleWithCallback {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleWithCallback<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleWithCallback)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleWithCallback))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleWithCallback));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleWithCallback));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleWithCallback>::value != 
		function_uuid<(base_type)&Base::toggleWithCallback>::value;
};


template <class, class, class, class = void>
struct toggle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggle>::value != 
		function_uuid<(base_type)&Base::toggle>::value;
};


template <class, class, class, class = void>
struct ccTouchBegan {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchBegan<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchBegan)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchBegan))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchBegan));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchBegan));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchBegan>::value != 
		function_uuid<(base_type)&Base::ccTouchBegan>::value;
};


template <class, class, class, class = void>
struct ccTouchCancelled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchCancelled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchCancelled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchCancelled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchCancelled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchCancelled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchCancelled>::value != 
		function_uuid<(base_type)&Base::ccTouchCancelled>::value;
};


template <class, class, class, class = void>
struct ccTouchEnded {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchEnded<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchEnded)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchEnded))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchEnded));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchEnded));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchEnded>::value != 
		function_uuid<(base_type)&Base::ccTouchEnded>::value;
};


template <class, class, class, class = void>
struct ccTouchMoved {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchMoved<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchMoved)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchMoved))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchMoved));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchMoved));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchMoved>::value != 
		function_uuid<(base_type)&Base::ccTouchMoved>::value;
};


template <class, class, class, class = void>
struct ccTouchesBegan {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesBegan<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesBegan)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesBegan))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesBegan));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesBegan));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchesBegan>::value != 
		function_uuid<(base_type)&Base::ccTouchesBegan>::value;
};


template <class, class, class, class = void>
struct ccTouchesCancelled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesCancelled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesCancelled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesCancelled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesCancelled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesCancelled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchesCancelled>::value != 
		function_uuid<(base_type)&Base::ccTouchesCancelled>::value;
};


template <class, class, class, class = void>
struct ccTouchesEnded {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesEnded<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesEnded)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesEnded))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesEnded));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesEnded));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchesEnded>::value != 
		function_uuid<(base_type)&Base::ccTouchesEnded>::value;
};


template <class, class, class, class = void>
struct ccTouchesMoved {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccTouchesMoved<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesMoved)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesMoved))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccTouchesMoved));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccTouchesMoved));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccTouchesMoved>::value != 
		function_uuid<(base_type)&Base::ccTouchesMoved>::value;
};


template <class, class, class, class = void>
struct didAccelerate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct didAccelerate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didAccelerate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didAccelerate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didAccelerate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didAccelerate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::didAccelerate>::value != 
		function_uuid<(base_type)&Base::didAccelerate>::value;
};


template <class, class, class, class = void>
struct getTouchMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTouchMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTouchMode>::value != 
		function_uuid<(base_type)&Base::getTouchMode>::value;
};


template <class, class, class, class = void>
struct getTouchPriority {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPriority<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchPriority)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPriority))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchPriority));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPriority));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTouchPriority>::value != 
		function_uuid<(base_type)&Base::getTouchPriority>::value;
};


template <class, class, class, class = void>
struct isAccelerometerEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isAccelerometerEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isAccelerometerEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isAccelerometerEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isAccelerometerEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isAccelerometerEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isAccelerometerEnabled>::value != 
		function_uuid<(base_type)&Base::isAccelerometerEnabled>::value;
};


template <class, class, class, class = void>
struct isKeyboardEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isKeyboardEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isKeyboardEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeyboardEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isKeyboardEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeyboardEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isKeyboardEnabled>::value != 
		function_uuid<(base_type)&Base::isKeyboardEnabled>::value;
};


template <class, class, class, class = void>
struct isKeypadEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isKeypadEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isKeypadEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeypadEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isKeypadEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isKeypadEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isKeypadEnabled>::value != 
		function_uuid<(base_type)&Base::isKeypadEnabled>::value;
};


template <class, class, class, class = void>
struct isMouseEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isMouseEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isMouseEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isMouseEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isMouseEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isMouseEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isMouseEnabled>::value != 
		function_uuid<(base_type)&Base::isMouseEnabled>::value;
};


template <class, class, class, class = void>
struct isTouchEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isTouchEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isTouchEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isTouchEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isTouchEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isTouchEnabled>::value != 
		function_uuid<(base_type)&Base::isTouchEnabled>::value;
};


template <class, class, class, class = void>
struct keyBackClicked {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyBackClicked<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyBackClicked)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyBackClicked))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyBackClicked));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyBackClicked));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyBackClicked>::value != 
		function_uuid<(base_type)&Base::keyBackClicked>::value;
};


template <class, class, class, class = void>
struct keyDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyDown>::value != 
		function_uuid<(base_type)&Base::keyDown>::value;
};


template <class, class, class, class = void>
struct keyMenuClicked {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyMenuClicked<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyMenuClicked)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyMenuClicked))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyMenuClicked));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyMenuClicked));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyMenuClicked>::value != 
		function_uuid<(base_type)&Base::keyMenuClicked>::value;
};


template <class, class, class, class = void>
struct registerScriptTouchHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTouchHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptTouchHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTouchHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptTouchHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTouchHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerScriptTouchHandler>::value != 
		function_uuid<(base_type)&Base::registerScriptTouchHandler>::value;
};


template <class, class, class, class = void>
struct setAccelerometerEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometerEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometerEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAccelerometerEnabled>::value != 
		function_uuid<(base_type)&Base::setAccelerometerEnabled>::value;
};


template <class, class, class, class = void>
struct setAccelerometerInterval {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAccelerometerInterval<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometerInterval)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerInterval))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAccelerometerInterval));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAccelerometerInterval));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAccelerometerInterval>::value != 
		function_uuid<(base_type)&Base::setAccelerometerInterval>::value;
};


template <class, class, class, class = void>
struct setKeyboardEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setKeyboardEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeyboardEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeyboardEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeyboardEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setKeyboardEnabled>::value != 
		function_uuid<(base_type)&Base::setKeyboardEnabled>::value;
};


template <class, class, class, class = void>
struct setKeypadEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setKeypadEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeypadEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setKeypadEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setKeypadEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setKeypadEnabled>::value != 
		function_uuid<(base_type)&Base::setKeypadEnabled>::value;
};


template <class, class, class, class = void>
struct setMouseEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMouseEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMouseEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMouseEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMouseEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMouseEnabled>::value != 
		function_uuid<(base_type)&Base::setMouseEnabled>::value;
};


template <class, class, class, class = void>
struct setTouchEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTouchEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTouchEnabled>::value != 
		function_uuid<(base_type)&Base::setTouchEnabled>::value;
};


template <class, class, class, class = void>
struct setTouchMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTouchMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTouchMode>::value != 
		function_uuid<(base_type)&Base::setTouchMode>::value;
};


template <class, class, class, class = void>
struct setTouchPriority {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTouchPriority<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchPriority)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchPriority))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTouchPriority));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTouchPriority));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTouchPriority>::value != 
		function_uuid<(base_type)&Base::setTouchPriority>::value;
};


template <class, class, class, class = void>
struct unregisterScriptTouchHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTouchHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptTouchHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTouchHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptTouchHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTouchHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unregisterScriptTouchHandler>::value != 
		function_uuid<(base_type)&Base::unregisterScriptTouchHandler>::value;
};


template <class, class, class, class = void>
struct resetSystem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetSystem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetSystem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSystem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetSystem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetSystem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetSystem>::value != 
		function_uuid<(base_type)&Base::resetSystem>::value;
};


template <class, class, class, class = void>
struct resumeSystem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resumeSystem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeSystem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSystem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeSystem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSystem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resumeSystem>::value != 
		function_uuid<(base_type)&Base::resumeSystem>::value;
};


template <class, class, class, class = void>
struct stopSystem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopSystem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopSystem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopSystem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopSystem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopSystem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopSystem>::value != 
		function_uuid<(base_type)&Base::stopSystem>::value;
};


template <class, class, class, class = void>
struct alignItemsHorizontallyWithPadding {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorizontallyWithPadding<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsHorizontallyWithPadding)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorizontallyWithPadding))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsHorizontallyWithPadding));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorizontallyWithPadding));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::alignItemsHorizontallyWithPadding>::value != 
		function_uuid<(base_type)&Base::alignItemsHorizontallyWithPadding>::value;
};


template <class, class, class, class = void>
struct alignItemsVerticallyWithPadding {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsVerticallyWithPadding<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsVerticallyWithPadding)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsVerticallyWithPadding))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsVerticallyWithPadding));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsVerticallyWithPadding));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::alignItemsVerticallyWithPadding>::value != 
		function_uuid<(base_type)&Base::alignItemsVerticallyWithPadding>::value;
};


template <class, class, class, class = void>
struct createWithArray {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithArray<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithArray)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithArray))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithArray));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithArray));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithArray>::value != 
		function_uuid<(base_type)&Base::createWithArray>::value;
};


template <class, class, class, class = void>
struct createWithItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithItem>::value != 
		function_uuid<(base_type)&Base::createWithItem>::value;
};


template <class, class, class, class = void>
struct addChild {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addChild<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addChild)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addChild))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addChild));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addChild));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addChild>::value != 
		function_uuid<(base_type)&Base::addChild>::value;
};


template <class, class, class, class = void>
struct removeChild {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeChild<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeChild)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChild))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeChild));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChild));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeChild>::value != 
		function_uuid<(base_type)&Base::removeChild>::value;
};


template <class, class, class, class = void>
struct initWithArray {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithArray<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithArray)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithArray))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithArray));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithArray));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithArray>::value != 
		function_uuid<(base_type)&Base::initWithArray>::value;
};


template <class, class, class, class = void>
struct registerScriptTapHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptTapHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptTapHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTapHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptTapHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptTapHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerScriptTapHandler>::value != 
		function_uuid<(base_type)&Base::registerScriptTapHandler>::value;
};


template <class, class, class, class = void>
struct unregisterScriptTapHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptTapHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptTapHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTapHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptTapHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptTapHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unregisterScriptTapHandler>::value != 
		function_uuid<(base_type)&Base::unregisterScriptTapHandler>::value;
};


template <class, class, class, class = void>
struct rect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct rect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::rect>::value != 
		function_uuid<(base_type)&Base::rect>::value;
};


template <class, class, class, class = void>
struct incrementPriorityForSong {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct incrementPriorityForSong<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementPriorityForSong)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementPriorityForSong))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementPriorityForSong));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementPriorityForSong));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::incrementPriorityForSong>::value != 
		function_uuid<(base_type)&Base::incrementPriorityForSong>::value;
};


template <class, class, class, class = void>
struct sharedState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedState>::value != 
		function_uuid<(base_type)&Base::sharedState>::value;
};


template <class, class, class, class = void>
struct pathForSong {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pathForSong<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pathForSong)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pathForSong))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pathForSong));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pathForSong));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pathForSong>::value != 
		function_uuid<(base_type)&Base::pathForSong>::value;
};


template <class, class, class, class = void>
struct getDownloadedSongs {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDownloadedSongs<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDownloadedSongs)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDownloadedSongs))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDownloadedSongs));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDownloadedSongs));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDownloadedSongs>::value != 
		function_uuid<(base_type)&Base::getDownloadedSongs>::value;
};


template <class, class, class, class = void>
struct songStateChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct songStateChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::songStateChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::songStateChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::songStateChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::songStateChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::songStateChanged>::value != 
		function_uuid<(base_type)&Base::songStateChanged>::value;
};


template <class, class, class, class = void>
struct isEqual {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isEqual<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isEqual)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEqual))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isEqual));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isEqual));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isEqual>::value != 
		function_uuid<(base_type)&Base::isEqual>::value;
};


template <class, class, class, class = void>
struct copyWithZone {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct copyWithZone<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyWithZone)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyWithZone))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyWithZone));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyWithZone));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::copyWithZone>::value != 
		function_uuid<(base_type)&Base::copyWithZone>::value;
};


template <class, class, class, class = void>
struct boolValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct boolValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::boolValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boolValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::boolValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::boolValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::boolValue>::value != 
		function_uuid<(base_type)&Base::boolValue>::value;
};


template <class, class, class, class = void>
struct doubleValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct doubleValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doubleValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doubleValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doubleValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doubleValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::doubleValue>::value != 
		function_uuid<(base_type)&Base::doubleValue>::value;
};


template <class, class, class, class = void>
struct floatValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct floatValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::floatValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::floatValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::floatValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::floatValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::floatValue>::value != 
		function_uuid<(base_type)&Base::floatValue>::value;
};


template <class, class, class, class = void>
struct getCString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCString>::value != 
		function_uuid<(base_type)&Base::getCString>::value;
};


template <class, class, class, class = void>
struct intValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct intValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::intValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::intValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::intValue>::value != 
		function_uuid<(base_type)&Base::intValue>::value;
};


template <class, class, class, class = void>
struct getNormalImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNormalImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNormalImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNormalImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNormalImage>::value != 
		function_uuid<(base_type)&Base::getNormalImage>::value;
};


template <class, class, class, class = void>
struct setNormalImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setNormalImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setNormalImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNormalImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setNormalImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setNormalImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setNormalImage>::value != 
		function_uuid<(base_type)&Base::setNormalImage>::value;
};


template <class, class, class, class = void>
struct getSelectedImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSelectedImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSelectedImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSelectedImage>::value != 
		function_uuid<(base_type)&Base::getSelectedImage>::value;
};


template <class, class, class, class = void>
struct setSelectedImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSelectedImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSelectedImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelectedImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSelectedImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSelectedImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSelectedImage>::value != 
		function_uuid<(base_type)&Base::setSelectedImage>::value;
};


template <class, class, class, class = void>
struct getDisabledImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDisabledImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisabledImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDisabledImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDisabledImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDisabledImage>::value != 
		function_uuid<(base_type)&Base::getDisabledImage>::value;
};


template <class, class, class, class = void>
struct setDisabledImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDisabledImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisabledImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisabledImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisabledImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDisabledImage>::value != 
		function_uuid<(base_type)&Base::setDisabledImage>::value;
};


template <class, class, class, class = void>
struct updateImagesVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateImagesVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateImagesVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateImagesVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateImagesVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateImagesVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateImagesVisibility>::value != 
		function_uuid<(base_type)&Base::updateImagesVisibility>::value;
};


template <class, class, class, class = void>
struct initWithNormalSprite {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithNormalSprite<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithNormalSprite)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithNormalSprite))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithNormalSprite));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithNormalSprite));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithNormalSprite>::value != 
		function_uuid<(base_type)&Base::initWithNormalSprite>::value;
};


template <class, class, class, class = void>
struct reset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reset>::value != 
		function_uuid<(base_type)&Base::reset>::value;
};


template <class, class, class, class = void>
struct resumeStroke {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resumeStroke<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeStroke)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeStroke))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeStroke));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeStroke));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resumeStroke>::value != 
		function_uuid<(base_type)&Base::resumeStroke>::value;
};


template <class, class, class, class = void>
struct stopStroke {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopStroke<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopStroke)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopStroke))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopStroke));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopStroke));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopStroke>::value != 
		function_uuid<(base_type)&Base::stopStroke>::value;
};


template <class, class, class, class = void>
struct initWithFade {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithFade<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithFade)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFade))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithFade));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFade));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithFade>::value != 
		function_uuid<(base_type)&Base::initWithFade>::value;
};


template <class, class, class, class = void>
struct _setZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct _setZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::_setZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::_setZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::_setZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::_setZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::_setZOrder>::value != 
		function_uuid<(base_type)&Base::_setZOrder>::value;
};


template <class, class, class, class = void>
struct addComponent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addComponent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addComponent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addComponent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addComponent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addComponent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addComponent>::value != 
		function_uuid<(base_type)&Base::addComponent>::value;
};


template <class, class, class, class = void>
struct cleanup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct cleanup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cleanup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cleanup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cleanup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cleanup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::cleanup>::value != 
		function_uuid<(base_type)&Base::cleanup>::value;
};


template <class, class, class, class = void>
struct convertToNodeSpace {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct convertToNodeSpace<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToNodeSpace)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToNodeSpace))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToNodeSpace));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToNodeSpace));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::convertToNodeSpace>::value != 
		function_uuid<(base_type)&Base::convertToNodeSpace>::value;
};


template <class, class, class, class = void>
struct convertToWorldSpace {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct convertToWorldSpace<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToWorldSpace)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToWorldSpace))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::convertToWorldSpace));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::convertToWorldSpace));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::convertToWorldSpace>::value != 
		function_uuid<(base_type)&Base::convertToWorldSpace>::value;
};


template <class, class, class, class = void>
struct getActionByTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getActionByTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActionByTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionByTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActionByTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActionByTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getActionByTag>::value != 
		function_uuid<(base_type)&Base::getActionByTag>::value;
};


template <class, class, class, class = void>
struct getAnchorPoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAnchorPoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAnchorPoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAnchorPoint>::value != 
		function_uuid<(base_type)&Base::getAnchorPoint>::value;
};


template <class, class, class, class = void>
struct getAnchorPointInPoints {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAnchorPointInPoints<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAnchorPointInPoints)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPointInPoints))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAnchorPointInPoints));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAnchorPointInPoints));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAnchorPointInPoints>::value != 
		function_uuid<(base_type)&Base::getAnchorPointInPoints>::value;
};


template <class, class, class, class = void>
struct getCamera {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCamera<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCamera)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCamera))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCamera));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCamera));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCamera>::value != 
		function_uuid<(base_type)&Base::getCamera>::value;
};


template <class, class, class, class = void>
struct getChildByTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getChildByTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildByTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildByTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildByTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildByTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getChildByTag>::value != 
		function_uuid<(base_type)&Base::getChildByTag>::value;
};


template <class, class, class, class = void>
struct getChildren {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getChildren<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildren)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildren))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildren));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildren));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getChildren>::value != 
		function_uuid<(base_type)&Base::getChildren>::value;
};


template <class, class, class, class = void>
struct getChildrenCount {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getChildrenCount<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildrenCount)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildrenCount))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getChildrenCount));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getChildrenCount));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getChildrenCount>::value != 
		function_uuid<(base_type)&Base::getChildrenCount>::value;
};


template <class, class, class, class = void>
struct getContentSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getContentSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getContentSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getContentSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getContentSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getContentSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getContentSize>::value != 
		function_uuid<(base_type)&Base::getContentSize>::value;
};


template <class, class, class, class = void>
struct getGLServerState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGLServerState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGLServerState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGLServerState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGLServerState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGLServerState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGLServerState>::value != 
		function_uuid<(base_type)&Base::getGLServerState>::value;
};


template <class, class, class, class = void>
struct getGrid {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGrid<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGrid)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGrid))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGrid));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGrid));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGrid>::value != 
		function_uuid<(base_type)&Base::getGrid>::value;
};


template <class, class, class, class = void>
struct getOrderOfArrival {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOrderOfArrival<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrderOfArrival)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrderOfArrival))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrderOfArrival));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrderOfArrival));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOrderOfArrival>::value != 
		function_uuid<(base_type)&Base::getOrderOfArrival>::value;
};


template <class, class, class, class = void>
struct getParent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getParent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getParent>::value != 
		function_uuid<(base_type)&Base::getParent>::value;
};


template <class, class, class, class = void>
struct getPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPosition>::value != 
		function_uuid<(base_type)&Base::getPosition>::value;
};


template <class, class, class, class = void>
struct getPositionX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPositionX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPositionX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPositionX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPositionX>::value != 
		function_uuid<(base_type)&Base::getPositionX>::value;
};


template <class, class, class, class = void>
struct getPositionY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPositionY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPositionY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPositionY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPositionY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPositionY>::value != 
		function_uuid<(base_type)&Base::getPositionY>::value;
};


template <class, class, class, class = void>
struct getRotation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRotation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRotation>::value != 
		function_uuid<(base_type)&Base::getRotation>::value;
};


template <class, class, class, class = void>
struct getRotationX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRotationX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotationX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotationX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRotationX>::value != 
		function_uuid<(base_type)&Base::getRotationX>::value;
};


template <class, class, class, class = void>
struct getRotationY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRotationY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotationY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRotationY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRotationY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRotationY>::value != 
		function_uuid<(base_type)&Base::getRotationY>::value;
};


template <class, class, class, class = void>
struct getScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getScale>::value != 
		function_uuid<(base_type)&Base::getScale>::value;
};


template <class, class, class, class = void>
struct getScaleX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getScaleX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaleX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaleX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getScaleX>::value != 
		function_uuid<(base_type)&Base::getScaleX>::value;
};


template <class, class, class, class = void>
struct getScaleY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getScaleY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaleY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaleY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaleY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getScaleY>::value != 
		function_uuid<(base_type)&Base::getScaleY>::value;
};


template <class, class, class, class = void>
struct getScaledContentSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getScaledContentSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaledContentSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaledContentSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getScaledContentSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getScaledContentSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getScaledContentSize>::value != 
		function_uuid<(base_type)&Base::getScaledContentSize>::value;
};


template <class, class, class, class = void>
struct getShaderProgram {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getShaderProgram<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getShaderProgram)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getShaderProgram))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getShaderProgram));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getShaderProgram));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getShaderProgram>::value != 
		function_uuid<(base_type)&Base::getShaderProgram>::value;
};


template <class, class, class, class = void>
struct getSkewX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSkewX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSkewX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSkewX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSkewX>::value != 
		function_uuid<(base_type)&Base::getSkewX>::value;
};


template <class, class, class, class = void>
struct getSkewY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSkewY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSkewY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSkewY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSkewY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSkewY>::value != 
		function_uuid<(base_type)&Base::getSkewY>::value;
};


template <class, class, class, class = void>
struct getUserData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getUserData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUserData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUserData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getUserData>::value != 
		function_uuid<(base_type)&Base::getUserData>::value;
};


template <class, class, class, class = void>
struct getUserObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getUserObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUserObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUserObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUserObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getUserObject>::value != 
		function_uuid<(base_type)&Base::getUserObject>::value;
};


template <class, class, class, class = void>
struct getVertexZ {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getVertexZ<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getVertexZ)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getVertexZ))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getVertexZ));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getVertexZ));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getVertexZ>::value != 
		function_uuid<(base_type)&Base::getVertexZ>::value;
};


template <class, class, class, class = void>
struct getZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getZOrder>::value != 
		function_uuid<(base_type)&Base::getZOrder>::value;
};


template <class, class, class, class = void>
struct ignoreAnchorPointForPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ignoreAnchorPointForPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreAnchorPointForPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreAnchorPointForPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreAnchorPointForPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreAnchorPointForPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ignoreAnchorPointForPosition>::value != 
		function_uuid<(base_type)&Base::ignoreAnchorPointForPosition>::value;
};


template <class, class, class, class = void>
struct isIgnoreAnchorPointForPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isIgnoreAnchorPointForPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isIgnoreAnchorPointForPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIgnoreAnchorPointForPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isIgnoreAnchorPointForPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIgnoreAnchorPointForPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isIgnoreAnchorPointForPosition>::value != 
		function_uuid<(base_type)&Base::isIgnoreAnchorPointForPosition>::value;
};


template <class, class, class, class = void>
struct isRunning {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isRunning<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isRunning)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isRunning))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isRunning));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isRunning));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isRunning>::value != 
		function_uuid<(base_type)&Base::isRunning>::value;
};


template <class, class, class, class = void>
struct isVisible {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isVisible<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isVisible)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isVisible))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isVisible));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isVisible));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isVisible>::value != 
		function_uuid<(base_type)&Base::isVisible>::value;
};


template <class, class, class, class = void>
struct nodeToParentTransform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct nodeToParentTransform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::nodeToParentTransform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToParentTransform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::nodeToParentTransform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToParentTransform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::nodeToParentTransform>::value != 
		function_uuid<(base_type)&Base::nodeToParentTransform>::value;
};


template <class, class, class, class = void>
struct nodeToWorldTransform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct nodeToWorldTransform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::nodeToWorldTransform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToWorldTransform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::nodeToWorldTransform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::nodeToWorldTransform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::nodeToWorldTransform>::value != 
		function_uuid<(base_type)&Base::nodeToWorldTransform>::value;
};


template <class, class, class, class = void>
struct parentToNodeTransform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct parentToNodeTransform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::parentToNodeTransform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentToNodeTransform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::parentToNodeTransform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentToNodeTransform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::parentToNodeTransform>::value != 
		function_uuid<(base_type)&Base::parentToNodeTransform>::value;
};


template <class, class, class, class = void>
struct pauseSchedulerAndActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pauseSchedulerAndActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pauseSchedulerAndActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseSchedulerAndActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pauseSchedulerAndActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseSchedulerAndActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pauseSchedulerAndActions>::value != 
		function_uuid<(base_type)&Base::pauseSchedulerAndActions>::value;
};


template <class, class, class, class = void>
struct registerScriptHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerScriptHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerScriptHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerScriptHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerScriptHandler>::value != 
		function_uuid<(base_type)&Base::registerScriptHandler>::value;
};


template <class, class, class, class = void>
struct removeAllChildren {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildren<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllChildren)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildren))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllChildren));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildren));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllChildren>::value != 
		function_uuid<(base_type)&Base::removeAllChildren>::value;
};


template <class, class, class, class = void>
struct removeAllChildrenWithCleanup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllChildrenWithCleanup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllChildrenWithCleanup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildrenWithCleanup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllChildrenWithCleanup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllChildrenWithCleanup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllChildrenWithCleanup>::value != 
		function_uuid<(base_type)&Base::removeAllChildrenWithCleanup>::value;
};


template <class, class, class, class = void>
struct removeAllComponents {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllComponents<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllComponents)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllComponents))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllComponents));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllComponents));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllComponents>::value != 
		function_uuid<(base_type)&Base::removeAllComponents>::value;
};


template <class, class, class, class = void>
struct removeChildByTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeChildByTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeChildByTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChildByTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeChildByTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeChildByTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeChildByTag>::value != 
		function_uuid<(base_type)&Base::removeChildByTag>::value;
};


template <class, class, class, class = void>
struct removeComponent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeComponent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeComponent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeComponent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeComponent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeComponent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeComponent>::value != 
		function_uuid<(base_type)&Base::removeComponent>::value;
};


template <class, class, class, class = void>
struct removeFromParent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromParent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromParent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeFromParent>::value != 
		function_uuid<(base_type)&Base::removeFromParent>::value;
};


template <class, class, class, class = void>
struct removeFromParentAndCleanup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeFromParentAndCleanup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromParentAndCleanup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParentAndCleanup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromParentAndCleanup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromParentAndCleanup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeFromParentAndCleanup>::value != 
		function_uuid<(base_type)&Base::removeFromParentAndCleanup>::value;
};


template <class, class, class, class = void>
struct removeMeAndCleanup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeMeAndCleanup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeMeAndCleanup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeMeAndCleanup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeMeAndCleanup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeMeAndCleanup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeMeAndCleanup>::value != 
		function_uuid<(base_type)&Base::removeMeAndCleanup>::value;
};


template <class, class, class, class = void>
struct reorderChild {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reorderChild<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reorderChild)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderChild))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reorderChild));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderChild));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reorderChild>::value != 
		function_uuid<(base_type)&Base::reorderChild>::value;
};


template <class, class, class, class = void>
struct resumeSchedulerAndActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resumeSchedulerAndActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeSchedulerAndActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSchedulerAndActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeSchedulerAndActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeSchedulerAndActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resumeSchedulerAndActions>::value != 
		function_uuid<(base_type)&Base::resumeSchedulerAndActions>::value;
};


template <class, class, class, class = void>
struct runAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runAction>::value != 
		function_uuid<(base_type)&Base::runAction>::value;
};


template <class, class, class, class = void>
struct schedule {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct schedule<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::schedule)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::schedule))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::schedule));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::schedule));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::schedule>::value != 
		function_uuid<(base_type)&Base::schedule>::value;
};


template <class, class, class, class = void>
struct scheduleUpdate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleUpdate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleUpdate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scheduleUpdate>::value != 
		function_uuid<(base_type)&Base::scheduleUpdate>::value;
};


template <class, class, class, class = void>
struct setGLServerState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGLServerState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGLServerState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGLServerState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGLServerState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGLServerState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGLServerState>::value != 
		function_uuid<(base_type)&Base::setGLServerState>::value;
};


template <class, class, class, class = void>
struct setGrid {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGrid<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGrid)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGrid))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGrid));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGrid));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGrid>::value != 
		function_uuid<(base_type)&Base::setGrid>::value;
};


template <class, class, class, class = void>
struct setOrderOfArrival {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setOrderOfArrival<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOrderOfArrival)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrderOfArrival))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOrderOfArrival));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrderOfArrival));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setOrderOfArrival>::value != 
		function_uuid<(base_type)&Base::setOrderOfArrival>::value;
};


template <class, class, class, class = void>
struct setParent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setParent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setParent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setParent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setParent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setParent>::value != 
		function_uuid<(base_type)&Base::setParent>::value;
};


template <class, class, class, class = void>
struct setPositionX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPositionX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPositionX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPositionX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPositionX>::value != 
		function_uuid<(base_type)&Base::setPositionX>::value;
};


template <class, class, class, class = void>
struct setPositionY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPositionY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPositionY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPositionY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPositionY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPositionY>::value != 
		function_uuid<(base_type)&Base::setPositionY>::value;
};


template <class, class, class, class = void>
struct setRotationX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRotationX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotationX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotationX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRotationX>::value != 
		function_uuid<(base_type)&Base::setRotationX>::value;
};


template <class, class, class, class = void>
struct setRotationY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRotationY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotationY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRotationY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRotationY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRotationY>::value != 
		function_uuid<(base_type)&Base::setRotationY>::value;
};


template <class, class, class, class = void>
struct setShaderProgram {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setShaderProgram<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setShaderProgram)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setShaderProgram))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setShaderProgram));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setShaderProgram));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setShaderProgram>::value != 
		function_uuid<(base_type)&Base::setShaderProgram>::value;
};


template <class, class, class, class = void>
struct setSkewX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSkewX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSkewX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSkewX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSkewX>::value != 
		function_uuid<(base_type)&Base::setSkewX>::value;
};


template <class, class, class, class = void>
struct setSkewY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSkewY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSkewY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSkewY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSkewY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSkewY>::value != 
		function_uuid<(base_type)&Base::setSkewY>::value;
};


template <class, class, class, class = void>
struct setUserData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setUserData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUserData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUserData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setUserData>::value != 
		function_uuid<(base_type)&Base::setUserData>::value;
};


template <class, class, class, class = void>
struct setUserObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setUserObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUserObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUserObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUserObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setUserObject>::value != 
		function_uuid<(base_type)&Base::setUserObject>::value;
};


template <class, class, class, class = void>
struct setVertexZ {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setVertexZ<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVertexZ)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexZ))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVertexZ));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexZ));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setVertexZ>::value != 
		function_uuid<(base_type)&Base::setVertexZ>::value;
};


template <class, class, class, class = void>
struct setZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setZOrder>::value != 
		function_uuid<(base_type)&Base::setZOrder>::value;
};


template <class, class, class, class = void>
struct sortAllChildren {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sortAllChildren<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortAllChildren)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortAllChildren))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortAllChildren));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortAllChildren));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sortAllChildren>::value != 
		function_uuid<(base_type)&Base::sortAllChildren>::value;
};


template <class, class, class, class = void>
struct stopActionByTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopActionByTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopActionByTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionByTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopActionByTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionByTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopActionByTag>::value != 
		function_uuid<(base_type)&Base::stopActionByTag>::value;
};


template <class, class, class, class = void>
struct stopAllActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopAllActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopAllActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopAllActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopAllActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopAllActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopAllActions>::value != 
		function_uuid<(base_type)&Base::stopAllActions>::value;
};


template <class, class, class, class = void>
struct unregisterScriptHandler {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unregisterScriptHandler<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptHandler)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptHandler))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterScriptHandler));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterScriptHandler));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unregisterScriptHandler>::value != 
		function_uuid<(base_type)&Base::unregisterScriptHandler>::value;
};


template <class, class, class, class = void>
struct unschedule {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unschedule<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unschedule)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unschedule))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unschedule));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unschedule));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unschedule>::value != 
		function_uuid<(base_type)&Base::unschedule>::value;
};


template <class, class, class, class = void>
struct unscheduleAllSelectors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllSelectors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleAllSelectors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllSelectors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleAllSelectors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllSelectors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unscheduleAllSelectors>::value != 
		function_uuid<(base_type)&Base::unscheduleAllSelectors>::value;
};


template <class, class, class, class = void>
struct unscheduleUpdate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleUpdate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleUpdate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleUpdate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleUpdate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleUpdate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unscheduleUpdate>::value != 
		function_uuid<(base_type)&Base::unscheduleUpdate>::value;
};


template <class, class, class, class = void>
struct updateTransform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateTransform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTransform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTransform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTransform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTransform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateTransform>::value != 
		function_uuid<(base_type)&Base::updateTransform>::value;
};


template <class, class, class, class = void>
struct updateTweenAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateTweenAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTweenAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTweenAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateTweenAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateTweenAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateTweenAction>::value != 
		function_uuid<(base_type)&Base::updateTweenAction>::value;
};


template <class, class, class, class = void>
struct worldToNodeTransform {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct worldToNodeTransform<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::worldToNodeTransform)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::worldToNodeTransform))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::worldToNodeTransform));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::worldToNodeTransform));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::worldToNodeTransform>::value != 
		function_uuid<(base_type)&Base::worldToNodeTransform>::value;
};


template <class, class, class, class = void>
struct begin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct begin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::begin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::begin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::begin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::begin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::begin>::value != 
		function_uuid<(base_type)&Base::begin>::value;
};


template <class, class, class, class = void>
struct end {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct end<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::end)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::end))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::end));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::end));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::end>::value != 
		function_uuid<(base_type)&Base::end>::value;
};


template <class, class, class, class = void>
struct newCCImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct newCCImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::newCCImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::newCCImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::newCCImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::newCCImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::newCCImage>::value != 
		function_uuid<(base_type)&Base::newCCImage>::value;
};


template <class, class, class, class = void>
struct autorelease {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct autorelease<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::autorelease)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::autorelease))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::autorelease));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::autorelease));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::autorelease>::value != 
		function_uuid<(base_type)&Base::autorelease>::value;
};


template <class, class, class, class = void>
struct canEncode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct canEncode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::canEncode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canEncode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::canEncode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canEncode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::canEncode>::value != 
		function_uuid<(base_type)&Base::canEncode>::value;
};


template <class, class, class, class = void>
struct encodeWithCoder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct encodeWithCoder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::encodeWithCoder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeWithCoder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::encodeWithCoder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeWithCoder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::encodeWithCoder>::value != 
		function_uuid<(base_type)&Base::encodeWithCoder>::value;
};


template <class, class, class, class = void>
struct getTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTag>::value != 
		function_uuid<(base_type)&Base::getTag>::value;
};


template <class, class, class, class = void>
struct release {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct release<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::release)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::release))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::release));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::release));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::release>::value != 
		function_uuid<(base_type)&Base::release>::value;
};


template <class, class, class, class = void>
struct retain {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct retain<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::retain)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::retain))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::retain));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::retain));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::retain>::value != 
		function_uuid<(base_type)&Base::retain>::value;
};


template <class, class, class, class = void>
struct setTag {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTag<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTag)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTag))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTag));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTag));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTag>::value != 
		function_uuid<(base_type)&Base::setTag>::value;
};


template <class, class, class, class = void>
struct getHighestChildZ {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getHighestChildZ<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getHighestChildZ)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getHighestChildZ))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getHighestChildZ));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getHighestChildZ));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getHighestChildZ>::value != 
		function_uuid<(base_type)&Base::getHighestChildZ>::value;
};


template <class, class, class, class = void>
struct scheduleSelector {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scheduleSelector<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleSelector)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleSelector))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleSelector));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleSelector));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scheduleSelector>::value != 
		function_uuid<(base_type)&Base::scheduleSelector>::value;
};


template <class, class, class, class = void>
struct scheduleUpdateForTarget {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scheduleUpdateForTarget<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleUpdateForTarget)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdateForTarget))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scheduleUpdateForTarget));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scheduleUpdateForTarget));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scheduleUpdateForTarget>::value != 
		function_uuid<(base_type)&Base::scheduleUpdateForTarget>::value;
};


template <class, class, class, class = void>
struct unscheduleAllForTarget {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unscheduleAllForTarget<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleAllForTarget)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllForTarget))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unscheduleAllForTarget));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unscheduleAllForTarget));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unscheduleAllForTarget>::value != 
		function_uuid<(base_type)&Base::unscheduleAllForTarget>::value;
};


template <class, class, class, class = void>
struct initWithTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithTexture>::value != 
		function_uuid<(base_type)&Base::initWithTexture>::value;
};


template <class, class, class, class = void>
struct initWithSpriteFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithSpriteFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithSpriteFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithSpriteFrame>::value != 
		function_uuid<(base_type)&Base::initWithSpriteFrame>::value;
};


template <class, class, class, class = void>
struct initWithSpriteFrameName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithSpriteFrameName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithSpriteFrameName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrameName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithSpriteFrameName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithSpriteFrameName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithSpriteFrameName>::value != 
		function_uuid<(base_type)&Base::initWithSpriteFrameName>::value;
};


template <class, class, class, class = void>
struct initWithFile {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithFile<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithFile)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFile))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithFile));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithFile));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithFile>::value != 
		function_uuid<(base_type)&Base::initWithFile>::value;
};


template <class, class, class, class = void>
struct setTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTexture>::value != 
		function_uuid<(base_type)&Base::setTexture>::value;
};


template <class, class, class, class = void>
struct getTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTexture>::value != 
		function_uuid<(base_type)&Base::getTexture>::value;
};


template <class, class, class, class = void>
struct setChildColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setChildColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setChildColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setChildColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setChildColor>::value != 
		function_uuid<(base_type)&Base::setChildColor>::value;
};


template <class, class, class, class = void>
struct setChildOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setChildOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setChildOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setChildOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setChildOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setChildOpacity>::value != 
		function_uuid<(base_type)&Base::setChildOpacity>::value;
};


template <class, class, class, class = void>
struct getBatchNode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBatchNode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBatchNode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBatchNode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBatchNode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBatchNode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBatchNode>::value != 
		function_uuid<(base_type)&Base::getBatchNode>::value;
};


template <class, class, class, class = void>
struct setBatchNode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setBatchNode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBatchNode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBatchNode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBatchNode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBatchNode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setBatchNode>::value != 
		function_uuid<(base_type)&Base::setBatchNode>::value;
};


template <class, class, class, class = void>
struct refreshTextureRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct refreshTextureRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshTextureRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshTextureRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshTextureRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshTextureRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::refreshTextureRect>::value != 
		function_uuid<(base_type)&Base::refreshTextureRect>::value;
};


template <class, class, class, class = void>
struct setTextureRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTextureRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTextureRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTextureRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTextureRect>::value != 
		function_uuid<(base_type)&Base::setTextureRect>::value;
};


template <class, class, class, class = void>
struct setVertexRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setVertexRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVertexRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setVertexRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setVertexRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setVertexRect>::value != 
		function_uuid<(base_type)&Base::setVertexRect>::value;
};


template <class, class, class, class = void>
struct setDisplayFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisplayFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisplayFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDisplayFrame>::value != 
		function_uuid<(base_type)&Base::setDisplayFrame>::value;
};


template <class, class, class, class = void>
struct isFrameDisplayed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isFrameDisplayed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFrameDisplayed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFrameDisplayed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFrameDisplayed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFrameDisplayed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isFrameDisplayed>::value != 
		function_uuid<(base_type)&Base::isFrameDisplayed>::value;
};


template <class, class, class, class = void>
struct displayFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct displayFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::displayFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::displayFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::displayFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::displayFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::displayFrame>::value != 
		function_uuid<(base_type)&Base::displayFrame>::value;
};


template <class, class, class, class = void>
struct setDisplayFrameWithAnimationName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDisplayFrameWithAnimationName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisplayFrameWithAnimationName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrameWithAnimationName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDisplayFrameWithAnimationName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDisplayFrameWithAnimationName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDisplayFrameWithAnimationName>::value != 
		function_uuid<(base_type)&Base::setDisplayFrameWithAnimationName>::value;
};


template <class, class, class, class = void>
struct setTextureCoords {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTextureCoords<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTextureCoords)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureCoords))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTextureCoords));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTextureCoords));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTextureCoords>::value != 
		function_uuid<(base_type)&Base::setTextureCoords>::value;
};


template <class, class, class, class = void>
struct updateBlendFunc {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendFunc<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlendFunc)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendFunc))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlendFunc));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendFunc));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBlendFunc>::value != 
		function_uuid<(base_type)&Base::updateBlendFunc>::value;
};


template <class, class, class, class = void>
struct setReorderChildDirtyRecursively {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setReorderChildDirtyRecursively<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setReorderChildDirtyRecursively)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setReorderChildDirtyRecursively))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setReorderChildDirtyRecursively));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setReorderChildDirtyRecursively));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setReorderChildDirtyRecursively>::value != 
		function_uuid<(base_type)&Base::setReorderChildDirtyRecursively>::value;
};


template <class, class, class, class = void>
struct setDirtyRecursively {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDirtyRecursively<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDirtyRecursively)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDirtyRecursively))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDirtyRecursively));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDirtyRecursively));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDirtyRecursively>::value != 
		function_uuid<(base_type)&Base::setDirtyRecursively>::value;
};


template <class, class, class, class = void>
struct createWithSpriteFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithSpriteFrame>::value != 
		function_uuid<(base_type)&Base::createWithSpriteFrame>::value;
};


template <class, class, class, class = void>
struct createWithSpriteFrameName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithSpriteFrameName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrameName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrameName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithSpriteFrameName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithSpriteFrameName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithSpriteFrameName>::value != 
		function_uuid<(base_type)&Base::createWithSpriteFrameName>::value;
};


template <class, class, class, class = void>
struct getUsedAtlasCapacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getUsedAtlasCapacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUsedAtlasCapacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUsedAtlasCapacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUsedAtlasCapacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUsedAtlasCapacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getUsedAtlasCapacity>::value != 
		function_uuid<(base_type)&Base::getUsedAtlasCapacity>::value;
};


template <class, class, class, class = void>
struct increaseAtlasCapacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct increaseAtlasCapacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::increaseAtlasCapacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::increaseAtlasCapacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::increaseAtlasCapacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::increaseAtlasCapacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::increaseAtlasCapacity>::value != 
		function_uuid<(base_type)&Base::increaseAtlasCapacity>::value;
};


template <class, class, class, class = void>
struct getIconType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getIconType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIconType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIconType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIconType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIconType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getIconType>::value != 
		function_uuid<(base_type)&Base::getIconType>::value;
};


template <class, class, class, class = void>
struct getPlayerCube {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerCube<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerCube)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerCube))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerCube));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerCube));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerCube>::value != 
		function_uuid<(base_type)&Base::getPlayerCube>::value;
};


template <class, class, class, class = void>
struct getPlayerShip {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerShip<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerShip)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerShip))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerShip));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerShip));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerShip>::value != 
		function_uuid<(base_type)&Base::getPlayerShip>::value;
};


template <class, class, class, class = void>
struct getPlayerBall {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBall<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerBall)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBall))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerBall));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBall));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerBall>::value != 
		function_uuid<(base_type)&Base::getPlayerBall>::value;
};


template <class, class, class, class = void>
struct getPlayerUfo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerUfo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerUfo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerUfo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerUfo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerUfo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerUfo>::value != 
		function_uuid<(base_type)&Base::getPlayerUfo>::value;
};


template <class, class, class, class = void>
struct getPlayerWave {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerWave<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerWave)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerWave))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerWave));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerWave));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerWave>::value != 
		function_uuid<(base_type)&Base::getPlayerWave>::value;
};


template <class, class, class, class = void>
struct getPlayerRobot {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerRobot<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerRobot)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerRobot))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerRobot));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerRobot));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerRobot>::value != 
		function_uuid<(base_type)&Base::getPlayerRobot>::value;
};


template <class, class, class, class = void>
struct getPlayerSpider {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerSpider<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerSpider)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerSpider))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerSpider));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerSpider));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerSpider>::value != 
		function_uuid<(base_type)&Base::getPlayerSpider>::value;
};


template <class, class, class, class = void>
struct getPlayerStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerStreak>::value != 
		function_uuid<(base_type)&Base::getPlayerStreak>::value;
};


template <class, class, class, class = void>
struct getGlowEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGlowEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGlowEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGlowEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGlowEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGlowEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGlowEnabled>::value != 
		function_uuid<(base_type)&Base::getGlowEnabled>::value;
};


template <class, class, class, class = void>
struct getPlayerExplosion {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerExplosion<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerExplosion)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerExplosion))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerExplosion));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerExplosion));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerExplosion>::value != 
		function_uuid<(base_type)&Base::getPlayerExplosion>::value;
};


template <class, class, class, class = void>
struct getPlayerColor1 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor1<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor1)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor1))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor1));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor1));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerColor1>::value != 
		function_uuid<(base_type)&Base::getPlayerColor1>::value;
};


template <class, class, class, class = void>
struct getPlayerColor2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerColor2>::value != 
		function_uuid<(base_type)&Base::getPlayerColor2>::value;
};


template <class, class, class, class = void>
struct getPlayerName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerName>::value != 
		function_uuid<(base_type)&Base::getPlayerName>::value;
};


template <class, class, class, class = void>
struct getMaxS {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMaxS<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxS)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxS))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxS));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxS));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMaxS>::value != 
		function_uuid<(base_type)&Base::getMaxS>::value;
};


template <class, class, class, class = void>
struct getMaxT {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMaxT<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxT)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxT))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxT));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxT));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMaxT>::value != 
		function_uuid<(base_type)&Base::getMaxT>::value;
};


template <class, class, class, class = void>
struct getName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getName>::value != 
		function_uuid<(base_type)&Base::getName>::value;
};


template <class, class, class, class = void>
struct getPixelFormat {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPixelFormat<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelFormat)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelFormat))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelFormat));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelFormat));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPixelFormat>::value != 
		function_uuid<(base_type)&Base::getPixelFormat>::value;
};


template <class, class, class, class = void>
struct getPixelsHigh {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsHigh<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelsHigh)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsHigh))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelsHigh));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsHigh));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPixelsHigh>::value != 
		function_uuid<(base_type)&Base::getPixelsHigh>::value;
};


template <class, class, class, class = void>
struct getPixelsWide {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPixelsWide<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelsWide)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsWide))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPixelsWide));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPixelsWide));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPixelsWide>::value != 
		function_uuid<(base_type)&Base::getPixelsWide>::value;
};


template <class, class, class, class = void>
struct initPremultipliedATextureWithImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initPremultipliedATextureWithImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initPremultipliedATextureWithImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initPremultipliedATextureWithImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initPremultipliedATextureWithImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initPremultipliedATextureWithImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initPremultipliedATextureWithImage>::value != 
		function_uuid<(base_type)&Base::initPremultipliedATextureWithImage>::value;
};


template <class, class, class, class = void>
struct initWithData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithData>::value != 
		function_uuid<(base_type)&Base::initWithData>::value;
};


template <class, class, class, class = void>
struct setAliasTexParameters {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAliasTexParameters<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAliasTexParameters)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAliasTexParameters))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAliasTexParameters));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAliasTexParameters));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAliasTexParameters>::value != 
		function_uuid<(base_type)&Base::setAliasTexParameters>::value;
};


template <class, class, class, class = void>
struct setAntiAliasTexParameters {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAntiAliasTexParameters<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAntiAliasTexParameters)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAntiAliasTexParameters))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAntiAliasTexParameters));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAntiAliasTexParameters));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAntiAliasTexParameters>::value != 
		function_uuid<(base_type)&Base::setAntiAliasTexParameters>::value;
};


template <class, class, class, class = void>
struct setMaxS {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMaxS<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxS)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxS))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxS));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxS));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMaxS>::value != 
		function_uuid<(base_type)&Base::setMaxS>::value;
};


template <class, class, class, class = void>
struct setMaxT {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMaxT<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxT)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxT))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxT));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxT));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMaxT>::value != 
		function_uuid<(base_type)&Base::setMaxT>::value;
};


template <class, class, class, class = void>
struct initWithImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithImage>::value != 
		function_uuid<(base_type)&Base::initWithImage>::value;
};


template <class, class, class, class = void>
struct setTexParameters {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setTexParameters<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTexParameters)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexParameters))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setTexParameters));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setTexParameters));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setTexParameters>::value != 
		function_uuid<(base_type)&Base::setTexParameters>::value;
};


template <class, class, class, class = void>
struct circleWaveWillBeRemoved {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct circleWaveWillBeRemoved<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::circleWaveWillBeRemoved)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::circleWaveWillBeRemoved))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::circleWaveWillBeRemoved));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::circleWaveWillBeRemoved));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::circleWaveWillBeRemoved>::value != 
		function_uuid<(base_type)&Base::circleWaveWillBeRemoved>::value;
};


template <class, class, class, class = void>
struct addImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addImage>::value != 
		function_uuid<(base_type)&Base::addImage>::value;
};


template <class, class, class, class = void>
struct sharedTextureCache {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedTextureCache<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedTextureCache)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedTextureCache))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedTextureCache));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedTextureCache));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedTextureCache>::value != 
		function_uuid<(base_type)&Base::sharedTextureCache>::value;
};


template <class, class, class, class = void>
struct gettimeofdayCocos2d {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct gettimeofdayCocos2d<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gettimeofdayCocos2d)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gettimeofdayCocos2d))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gettimeofdayCocos2d));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gettimeofdayCocos2d));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::gettimeofdayCocos2d>::value != 
		function_uuid<(base_type)&Base::gettimeofdayCocos2d>::value;
};


template <class, class, class, class = void>
struct onEdit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onEdit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEdit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEdit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onEdit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onEdit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onEdit>::value != 
		function_uuid<(base_type)&Base::onEdit>::value;
};


template <class, class, class, class = void>
struct createToggleButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createToggleButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createToggleButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createToggleButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createToggleButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createToggleButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createToggleButton>::value != 
		function_uuid<(base_type)&Base::createToggleButton>::value;
};


template <class, class, class, class = void>
struct disableMetering {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct disableMetering<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableMetering)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMetering))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableMetering));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMetering));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::disableMetering>::value != 
		function_uuid<(base_type)&Base::disableMetering>::value;
};


template <class, class, class, class = void>
struct enableMetering {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enableMetering<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableMetering)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMetering))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableMetering));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMetering));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enableMetering>::value != 
		function_uuid<(base_type)&Base::enableMetering>::value;
};


template <class, class, class, class = void>
struct getMeteringValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMeteringValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMeteringValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMeteringValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMeteringValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMeteringValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMeteringValue>::value != 
		function_uuid<(base_type)&Base::getMeteringValue>::value;
};


template <class, class, class, class = void>
struct playBackgroundMusic {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playBackgroundMusic<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playBackgroundMusic)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBackgroundMusic))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playBackgroundMusic));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playBackgroundMusic));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playBackgroundMusic>::value != 
		function_uuid<(base_type)&Base::playBackgroundMusic>::value;
};


template <class, class, class, class = void>
struct playEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playEffect>::value != 
		function_uuid<(base_type)&Base::playEffect>::value;
};


template <class, class, class, class = void>
struct stopBackgroundMusic {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopBackgroundMusic<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopBackgroundMusic)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBackgroundMusic))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopBackgroundMusic));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopBackgroundMusic));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopBackgroundMusic>::value != 
		function_uuid<(base_type)&Base::stopBackgroundMusic>::value;
};


template <class, class, class, class = void>
struct sharedManager {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedManager<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedManager)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedManager))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedManager));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedManager));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedManager>::value != 
		function_uuid<(base_type)&Base::sharedManager>::value;
};


template <class, class, class, class = void>
struct getDelta {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDelta<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDelta)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelta))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDelta));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDelta));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDelta>::value != 
		function_uuid<(base_type)&Base::getDelta>::value;
};


template <class, class, class, class = void>
struct getLocationInView {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLocationInView<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLocationInView)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocationInView))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLocationInView));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocationInView));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLocationInView>::value != 
		function_uuid<(base_type)&Base::getLocationInView>::value;
};


template <class, class, class, class = void>
struct getPreviousLocationInView {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPreviousLocationInView<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPreviousLocationInView)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreviousLocationInView))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPreviousLocationInView));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreviousLocationInView));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPreviousLocationInView>::value != 
		function_uuid<(base_type)&Base::getPreviousLocationInView>::value;
};


template <class, class, class, class = void>
struct getLocation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLocation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLocation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLocation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLocation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLocation>::value != 
		function_uuid<(base_type)&Base::getLocation>::value;
};


template <class, class, class, class = void>
struct decrementForcePrio {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct decrementForcePrio<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::decrementForcePrio)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::decrementForcePrio))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::decrementForcePrio));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::decrementForcePrio));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::decrementForcePrio>::value != 
		function_uuid<(base_type)&Base::decrementForcePrio>::value;
};


template <class, class, class, class = void>
struct incrementForcePrio {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct incrementForcePrio<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementForcePrio)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementForcePrio))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementForcePrio));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementForcePrio));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::incrementForcePrio>::value != 
		function_uuid<(base_type)&Base::incrementForcePrio>::value;
};


template <class, class, class, class = void>
struct touches {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct touches<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::touches)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touches))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::touches));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::touches));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::touches>::value != 
		function_uuid<(base_type)&Base::touches>::value;
};


template <class, class, class, class = void>
struct createNewLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createNewLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createNewLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createNewLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createNewLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createNewLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createNewLevel>::value != 
		function_uuid<(base_type)&Base::createNewLevel>::value;
};


template <class, class, class, class = void>
struct getPageInfo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPageInfo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPageInfo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPageInfo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPageInfo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPageInfo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPageInfo>::value != 
		function_uuid<(base_type)&Base::getPageInfo>::value;
};


template <class, class, class, class = void>
struct getStoredOnlineLevels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStoredOnlineLevels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStoredOnlineLevels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStoredOnlineLevels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStoredOnlineLevels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStoredOnlineLevels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStoredOnlineLevels>::value != 
		function_uuid<(base_type)&Base::getStoredOnlineLevels>::value;
};


template <class, class, class, class = void>
struct getTopArtists {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtists<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTopArtists)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtists))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTopArtists));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtists));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTopArtists>::value != 
		function_uuid<(base_type)&Base::getTopArtists>::value;
};


template <class, class, class, class = void>
struct getTopArtistsKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTopArtistsKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTopArtistsKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtistsKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTopArtistsKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTopArtistsKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTopArtistsKey>::value != 
		function_uuid<(base_type)&Base::getTopArtistsKey>::value;
};


template <class, class, class, class = void>
struct makeTimeStamp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct makeTimeStamp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::makeTimeStamp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::makeTimeStamp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::makeTimeStamp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::makeTimeStamp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::makeTimeStamp>::value != 
		function_uuid<(base_type)&Base::makeTimeStamp>::value;
};


template <class, class, class, class = void>
struct getMainLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMainLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMainLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMainLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMainLevel>::value != 
		function_uuid<(base_type)&Base::getMainLevel>::value;
};


template <class, class, class, class = void>
struct setColorValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setColorValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColorValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColorValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setColorValue>::value != 
		function_uuid<(base_type)&Base::setColorValue>::value;
};


template <class, class, class, class = void>
struct HSVfromRGB {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct HSVfromRGB<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::HSVfromRGB)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::HSVfromRGB))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::HSVfromRGB));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::HSVfromRGB));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::HSVfromRGB>::value != 
		function_uuid<(base_type)&Base::HSVfromRGB>::value;
};


template <class, class, class, class = void>
struct RGBfromHSV {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct RGBfromHSV<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::RGBfromHSV)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::RGBfromHSV))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::RGBfromHSV));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::RGBfromHSV));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::RGBfromHSV>::value != 
		function_uuid<(base_type)&Base::RGBfromHSV>::value;
};


template <class, class, class, class = void>
struct getPreferredSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPreferredSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPreferredSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreferredSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPreferredSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPreferredSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPreferredSize>::value != 
		function_uuid<(base_type)&Base::getPreferredSize>::value;
};


template <class, class, class, class = void>
struct setPreferredSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPreferredSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPreferredSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPreferredSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPreferredSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPreferredSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPreferredSize>::value != 
		function_uuid<(base_type)&Base::setPreferredSize>::value;
};


template <class, class, class, class = void>
struct getCapInsets {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCapInsets<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCapInsets)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapInsets))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCapInsets));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapInsets));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCapInsets>::value != 
		function_uuid<(base_type)&Base::getCapInsets>::value;
};


template <class, class, class, class = void>
struct setCapInsets {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setCapInsets<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCapInsets)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCapInsets))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setCapInsets));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setCapInsets));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setCapInsets>::value != 
		function_uuid<(base_type)&Base::setCapInsets>::value;
};


template <class, class, class, class = void>
struct getInsetLeft {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getInsetLeft<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetLeft)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetLeft))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetLeft));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetLeft));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getInsetLeft>::value != 
		function_uuid<(base_type)&Base::getInsetLeft>::value;
};


template <class, class, class, class = void>
struct setInsetLeft {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setInsetLeft<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetLeft)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetLeft))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetLeft));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetLeft));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setInsetLeft>::value != 
		function_uuid<(base_type)&Base::setInsetLeft>::value;
};


template <class, class, class, class = void>
struct getInsetTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getInsetTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getInsetTop>::value != 
		function_uuid<(base_type)&Base::getInsetTop>::value;
};


template <class, class, class, class = void>
struct setInsetTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setInsetTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setInsetTop>::value != 
		function_uuid<(base_type)&Base::setInsetTop>::value;
};


template <class, class, class, class = void>
struct getInsetRight {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getInsetRight<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetRight)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetRight))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetRight));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetRight));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getInsetRight>::value != 
		function_uuid<(base_type)&Base::getInsetRight>::value;
};


template <class, class, class, class = void>
struct setInsetRight {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setInsetRight<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetRight)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetRight))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetRight));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetRight));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setInsetRight>::value != 
		function_uuid<(base_type)&Base::setInsetRight>::value;
};


template <class, class, class, class = void>
struct getInsetBottom {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getInsetBottom<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetBottom)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetBottom))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getInsetBottom));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getInsetBottom));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getInsetBottom>::value != 
		function_uuid<(base_type)&Base::getInsetBottom>::value;
};


template <class, class, class, class = void>
struct setInsetBottom {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setInsetBottom<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetBottom)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetBottom))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setInsetBottom));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setInsetBottom));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setInsetBottom>::value != 
		function_uuid<(base_type)&Base::setInsetBottom>::value;
};


template <class, class, class, class = void>
struct initWithBatchNode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct initWithBatchNode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithBatchNode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithBatchNode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::initWithBatchNode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::initWithBatchNode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::initWithBatchNode>::value != 
		function_uuid<(base_type)&Base::initWithBatchNode>::value;
};


template <class, class, class, class = void>
struct updateWithBatchNode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateWithBatchNode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateWithBatchNode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWithBatchNode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateWithBatchNode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateWithBatchNode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateWithBatchNode>::value != 
		function_uuid<(base_type)&Base::updateWithBatchNode>::value;
};


template <class, class, class, class = void>
struct setSpriteFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSpriteFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSpriteFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSpriteFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSpriteFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSpriteFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSpriteFrame>::value != 
		function_uuid<(base_type)&Base::setSpriteFrame>::value;
};


template <class, class, class, class = void>
struct ccGLBlendFunc {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccGLBlendFunc<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccGLBlendFunc)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccGLBlendFunc))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccGLBlendFunc));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccGLBlendFunc));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccGLBlendFunc>::value != 
		function_uuid<(base_type)&Base::ccGLBlendFunc>::value;
};


template <class, class, class, class = void>
struct ccDrawSolidRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ccDrawSolidRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccDrawSolidRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccDrawSolidRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ccDrawSolidRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ccDrawSolidRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ccDrawSolidRect>::value != 
		function_uuid<(base_type)&Base::ccDrawSolidRect>::value;
};


template <class, class, class, class = void>
struct doUnlink {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct doUnlink<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doUnlink)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doUnlink))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doUnlink));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doUnlink));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::doUnlink>::value != 
		function_uuid<(base_type)&Base::doUnlink>::value;
};


template <class, class, class, class = void>
struct onAccountManagement {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onAccountManagement<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onAccountManagement)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAccountManagement))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onAccountManagement));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAccountManagement));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onAccountManagement>::value != 
		function_uuid<(base_type)&Base::onAccountManagement>::value;
};


template <class, class, class, class = void>
struct onReLogin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onReLogin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onReLogin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onReLogin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onReLogin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onReLogin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onReLogin>::value != 
		function_uuid<(base_type)&Base::onReLogin>::value;
};


template <class, class, class, class = void>
struct onUnlink {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onUnlink<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onUnlink)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUnlink))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onUnlink));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUnlink));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onUnlink>::value != 
		function_uuid<(base_type)&Base::onUnlink>::value;
};


template <class, class, class, class = void>
struct updatePage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePage>::value != 
		function_uuid<(base_type)&Base::updatePage>::value;
};


template <class, class, class, class = void>
struct verifyUnlink {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct verifyUnlink<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::verifyUnlink)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::verifyUnlink))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::verifyUnlink));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::verifyUnlink));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::verifyUnlink>::value != 
		function_uuid<(base_type)&Base::verifyUnlink>::value;
};


template <class, class, class, class = void>
struct FLAlert_Clicked {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct FLAlert_Clicked<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::FLAlert_Clicked)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::FLAlert_Clicked))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::FLAlert_Clicked));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::FLAlert_Clicked));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::FLAlert_Clicked>::value != 
		function_uuid<(base_type)&Base::FLAlert_Clicked>::value;
};


template <class, class, class, class = void>
struct accountStatusChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct accountStatusChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::accountStatusChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::accountStatusChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::accountStatusChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::accountStatusChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::accountStatusChanged>::value != 
		function_uuid<(base_type)&Base::accountStatusChanged>::value;
};


template <class, class, class, class = void>
struct doBackup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct doBackup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doBackup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doBackup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doBackup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doBackup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::doBackup>::value != 
		function_uuid<(base_type)&Base::doBackup>::value;
};


template <class, class, class, class = void>
struct doSync {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct doSync<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doSync)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doSync))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doSync));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doSync));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::doSync>::value != 
		function_uuid<(base_type)&Base::doSync>::value;
};


template <class, class, class, class = void>
struct hideLoadingUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hideLoadingUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideLoadingUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLoadingUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideLoadingUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideLoadingUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hideLoadingUI>::value != 
		function_uuid<(base_type)&Base::hideLoadingUI>::value;
};


template <class, class, class, class = void>
struct onBackup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBackup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBackup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBackup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBackup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBackup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBackup>::value != 
		function_uuid<(base_type)&Base::onBackup>::value;
};


template <class, class, class, class = void>
struct onHelp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onHelp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onHelp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onHelp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onHelp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onHelp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onHelp>::value != 
		function_uuid<(base_type)&Base::onHelp>::value;
};


template <class, class, class, class = void>
struct onLogin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onLogin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onLogin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLogin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onLogin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onLogin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onLogin>::value != 
		function_uuid<(base_type)&Base::onLogin>::value;
};


template <class, class, class, class = void>
struct onRegister {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onRegister<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRegister)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRegister))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRegister));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRegister));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onRegister>::value != 
		function_uuid<(base_type)&Base::onRegister>::value;
};


template <class, class, class, class = void>
struct onSync {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSync<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSync)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSync))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSync));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSync));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSync>::value != 
		function_uuid<(base_type)&Base::onSync>::value;
};


template <class, class, class, class = void>
struct showLoadingUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showLoadingUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showLoadingUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLoadingUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showLoadingUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showLoadingUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showLoadingUI>::value != 
		function_uuid<(base_type)&Base::showLoadingUI>::value;
};


template <class, class, class, class = void>
struct toggleUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleUI>::value != 
		function_uuid<(base_type)&Base::toggleUI>::value;
};


template <class, class, class, class = void>
struct backupAccountFailed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFailed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::backupAccountFailed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFailed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::backupAccountFailed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFailed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::backupAccountFailed>::value != 
		function_uuid<(base_type)&Base::backupAccountFailed>::value;
};


template <class, class, class, class = void>
struct backupAccountFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct backupAccountFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::backupAccountFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::backupAccountFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::backupAccountFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::backupAccountFinished>::value != 
		function_uuid<(base_type)&Base::backupAccountFinished>::value;
};


template <class, class, class, class = void>
struct syncAccountFailed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFailed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::syncAccountFailed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFailed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::syncAccountFailed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFailed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::syncAccountFailed>::value != 
		function_uuid<(base_type)&Base::syncAccountFailed>::value;
};


template <class, class, class, class = void>
struct syncAccountFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct syncAccountFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::syncAccountFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::syncAccountFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::syncAccountFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::syncAccountFinished>::value != 
		function_uuid<(base_type)&Base::syncAccountFinished>::value;
};


template <class, class, class, class = void>
struct loadFromDict {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFromDict<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromDict)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromDict))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromDict));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromDict));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFromDict>::value != 
		function_uuid<(base_type)&Base::loadFromDict>::value;
};


template <class, class, class, class = void>
struct getAllAchievements {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAllAchievements<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllAchievements)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllAchievements))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllAchievements));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllAchievements));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAllAchievements>::value != 
		function_uuid<(base_type)&Base::getAllAchievements>::value;
};


template <class, class, class, class = void>
struct notifyAchievement {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct notifyAchievement<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::notifyAchievement)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::notifyAchievement))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::notifyAchievement));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::notifyAchievement));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::notifyAchievement>::value != 
		function_uuid<(base_type)&Base::notifyAchievement>::value;
};


template <class, class, class, class = void>
struct willSwitchToScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willSwitchToScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willSwitchToScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::willSwitchToScene>::value != 
		function_uuid<(base_type)&Base::willSwitchToScene>::value;
};


template <class, class, class, class = void>
struct showNextAchievement {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showNextAchievement<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showNextAchievement)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNextAchievement))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showNextAchievement));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNextAchievement));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showNextAchievement>::value != 
		function_uuid<(base_type)&Base::showNextAchievement>::value;
};


template <class, class, class, class = void>
struct hideCursor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hideCursor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideCursor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideCursor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideCursor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideCursor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hideCursor>::value != 
		function_uuid<(base_type)&Base::hideCursor>::value;
};


template <class, class, class, class = void>
struct showCursor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showCursor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCursor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCursor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCursor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCursor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showCursor>::value != 
		function_uuid<(base_type)&Base::showCursor>::value;
};


template <class, class, class, class = void>
struct isControllerConnected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isControllerConnected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isControllerConnected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isControllerConnected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isControllerConnected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isControllerConnected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isControllerConnected>::value != 
		function_uuid<(base_type)&Base::isControllerConnected>::value;
};


template <class, class, class, class = void>
struct playAnimation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playAnimation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playAnimation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playAnimation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playAnimation>::value != 
		function_uuid<(base_type)&Base::playAnimation>::value;
};


template <class, class, class, class = void>
struct updateChildSpriteColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateChildSpriteColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateChildSpriteColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateChildSpriteColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateChildSpriteColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateChildSpriteColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateChildSpriteColor>::value != 
		function_uuid<(base_type)&Base::updateChildSpriteColor>::value;
};


template <class, class, class, class = void>
struct startAnimating {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startAnimating<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startAnimating)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startAnimating))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startAnimating));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startAnimating));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startAnimating>::value != 
		function_uuid<(base_type)&Base::startAnimating>::value;
};


template <class, class, class, class = void>
struct bgScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct bgScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::bgScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bgScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::bgScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::bgScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::bgScale>::value != 
		function_uuid<(base_type)&Base::bgScale>::value;
};


template <class, class, class, class = void>
struct applicationDidFinishLaunching {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidFinishLaunching<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationDidFinishLaunching)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidFinishLaunching))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationDidFinishLaunching));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidFinishLaunching));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applicationDidFinishLaunching>::value != 
		function_uuid<(base_type)&Base::applicationDidFinishLaunching>::value;
};


template <class, class, class, class = void>
struct applicationDidEnterBackground {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applicationDidEnterBackground<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationDidEnterBackground)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidEnterBackground))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationDidEnterBackground));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationDidEnterBackground));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applicationDidEnterBackground>::value != 
		function_uuid<(base_type)&Base::applicationDidEnterBackground>::value;
};


template <class, class, class, class = void>
struct applicationWillEnterForeground {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillEnterForeground<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillEnterForeground)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillEnterForeground))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillEnterForeground));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillEnterForeground));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applicationWillEnterForeground>::value != 
		function_uuid<(base_type)&Base::applicationWillEnterForeground>::value;
};


template <class, class, class, class = void>
struct applicationWillBecomeActive {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillBecomeActive<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillBecomeActive)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillBecomeActive))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillBecomeActive));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillBecomeActive));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applicationWillBecomeActive>::value != 
		function_uuid<(base_type)&Base::applicationWillBecomeActive>::value;
};


template <class, class, class, class = void>
struct applicationWillResignActive {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applicationWillResignActive<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillResignActive)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillResignActive))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applicationWillResignActive));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applicationWillResignActive));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applicationWillResignActive>::value != 
		function_uuid<(base_type)&Base::applicationWillResignActive>::value;
};


template <class, class, class, class = void>
struct trySaveGame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct trySaveGame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::trySaveGame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::trySaveGame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::trySaveGame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::trySaveGame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::trySaveGame>::value != 
		function_uuid<(base_type)&Base::trySaveGame>::value;
};


template <class, class, class, class = void>
struct get {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct get<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::get)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::get))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::get));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::get));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::get>::value != 
		function_uuid<(base_type)&Base::get>::value;
};


template <class, class, class, class = void>
struct audioStep {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct audioStep<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::audioStep)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::audioStep))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::audioStep));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::audioStep));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::audioStep>::value != 
		function_uuid<(base_type)&Base::audioStep>::value;
};


template <class, class, class, class = void>
struct resetAudioVars {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetAudioVars<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetAudioVars)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAudioVars))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetAudioVars));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetAudioVars));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetAudioVars>::value != 
		function_uuid<(base_type)&Base::resetAudioVars>::value;
};


template <class, class, class, class = void>
struct googlePlaySignedIn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct googlePlaySignedIn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::googlePlaySignedIn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::googlePlaySignedIn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::googlePlaySignedIn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::googlePlaySignedIn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::googlePlaySignedIn>::value != 
		function_uuid<(base_type)&Base::googlePlaySignedIn>::value;
};


template <class, class, class, class = void>
struct onMoreGames {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onMoreGames<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMoreGames)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMoreGames))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMoreGames));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMoreGames));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onMoreGames>::value != 
		function_uuid<(base_type)&Base::onMoreGames>::value;
};


template <class, class, class, class = void>
struct onGarage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGarage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGarage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGarage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGarage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGarage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGarage>::value != 
		function_uuid<(base_type)&Base::onGarage>::value;
};


template <class, class, class, class = void>
struct onQuit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onQuit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onQuit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onQuit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onQuit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onQuit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onQuit>::value != 
		function_uuid<(base_type)&Base::onQuit>::value;
};


template <class, class, class, class = void>
struct onMyProfile {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onMyProfile<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMyProfile)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyProfile))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onMyProfile));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onMyProfile));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onMyProfile>::value != 
		function_uuid<(base_type)&Base::onMyProfile>::value;
};


template <class, class, class, class = void>
struct onPlay {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlay<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlay)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlay))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlay));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlay));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlay>::value != 
		function_uuid<(base_type)&Base::onPlay>::value;
};


template <class, class, class, class = void>
struct onCreator {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onCreator<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCreator)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreator))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCreator));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreator));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onCreator>::value != 
		function_uuid<(base_type)&Base::onCreator>::value;
};


template <class, class, class, class = void>
struct onRobTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onRobTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRobTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRobTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onRobTop>::value != 
		function_uuid<(base_type)&Base::onRobTop>::value;
};


template <class, class, class, class = void>
struct onDaily {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDaily<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDaily)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDaily))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDaily));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDaily));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDaily>::value != 
		function_uuid<(base_type)&Base::onDaily>::value;
};


template <class, class, class, class = void>
struct onOptions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onOptions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onOptions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onOptions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onOptions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onOptions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onOptions>::value != 
		function_uuid<(base_type)&Base::onOptions>::value;
};


template <class, class, class, class = void>
struct onAchievements {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onAchievements<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onAchievements)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAchievements))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onAchievements));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onAchievements));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onAchievements>::value != 
		function_uuid<(base_type)&Base::onAchievements>::value;
};


template <class, class, class, class = void>
struct onStats {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onStats<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStats)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStats))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStats));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStats));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onStats>::value != 
		function_uuid<(base_type)&Base::onStats>::value;
};


template <class, class, class, class = void>
struct onFacebook {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onFacebook<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onFacebook)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onFacebook))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onFacebook));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onFacebook));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onFacebook>::value != 
		function_uuid<(base_type)&Base::onFacebook>::value;
};


template <class, class, class, class = void>
struct onTwitter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onTwitter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTwitter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTwitter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTwitter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTwitter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onTwitter>::value != 
		function_uuid<(base_type)&Base::onTwitter>::value;
};


template <class, class, class, class = void>
struct onYouTube {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onYouTube<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onYouTube)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onYouTube))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onYouTube));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onYouTube));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onYouTube>::value != 
		function_uuid<(base_type)&Base::onYouTube>::value;
};


template <class, class, class, class = void>
struct scene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scene>::value != 
		function_uuid<(base_type)&Base::scene>::value;
};


template <class, class, class, class = void>
struct node {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct node<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::node)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::node))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::node));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::node));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::node>::value != 
		function_uuid<(base_type)&Base::node>::value;
};


template <class, class, class, class = void>
struct setupList {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupList<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupList)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupList))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupList));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupList));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupList>::value != 
		function_uuid<(base_type)&Base::setupList>::value;
};


template <class, class, class, class = void>
struct TableViewWillDisplayCellForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillDisplayCellForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewWillDisplayCellForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillDisplayCellForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewWillDisplayCellForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillDisplayCellForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::TableViewWillDisplayCellForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::TableViewWillDisplayCellForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct cellHeightForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct cellHeightForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cellHeightForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellHeightForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cellHeightForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellHeightForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::cellHeightForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::cellHeightForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct didSelectRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct didSelectRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didSelectRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didSelectRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didSelectRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didSelectRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::didSelectRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::didSelectRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct numberOfRowsInSection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct numberOfRowsInSection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::numberOfRowsInSection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfRowsInSection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::numberOfRowsInSection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfRowsInSection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::numberOfRowsInSection>::value != 
		function_uuid<(base_type)&Base::numberOfRowsInSection>::value;
};


template <class, class, class, class = void>
struct numberOfSectionsInTableView {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct numberOfSectionsInTableView<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::numberOfSectionsInTableView)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfSectionsInTableView))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::numberOfSectionsInTableView));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::numberOfSectionsInTableView));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::numberOfSectionsInTableView>::value != 
		function_uuid<(base_type)&Base::numberOfSectionsInTableView>::value;
};


template <class, class, class, class = void>
struct cellForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct cellForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cellForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cellForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cellForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::cellForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::cellForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct TableViewCommitCellEditingStyleForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct TableViewCommitCellEditingStyleForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewCommitCellEditingStyleForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewCommitCellEditingStyleForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewCommitCellEditingStyleForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewCommitCellEditingStyleForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::TableViewCommitCellEditingStyleForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::TableViewCommitCellEditingStyleForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct TableViewWillReloadCellForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct TableViewWillReloadCellForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewWillReloadCellForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillReloadCellForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewWillReloadCellForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewWillReloadCellForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::TableViewWillReloadCellForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::TableViewWillReloadCellForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct getListCell {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getListCell<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getListCell)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getListCell))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getListCell));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getListCell));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getListCell>::value != 
		function_uuid<(base_type)&Base::getListCell>::value;
};


template <class, class, class, class = void>
struct loadCell {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadCell<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadCell)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadCell))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadCell));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadCell));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadCell>::value != 
		function_uuid<(base_type)&Base::loadCell>::value;
};


template <class, class, class, class = void>
struct instantMoveToPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct instantMoveToPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::instantMoveToPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::instantMoveToPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::instantMoveToPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::instantMoveToPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::instantMoveToPage>::value != 
		function_uuid<(base_type)&Base::instantMoveToPage>::value;
};


template <class, class, class, class = void>
struct moveToPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveToPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveToPage>::value != 
		function_uuid<(base_type)&Base::moveToPage>::value;
};


template <class, class, class, class = void>
struct updateBGImage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBGImage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGImage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGImage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGImage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGImage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBGImage>::value != 
		function_uuid<(base_type)&Base::updateBGImage>::value;
};


template <class, class, class, class = void>
struct updateSpriteBGSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSpriteBGSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpriteBGSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpriteBGSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpriteBGSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpriteBGSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSpriteBGSize>::value != 
		function_uuid<(base_type)&Base::updateSpriteBGSize>::value;
};


template <class, class, class, class = void>
struct runAnimation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runAnimation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runAnimation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAnimation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runAnimation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runAnimation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runAnimation>::value != 
		function_uuid<(base_type)&Base::runAnimation>::value;
};


template <class, class, class, class = void>
struct tweenToAnimation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct tweenToAnimation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tweenToAnimation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tweenToAnimation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tweenToAnimation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tweenToAnimation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::tweenToAnimation>::value != 
		function_uuid<(base_type)&Base::tweenToAnimation>::value;
};


template <class, class, class, class = void>
struct followObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct followObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::followObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::followObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::followObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::followObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::followObject>::value != 
		function_uuid<(base_type)&Base::followObject>::value;
};


template <class, class, class, class = void>
struct updatePosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePosition>::value != 
		function_uuid<(base_type)&Base::updatePosition>::value;
};


template <class, class, class, class = void>
struct colorAllCharactersTo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorAllCharactersTo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorAllCharactersTo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorAllCharactersTo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorAllCharactersTo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorAllCharactersTo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorAllCharactersTo>::value != 
		function_uuid<(base_type)&Base::colorAllCharactersTo>::value;
};


template <class, class, class, class = void>
struct transformColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct transformColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transformColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transformColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::transformColor>::value != 
		function_uuid<(base_type)&Base::transformColor>::value;
};


template <class, class, class, class = void>
struct alignItemsHorisontally {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct alignItemsHorisontally<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsHorisontally)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorisontally))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignItemsHorisontally));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignItemsHorisontally));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::alignItemsHorisontally>::value != 
		function_uuid<(base_type)&Base::alignItemsHorisontally>::value;
};


template <class, class, class, class = void>
struct getMinY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMinY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMinY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMinY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMinY>::value != 
		function_uuid<(base_type)&Base::getMinY>::value;
};


template <class, class, class, class = void>
struct getMaxY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMaxY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMaxY>::value != 
		function_uuid<(base_type)&Base::getMaxY>::value;
};


template <class, class, class, class = void>
struct preVisitWithClippingRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct preVisitWithClippingRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preVisitWithClippingRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preVisitWithClippingRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preVisitWithClippingRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preVisitWithClippingRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::preVisitWithClippingRect>::value != 
		function_uuid<(base_type)&Base::preVisitWithClippingRect>::value;
};


template <class, class, class, class = void>
struct postVisit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct postVisit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postVisit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postVisit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postVisit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postVisit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::postVisit>::value != 
		function_uuid<(base_type)&Base::postVisit>::value;
};


template <class, class, class, class = void>
struct moveToTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveToTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveToTop>::value != 
		function_uuid<(base_type)&Base::moveToTop>::value;
};


template <class, class, class, class = void>
struct moveToTopWithOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveToTopWithOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToTopWithOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTopWithOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveToTopWithOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveToTopWithOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveToTopWithOffset>::value != 
		function_uuid<(base_type)&Base::moveToTopWithOffset>::value;
};


template <class, class, class, class = void>
struct scrollLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollLayer>::value != 
		function_uuid<(base_type)&Base::scrollLayer>::value;
};


template <class, class, class, class = void>
struct scrllViewWillBeginDecelerating {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrllViewWillBeginDecelerating<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrllViewWillBeginDecelerating)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrllViewWillBeginDecelerating))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrllViewWillBeginDecelerating));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrllViewWillBeginDecelerating));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrllViewWillBeginDecelerating>::value != 
		function_uuid<(base_type)&Base::scrllViewWillBeginDecelerating>::value;
};


template <class, class, class, class = void>
struct scrollViewDidEndDecelerating {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndDecelerating<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewDidEndDecelerating)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndDecelerating))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewDidEndDecelerating));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndDecelerating));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollViewDidEndDecelerating>::value != 
		function_uuid<(base_type)&Base::scrollViewDidEndDecelerating>::value;
};


template <class, class, class, class = void>
struct scrollViewTouchMoving {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchMoving<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchMoving)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchMoving))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchMoving));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchMoving));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollViewTouchMoving>::value != 
		function_uuid<(base_type)&Base::scrollViewTouchMoving>::value;
};


template <class, class, class, class = void>
struct scrollViewDidEndMoving {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewDidEndMoving<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewDidEndMoving)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndMoving))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewDidEndMoving));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewDidEndMoving));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollViewDidEndMoving>::value != 
		function_uuid<(base_type)&Base::scrollViewDidEndMoving>::value;
};


template <class, class, class, class = void>
struct scrollViewTouchBegin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchBegin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchBegin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchBegin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchBegin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchBegin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollViewTouchBegin>::value != 
		function_uuid<(base_type)&Base::scrollViewTouchBegin>::value;
};


template <class, class, class, class = void>
struct scrollViewTouchEnd {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scrollViewTouchEnd<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchEnd)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchEnd))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scrollViewTouchEnd));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scrollViewTouchEnd));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scrollViewTouchEnd>::value != 
		function_uuid<(base_type)&Base::scrollViewTouchEnd>::value;
};


template <class, class, class, class = void>
struct textForColorIdx {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textForColorIdx<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textForColorIdx)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textForColorIdx))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textForColorIdx));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textForColorIdx));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textForColorIdx>::value != 
		function_uuid<(base_type)&Base::textForColorIdx>::value;
};


template <class, class, class, class = void>
struct setLabelNormalColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setLabelNormalColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelNormalColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelNormalColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelNormalColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelNormalColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setLabelNormalColor>::value != 
		function_uuid<(base_type)&Base::setLabelNormalColor>::value;
};


template <class, class, class, class = void>
struct setLabelPlaceholderColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelPlaceholderColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelPlaceholderColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setLabelPlaceholderColor>::value != 
		function_uuid<(base_type)&Base::setLabelPlaceholderColor>::value;
};


template <class, class, class, class = void>
struct setLabelPlaceholderScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setLabelPlaceholderScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelPlaceholderScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLabelPlaceholderScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLabelPlaceholderScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setLabelPlaceholderScale>::value != 
		function_uuid<(base_type)&Base::setLabelPlaceholderScale>::value;
};


template <class, class, class, class = void>
struct setMaxLabelScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxLabelScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxLabelScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMaxLabelScale>::value != 
		function_uuid<(base_type)&Base::setMaxLabelScale>::value;
};


template <class, class, class, class = void>
struct setMaxLabelWidth {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMaxLabelWidth<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxLabelWidth)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelWidth))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMaxLabelWidth));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMaxLabelWidth));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMaxLabelWidth>::value != 
		function_uuid<(base_type)&Base::setMaxLabelWidth>::value;
};


template <class, class, class, class = void>
struct setAllowedChars {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAllowedChars<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAllowedChars)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAllowedChars))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAllowedChars));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAllowedChars));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAllowedChars>::value != 
		function_uuid<(base_type)&Base::setAllowedChars>::value;
};


template <class, class, class, class = void>
struct forceOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct forceOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::forceOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::forceOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::forceOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::forceOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::forceOffset>::value != 
		function_uuid<(base_type)&Base::forceOffset>::value;
};


template <class, class, class, class = void>
struct getString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getString>::value != 
		function_uuid<(base_type)&Base::getString>::value;
};


template <class, class, class, class = void>
struct getTextField {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTextField<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTextField)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTextField))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTextField));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTextField));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTextField>::value != 
		function_uuid<(base_type)&Base::getTextField>::value;
};


template <class, class, class, class = void>
struct getPlaceholderLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlaceholderLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlaceholderLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlaceholderLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlaceholderLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlaceholderLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlaceholderLabel>::value != 
		function_uuid<(base_type)&Base::getPlaceholderLabel>::value;
};


template <class, class, class, class = void>
struct setDelegate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDelegate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDelegate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDelegate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDelegate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDelegate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDelegate>::value != 
		function_uuid<(base_type)&Base::setDelegate>::value;
};


template <class, class, class, class = void>
struct refreshLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct refreshLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::refreshLabel>::value != 
		function_uuid<(base_type)&Base::refreshLabel>::value;
};


template <class, class, class, class = void>
struct updateLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateLabel>::value != 
		function_uuid<(base_type)&Base::updateLabel>::value;
};


template <class, class, class, class = void>
struct onClickTrackNode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onClickTrackNode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onClickTrackNode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClickTrackNode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onClickTrackNode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onClickTrackNode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onClickTrackNode>::value != 
		function_uuid<(base_type)&Base::onClickTrackNode>::value;
};


template <class, class, class, class = void>
struct keyboardWillShow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillShow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyboardWillShow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillShow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyboardWillShow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillShow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyboardWillShow>::value != 
		function_uuid<(base_type)&Base::keyboardWillShow>::value;
};


template <class, class, class, class = void>
struct keyboardWillHide {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyboardWillHide<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyboardWillHide)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillHide))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyboardWillHide));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyboardWillHide));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyboardWillHide>::value != 
		function_uuid<(base_type)&Base::keyboardWillHide>::value;
};


template <class, class, class, class = void>
struct onTextFieldInsertText {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldInsertText<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldInsertText)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldInsertText))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldInsertText));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldInsertText));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onTextFieldInsertText>::value != 
		function_uuid<(base_type)&Base::onTextFieldInsertText>::value;
};


template <class, class, class, class = void>
struct onTextFieldAttachWithIME {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldAttachWithIME<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldAttachWithIME)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldAttachWithIME))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldAttachWithIME));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldAttachWithIME));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onTextFieldAttachWithIME>::value != 
		function_uuid<(base_type)&Base::onTextFieldAttachWithIME>::value;
};


template <class, class, class, class = void>
struct onTextFieldDetachWithIME {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onTextFieldDetachWithIME<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldDetachWithIME)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldDetachWithIME))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onTextFieldDetachWithIME));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onTextFieldDetachWithIME));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onTextFieldDetachWithIME>::value != 
		function_uuid<(base_type)&Base::onTextFieldDetachWithIME>::value;
};


template <class, class, class, class = void>
struct calculateWithCenter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateWithCenter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateWithCenter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateWithCenter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateWithCenter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateWithCenter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateWithCenter>::value != 
		function_uuid<(base_type)&Base::calculateWithCenter>::value;
};


template <class, class, class, class = void>
struct getBoundingRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBoundingRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBoundingRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoundingRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBoundingRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoundingRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBoundingRect>::value != 
		function_uuid<(base_type)&Base::getBoundingRect>::value;
};


template <class, class, class, class = void>
struct overlaps {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct overlaps<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::overlaps)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::overlaps));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::overlaps>::value != 
		function_uuid<(base_type)&Base::overlaps>::value;
};


template <class, class, class, class = void>
struct overlaps1Way {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct overlaps1Way<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::overlaps1Way)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps1Way))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::overlaps1Way));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::overlaps1Way));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::overlaps1Way>::value != 
		function_uuid<(base_type)&Base::overlaps1Way>::value;
};


template <class, class, class, class = void>
struct getObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObject>::value != 
		function_uuid<(base_type)&Base::getObject>::value;
};


template <class, class, class, class = void>
struct onNextItemID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onNextItemID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextItemID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextItemID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextItemID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextItemID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onNextItemID>::value != 
		function_uuid<(base_type)&Base::onNextItemID>::value;
};


template <class, class, class, class = void>
struct getSaveString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSaveString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSaveString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSaveString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSaveString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSaveString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSaveString>::value != 
		function_uuid<(base_type)&Base::getSaveString>::value;
};


template <class, class, class, class = void>
struct setupFromDict {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupFromDict<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupFromDict)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromDict))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupFromDict));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromDict));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupFromDict>::value != 
		function_uuid<(base_type)&Base::setupFromDict>::value;
};


template <class, class, class, class = void>
struct setupFromString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupFromString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupFromString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupFromString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupFromString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupFromString>::value != 
		function_uuid<(base_type)&Base::setupFromString>::value;
};


template <class, class, class, class = void>
struct colorValueChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorValueChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorValueChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorValueChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorValueChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorValueChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorValueChanged>::value != 
		function_uuid<(base_type)&Base::colorValueChanged>::value;
};


template <class, class, class, class = void>
struct onStop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onStop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onStop>::value != 
		function_uuid<(base_type)&Base::onStop>::value;
};


template <class, class, class, class = void>
struct createWithObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithObjects>::value != 
		function_uuid<(base_type)&Base::createWithObjects>::value;
};


template <class, class, class, class = void>
struct createDialogLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createDialogLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createDialogLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createDialogLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createDialogLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createDialogLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createDialogLayer>::value != 
		function_uuid<(base_type)&Base::createDialogLayer>::value;
};


template <class, class, class, class = void>
struct animateIn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animateIn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateIn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateIn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateIn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateIn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animateIn>::value != 
		function_uuid<(base_type)&Base::animateIn>::value;
};


template <class, class, class, class = void>
struct fadeInTextFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fadeInTextFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeInTextFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInTextFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeInTextFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInTextFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fadeInTextFinished>::value != 
		function_uuid<(base_type)&Base::fadeInTextFinished>::value;
};


template <class, class, class, class = void>
struct dialogClosed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct dialogClosed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dialogClosed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dialogClosed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dialogClosed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dialogClosed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::dialogClosed>::value != 
		function_uuid<(base_type)&Base::dialogClosed>::value;
};


template <class, class, class, class = void>
struct currencyWillExit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct currencyWillExit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::currencyWillExit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::currencyWillExit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::currencyWillExit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::currencyWillExit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::currencyWillExit>::value != 
		function_uuid<(base_type)&Base::currencyWillExit>::value;
};


template <class, class, class, class = void>
struct loadSongInfoFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadSongInfoFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadSongInfoFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSongInfoFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadSongInfoFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSongInfoFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadSongInfoFinished>::value != 
		function_uuid<(base_type)&Base::loadSongInfoFinished>::value;
};


template <class, class, class, class = void>
struct updateSongObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSongObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSongObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSongObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSongObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSongObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSongObject>::value != 
		function_uuid<(base_type)&Base::updateSongObject>::value;
};


template <class, class, class, class = void>
struct onNextColorChannel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onNextColorChannel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextColorChannel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextColorChannel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextColorChannel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextColorChannel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onNextColorChannel>::value != 
		function_uuid<(base_type)&Base::onNextColorChannel>::value;
};


template <class, class, class, class = void>
struct onSelectColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSelectColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSelectColor>::value != 
		function_uuid<(base_type)&Base::onSelectColor>::value;
};


template <class, class, class, class = void>
struct removeAllItems {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllItems<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllItems)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllItems))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllItems));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllItems));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllItems>::value != 
		function_uuid<(base_type)&Base::removeAllItems>::value;
};


template <class, class, class, class = void>
struct reloadItems {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadItems<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadItems)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItems))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadItems));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItems));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadItems>::value != 
		function_uuid<(base_type)&Base::reloadItems>::value;
};


template <class, class, class, class = void>
struct reloadItemsInNormalSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadItemsInNormalSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadItemsInNormalSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItemsInNormalSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadItemsInNormalSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadItemsInNormalSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadItemsInNormalSize>::value != 
		function_uuid<(base_type)&Base::reloadItemsInNormalSize>::value;
};


template <class, class, class, class = void>
struct addButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addButton>::value != 
		function_uuid<(base_type)&Base::addButton>::value;
};


template <class, class, class, class = void>
struct loadFromItems {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFromItems<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromItems)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromItems))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFromItems));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFromItems));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFromItems>::value != 
		function_uuid<(base_type)&Base::loadFromItems>::value;
};


template <class, class, class, class = void>
struct saveLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveLevel>::value != 
		function_uuid<(base_type)&Base::saveLevel>::value;
};


template <class, class, class, class = void>
struct onExitEditor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onExitEditor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitEditor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitEditor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitEditor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitEditor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onExitEditor>::value != 
		function_uuid<(base_type)&Base::onExitEditor>::value;
};


template <class, class, class, class = void>
struct playStep2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playStep2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playStep2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playStep2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playStep2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playStep2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playStep2>::value != 
		function_uuid<(base_type)&Base::playStep2>::value;
};


template <class, class, class, class = void>
struct onResume {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onResume<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onResume)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onResume))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onResume));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onResume));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onResume>::value != 
		function_uuid<(base_type)&Base::onResume>::value;
};


template <class, class, class, class = void>
struct onSaveAndPlay {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndPlay<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSaveAndPlay)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndPlay))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSaveAndPlay));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndPlay));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSaveAndPlay>::value != 
		function_uuid<(base_type)&Base::onSaveAndPlay>::value;
};


template <class, class, class, class = void>
struct onSaveAndExit {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSaveAndExit<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSaveAndExit)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndExit))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSaveAndExit));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSaveAndExit));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSaveAndExit>::value != 
		function_uuid<(base_type)&Base::onSaveAndExit>::value;
};


template <class, class, class, class = void>
struct onSave {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSave<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSave)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSave))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSave));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSave));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSave>::value != 
		function_uuid<(base_type)&Base::onSave>::value;
};


template <class, class, class, class = void>
struct onExitNoSave {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onExitNoSave<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitNoSave)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitNoSave))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onExitNoSave));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onExitNoSave));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onExitNoSave>::value != 
		function_uuid<(base_type)&Base::onExitNoSave>::value;
};


template <class, class, class, class = void>
struct uncheckAllPortals {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct uncheckAllPortals<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::uncheckAllPortals)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::uncheckAllPortals))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::uncheckAllPortals));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::uncheckAllPortals));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::uncheckAllPortals>::value != 
		function_uuid<(base_type)&Base::uncheckAllPortals>::value;
};


template <class, class, class, class = void>
struct constrainGameLayerPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct constrainGameLayerPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::constrainGameLayerPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::constrainGameLayerPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::constrainGameLayerPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::constrainGameLayerPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::constrainGameLayerPosition>::value != 
		function_uuid<(base_type)&Base::constrainGameLayerPosition>::value;
};


template <class, class, class, class = void>
struct deselectAll {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct deselectAll<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deselectAll)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectAll))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deselectAll));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectAll));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::deselectAll>::value != 
		function_uuid<(base_type)&Base::deselectAll>::value;
};


template <class, class, class, class = void>
struct onDeselectAll {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDeselectAll<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeselectAll)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeselectAll))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeselectAll));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeselectAll));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDeselectAll>::value != 
		function_uuid<(base_type)&Base::onDeselectAll>::value;
};


template <class, class, class, class = void>
struct disableButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct disableButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::disableButton>::value != 
		function_uuid<(base_type)&Base::disableButton>::value;
};


template <class, class, class, class = void>
struct editButtonUsable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct editButtonUsable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editButtonUsable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editButtonUsable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editButtonUsable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editButtonUsable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::editButtonUsable>::value != 
		function_uuid<(base_type)&Base::editButtonUsable>::value;
};


template <class, class, class, class = void>
struct editObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct editObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::editObject>::value != 
		function_uuid<(base_type)&Base::editObject>::value;
};


template <class, class, class, class = void>
struct enableButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enableButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enableButton>::value != 
		function_uuid<(base_type)&Base::enableButton>::value;
};


template <class, class, class, class = void>
struct getCreateBtn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCreateBtn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCreateBtn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCreateBtn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCreateBtn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCreateBtn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCreateBtn>::value != 
		function_uuid<(base_type)&Base::getCreateBtn>::value;
};


template <class, class, class, class = void>
struct getGroupCenter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroupCenter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupCenter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupCenter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupCenter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupCenter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroupCenter>::value != 
		function_uuid<(base_type)&Base::getGroupCenter>::value;
};


template <class, class, class, class = void>
struct getSelectedObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSelectedObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSelectedObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSelectedObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSelectedObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSelectedObjects>::value != 
		function_uuid<(base_type)&Base::getSelectedObjects>::value;
};


template <class, class, class, class = void>
struct moveObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveObject>::value != 
		function_uuid<(base_type)&Base::moveObject>::value;
};


template <class, class, class, class = void>
struct onDuplicate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDuplicate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDuplicate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDuplicate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDuplicate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDuplicate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDuplicate>::value != 
		function_uuid<(base_type)&Base::onDuplicate>::value;
};


template <class, class, class, class = void>
struct pasteObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pasteObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pasteObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pasteObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pasteObjects>::value != 
		function_uuid<(base_type)&Base::pasteObjects>::value;
};


template <class, class, class, class = void>
struct playerTouchBegan {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchBegan<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTouchBegan)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchBegan))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTouchBegan));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchBegan));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerTouchBegan>::value != 
		function_uuid<(base_type)&Base::playerTouchBegan>::value;
};


template <class, class, class, class = void>
struct playtestStopped {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playtestStopped<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playtestStopped)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playtestStopped))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playtestStopped));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playtestStopped));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playtestStopped>::value != 
		function_uuid<(base_type)&Base::playtestStopped>::value;
};


template <class, class, class, class = void>
struct redoLastAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct redoLastAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::redoLastAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::redoLastAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::redoLastAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::redoLastAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::redoLastAction>::value != 
		function_uuid<(base_type)&Base::redoLastAction>::value;
};


template <class, class, class, class = void>
struct replaceGroupID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct replaceGroupID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::replaceGroupID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceGroupID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::replaceGroupID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::replaceGroupID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::replaceGroupID>::value != 
		function_uuid<(base_type)&Base::replaceGroupID>::value;
};


template <class, class, class, class = void>
struct scaleChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scaleChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scaleChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scaleChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scaleChanged>::value != 
		function_uuid<(base_type)&Base::scaleChanged>::value;
};


template <class, class, class, class = void>
struct scaleObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct scaleObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scaleObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::scaleObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::scaleObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::scaleObjects>::value != 
		function_uuid<(base_type)&Base::scaleObjects>::value;
};


template <class, class, class, class = void>
struct selectObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selectObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selectObjects>::value != 
		function_uuid<(base_type)&Base::selectObjects>::value;
};


template <class, class, class, class = void>
struct setupCreateMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupCreateMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCreateMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCreateMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCreateMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCreateMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupCreateMenu>::value != 
		function_uuid<(base_type)&Base::setupCreateMenu>::value;
};


template <class, class, class, class = void>
struct undoLastAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct undoLastAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::undoLastAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::undoLastAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::undoLastAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::undoLastAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::undoLastAction>::value != 
		function_uuid<(base_type)&Base::undoLastAction>::value;
};


template <class, class, class, class = void>
struct updateButtons {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateButtons<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateButtons)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateButtons))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateButtons));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateButtons));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateButtons>::value != 
		function_uuid<(base_type)&Base::updateButtons>::value;
};


template <class, class, class, class = void>
struct updateObjectInfoLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateObjectInfoLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateObjectInfoLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateObjectInfoLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateObjectInfoLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateObjectInfoLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateObjectInfoLabel>::value != 
		function_uuid<(base_type)&Base::updateObjectInfoLabel>::value;
};


template <class, class, class, class = void>
struct updateSlider {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSlider<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlider)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlider))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSlider));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSlider));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSlider>::value != 
		function_uuid<(base_type)&Base::updateSlider>::value;
};


template <class, class, class, class = void>
struct updateZoom {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateZoom<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateZoom)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZoom))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateZoom));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZoom));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateZoom>::value != 
		function_uuid<(base_type)&Base::updateZoom>::value;
};


template <class, class, class, class = void>
struct selectObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selectObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selectObject>::value != 
		function_uuid<(base_type)&Base::selectObject>::value;
};


template <class, class, class, class = void>
struct selectAll {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selectAll<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectAll)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAll))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectAll));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAll));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selectAll>::value != 
		function_uuid<(base_type)&Base::selectAll>::value;
};


template <class, class, class, class = void>
struct selectAllWithDirection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selectAllWithDirection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectAllWithDirection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAllWithDirection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectAllWithDirection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectAllWithDirection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selectAllWithDirection>::value != 
		function_uuid<(base_type)&Base::selectAllWithDirection>::value;
};


template <class, class, class, class = void>
struct getTouchPoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTouchPoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchPoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTouchPoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTouchPoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTouchPoint>::value != 
		function_uuid<(base_type)&Base::getTouchPoint>::value;
};


template <class, class, class, class = void>
struct onSelectBuildTab {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSelectBuildTab<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectBuildTab)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectBuildTab))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectBuildTab));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectBuildTab));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSelectBuildTab>::value != 
		function_uuid<(base_type)&Base::onSelectBuildTab>::value;
};


template <class, class, class, class = void>
struct onCreateButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onCreateButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCreateButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreateButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCreateButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCreateButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onCreateButton>::value != 
		function_uuid<(base_type)&Base::onCreateButton>::value;
};


template <class, class, class, class = void>
struct getSpriteButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSpriteButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSpriteButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSpriteButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSpriteButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSpriteButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSpriteButton>::value != 
		function_uuid<(base_type)&Base::getSpriteButton>::value;
};


template <class, class, class, class = void>
struct offsetForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct offsetForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::offsetForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::offsetForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::offsetForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::offsetForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::offsetForKey>::value != 
		function_uuid<(base_type)&Base::offsetForKey>::value;
};


template <class, class, class, class = void>
struct updateDeleteMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDeleteMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDeleteMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDeleteMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDeleteMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDeleteMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDeleteMenu>::value != 
		function_uuid<(base_type)&Base::updateDeleteMenu>::value;
};


template <class, class, class, class = void>
struct updateCreateMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCreateMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCreateMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCreateMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCreateMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCreateMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCreateMenu>::value != 
		function_uuid<(base_type)&Base::updateCreateMenu>::value;
};


template <class, class, class, class = void>
struct toggleMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleMode>::value != 
		function_uuid<(base_type)&Base::toggleMode>::value;
};


template <class, class, class, class = void>
struct zoomIn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct zoomIn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::zoomIn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomIn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::zoomIn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomIn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::zoomIn>::value != 
		function_uuid<(base_type)&Base::zoomIn>::value;
};


template <class, class, class, class = void>
struct zoomOut {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct zoomOut<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::zoomOut)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomOut))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::zoomOut));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::zoomOut));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::zoomOut>::value != 
		function_uuid<(base_type)&Base::zoomOut>::value;
};


template <class, class, class, class = void>
struct rotateObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct rotateObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rotateObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotateObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rotateObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotateObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::rotateObjects>::value != 
		function_uuid<(base_type)&Base::rotateObjects>::value;
};


template <class, class, class, class = void>
struct updateGridNodeSize {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGridNodeSize<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGridNodeSize)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGridNodeSize))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGridNodeSize));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGridNodeSize));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGridNodeSize>::value != 
		function_uuid<(base_type)&Base::updateGridNodeSize>::value;
};


template <class, class, class, class = void>
struct updateSpecialUIElements {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSpecialUIElements<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpecialUIElements)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecialUIElements))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpecialUIElements));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpecialUIElements));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSpecialUIElements>::value != 
		function_uuid<(base_type)&Base::updateSpecialUIElements>::value;
};


template <class, class, class, class = void>
struct moveGameLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveGameLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveGameLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveGameLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveGameLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveGameLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveGameLayer>::value != 
		function_uuid<(base_type)&Base::moveGameLayer>::value;
};


template <class, class, class, class = void>
struct showUI {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showUI<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showUI)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showUI))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showUI));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showUI));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showUI>::value != 
		function_uuid<(base_type)&Base::showUI>::value;
};


template <class, class, class, class = void>
struct editObject2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct editObject2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editObject2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editObject2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editObject2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::editObject2>::value != 
		function_uuid<(base_type)&Base::editObject2>::value;
};


template <class, class, class, class = void>
struct editGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct editGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::editGroup>::value != 
		function_uuid<(base_type)&Base::editGroup>::value;
};


template <class, class, class, class = void>
struct moveObjectCall {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveObjectCall<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveObjectCall)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObjectCall))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveObjectCall));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveObjectCall));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveObjectCall>::value != 
		function_uuid<(base_type)&Base::moveObjectCall>::value;
};


template <class, class, class, class = void>
struct transformObjectCall {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct transformObjectCall<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transformObjectCall)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformObjectCall))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transformObjectCall));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transformObjectCall));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::transformObjectCall>::value != 
		function_uuid<(base_type)&Base::transformObjectCall>::value;
};


template <class, class, class, class = void>
struct onDeleteSelected {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteSelected<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeleteSelected)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteSelected))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeleteSelected));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteSelected));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDeleteSelected>::value != 
		function_uuid<(base_type)&Base::onDeleteSelected>::value;
};


template <class, class, class, class = void>
struct onCopy {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onCopy<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCopy)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopy))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCopy));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopy));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onCopy>::value != 
		function_uuid<(base_type)&Base::onCopy>::value;
};


template <class, class, class, class = void>
struct onPaste {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPaste<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPaste)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPaste))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPaste));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPaste));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPaste>::value != 
		function_uuid<(base_type)&Base::onPaste>::value;
};


template <class, class, class, class = void>
struct toggleEnableRotate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleEnableRotate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleEnableRotate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleEnableRotate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleEnableRotate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleEnableRotate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleEnableRotate>::value != 
		function_uuid<(base_type)&Base::toggleEnableRotate>::value;
};


template <class, class, class, class = void>
struct toggleFreeMove {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleFreeMove<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFreeMove)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFreeMove))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFreeMove));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFreeMove));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleFreeMove>::value != 
		function_uuid<(base_type)&Base::toggleFreeMove>::value;
};


template <class, class, class, class = void>
struct toggleSwipe {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleSwipe<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSwipe)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSwipe))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSwipe));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSwipe));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleSwipe>::value != 
		function_uuid<(base_type)&Base::toggleSwipe>::value;
};


template <class, class, class, class = void>
struct toggleSnap {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleSnap<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSnap)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSnap))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleSnap));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleSnap));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleSnap>::value != 
		function_uuid<(base_type)&Base::toggleSnap>::value;
};


template <class, class, class, class = void>
struct onPlayback {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlayback<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayback)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayback))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayback));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayback));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlayback>::value != 
		function_uuid<(base_type)&Base::onPlayback>::value;
};


template <class, class, class, class = void>
struct onPlaytest {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlaytest<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlaytest)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlaytest))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlaytest));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlaytest));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlaytest>::value != 
		function_uuid<(base_type)&Base::onPlaytest>::value;
};


template <class, class, class, class = void>
struct onStopPlaytest {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onStopPlaytest<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStopPlaytest)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStopPlaytest))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onStopPlaytest));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onStopPlaytest));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onStopPlaytest>::value != 
		function_uuid<(base_type)&Base::onStopPlaytest>::value;
};


template <class, class, class, class = void>
struct onGroupUp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGroupUp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupUp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupUp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupUp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupUp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGroupUp>::value != 
		function_uuid<(base_type)&Base::onGroupUp>::value;
};


template <class, class, class, class = void>
struct onGroupDown {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGroupDown<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupDown)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupDown))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupDown));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupDown));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGroupDown>::value != 
		function_uuid<(base_type)&Base::onGroupDown>::value;
};


template <class, class, class, class = void>
struct selectBuildTab {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct selectBuildTab<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectBuildTab)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectBuildTab))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::selectBuildTab));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::selectBuildTab));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::selectBuildTab>::value != 
		function_uuid<(base_type)&Base::selectBuildTab>::value;
};


template <class, class, class, class = void>
struct onPause {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPause<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPause)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPause))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPause));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPause));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPause>::value != 
		function_uuid<(base_type)&Base::onPause>::value;
};


template <class, class, class, class = void>
struct onSettings {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSettings<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSettings)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSettings))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSettings));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSettings));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSettings>::value != 
		function_uuid<(base_type)&Base::onSettings>::value;
};


template <class, class, class, class = void>
struct activateRotationControl {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activateRotationControl<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateRotationControl)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateRotationControl))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateRotationControl));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateRotationControl));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activateRotationControl>::value != 
		function_uuid<(base_type)&Base::activateRotationControl>::value;
};


template <class, class, class, class = void>
struct activateScaleControl {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activateScaleControl<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateScaleControl)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateScaleControl))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateScaleControl));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateScaleControl));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activateScaleControl>::value != 
		function_uuid<(base_type)&Base::activateScaleControl>::value;
};


template <class, class, class, class = void>
struct dynamicGroupUpdate {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct dynamicGroupUpdate<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dynamicGroupUpdate)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dynamicGroupUpdate))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dynamicGroupUpdate));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dynamicGroupUpdate));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::dynamicGroupUpdate>::value != 
		function_uuid<(base_type)&Base::dynamicGroupUpdate>::value;
};


template <class, class, class, class = void>
struct createRockOutline {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createRockOutline<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockOutline)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockOutline))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockOutline));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockOutline));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createRockOutline>::value != 
		function_uuid<(base_type)&Base::createRockOutline>::value;
};


template <class, class, class, class = void>
struct createRockEdges {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createRockEdges<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockEdges)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockEdges))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockEdges));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockEdges));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createRockEdges>::value != 
		function_uuid<(base_type)&Base::createRockEdges>::value;
};


template <class, class, class, class = void>
struct createRockBase {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createRockBase<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockBase)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockBase))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRockBase));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRockBase));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createRockBase>::value != 
		function_uuid<(base_type)&Base::createRockBase>::value;
};


template <class, class, class, class = void>
struct onCopyState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onCopyState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCopyState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopyState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCopyState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCopyState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onCopyState>::value != 
		function_uuid<(base_type)&Base::onCopyState>::value;
};


template <class, class, class, class = void>
struct onPasteColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPasteColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPasteColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPasteColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPasteColor>::value != 
		function_uuid<(base_type)&Base::onPasteColor>::value;
};


template <class, class, class, class = void>
struct onPasteState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPasteState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPasteState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPasteState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPasteState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPasteState>::value != 
		function_uuid<(base_type)&Base::onPasteState>::value;
};


template <class, class, class, class = void>
struct onGroupSticky {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGroupSticky<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupSticky)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupSticky))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGroupSticky));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGroupSticky));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGroupSticky>::value != 
		function_uuid<(base_type)&Base::onGroupSticky>::value;
};


template <class, class, class, class = void>
struct onUngroupSticky {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onUngroupSticky<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onUngroupSticky)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUngroupSticky))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onUngroupSticky));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onUngroupSticky));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onUngroupSticky>::value != 
		function_uuid<(base_type)&Base::onUngroupSticky>::value;
};


template <class, class, class, class = void>
struct onGoToLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGoToLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGoToLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGoToLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGoToLayer>::value != 
		function_uuid<(base_type)&Base::onGoToLayer>::value;
};


template <class, class, class, class = void>
struct onGoToBaseLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onGoToBaseLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGoToBaseLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToBaseLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onGoToBaseLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onGoToBaseLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onGoToBaseLayer>::value != 
		function_uuid<(base_type)&Base::onGoToBaseLayer>::value;
};


template <class, class, class, class = void>
struct editColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct editColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::editColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::editColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::editColor>::value != 
		function_uuid<(base_type)&Base::editColor>::value;
};


template <class, class, class, class = void>
struct alignObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct alignObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::alignObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::alignObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::alignObjects>::value != 
		function_uuid<(base_type)&Base::alignObjects>::value;
};


template <class, class, class, class = void>
struct keyUp {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyUp<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyUp)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyUp))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyUp));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyUp));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyUp>::value != 
		function_uuid<(base_type)&Base::keyUp>::value;
};


template <class, class, class, class = void>
struct getTargetColorIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTargetColorIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTargetColorIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetColorIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTargetColorIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTargetColorIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTargetColorIndex>::value != 
		function_uuid<(base_type)&Base::getTargetColorIndex>::value;
};


template <class, class, class, class = void>
struct triggerObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct triggerObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::triggerObject>::value != 
		function_uuid<(base_type)&Base::triggerObject>::value;
};


template <class, class, class, class = void>
struct setAngle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setAngle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAngle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAngle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setAngle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setAngle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setAngle>::value != 
		function_uuid<(base_type)&Base::setAngle>::value;
};


template <class, class, class, class = void>
struct updateSliderPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSliderPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSliderPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSliderPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSliderPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSliderPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSliderPosition>::value != 
		function_uuid<(base_type)&Base::updateSliderPosition>::value;
};


template <class, class, class, class = void>
struct updateColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateColors>::value != 
		function_uuid<(base_type)&Base::updateColors>::value;
};


template <class, class, class, class = void>
struct setup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setup>::value != 
		function_uuid<(base_type)&Base::setup>::value;
};


template <class, class, class, class = void>
struct encodeDataTo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct encodeDataTo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::encodeDataTo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeDataTo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::encodeDataTo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::encodeDataTo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::encodeDataTo>::value != 
		function_uuid<(base_type)&Base::encodeDataTo>::value;
};


template <class, class, class, class = void>
struct dataLoaded {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct dataLoaded<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dataLoaded)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dataLoaded))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::dataLoaded));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::dataLoaded));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::dataLoaded>::value != 
		function_uuid<(base_type)&Base::dataLoaded>::value;
};


template <class, class, class, class = void>
struct firstLoad {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct firstLoad<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::firstLoad)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstLoad))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::firstLoad));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstLoad));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::firstLoad>::value != 
		function_uuid<(base_type)&Base::firstLoad>::value;
};


template <class, class, class, class = void>
struct save {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct save<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::save)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::save))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::save));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::save));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::save>::value != 
		function_uuid<(base_type)&Base::save>::value;
};


template <class, class, class, class = void>
struct saveData {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveData<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveData)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveData))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveData));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveData));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveData>::value != 
		function_uuid<(base_type)&Base::saveData>::value;
};


template <class, class, class, class = void>
struct saveGMTo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveGMTo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveGMTo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveGMTo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveGMTo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveGMTo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveGMTo>::value != 
		function_uuid<(base_type)&Base::saveGMTo>::value;
};


template <class, class, class, class = void>
struct onBtn1 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBtn1<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBtn1)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn1))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBtn1));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn1));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBtn1>::value != 
		function_uuid<(base_type)&Base::onBtn1>::value;
};


template <class, class, class, class = void>
struct onBtn2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBtn2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBtn2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBtn2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBtn2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBtn2>::value != 
		function_uuid<(base_type)&Base::onBtn2>::value;
};


template <class, class, class, class = void>
struct sharedEngine {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sharedEngine<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedEngine)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedEngine))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sharedEngine));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sharedEngine));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sharedEngine>::value != 
		function_uuid<(base_type)&Base::sharedEngine>::value;
};


template <class, class, class, class = void>
struct preloadEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct preloadEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preloadEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preloadEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preloadEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preloadEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::preloadEffect>::value != 
		function_uuid<(base_type)&Base::preloadEffect>::value;
};


template <class, class, class, class = void>
struct isBackgroundMusicPlaying {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isBackgroundMusicPlaying<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBackgroundMusicPlaying)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBackgroundMusicPlaying))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBackgroundMusicPlaying));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBackgroundMusicPlaying));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isBackgroundMusicPlaying>::value != 
		function_uuid<(base_type)&Base::isBackgroundMusicPlaying>::value;
};


template <class, class, class, class = void>
struct loginAccountFailed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFailed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loginAccountFailed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFailed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loginAccountFailed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFailed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loginAccountFailed>::value != 
		function_uuid<(base_type)&Base::loginAccountFailed>::value;
};


template <class, class, class, class = void>
struct loginAccountFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loginAccountFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loginAccountFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loginAccountFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loginAccountFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loginAccountFinished>::value != 
		function_uuid<(base_type)&Base::loginAccountFinished>::value;
};


template <class, class, class, class = void>
struct getObjectLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectLayer>::value != 
		function_uuid<(base_type)&Base::getObjectLayer>::value;
};


template <class, class, class, class = void>
struct getAllObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAllObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAllObjects>::value != 
		function_uuid<(base_type)&Base::getAllObjects>::value;
};


template <class, class, class, class = void>
struct objectsCollided {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectsCollided<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectsCollided)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsCollided))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectsCollided));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsCollided));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectsCollided>::value != 
		function_uuid<(base_type)&Base::objectsCollided>::value;
};


template <class, class, class, class = void>
struct createMoveCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createMoveCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createMoveCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createMoveCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createMoveCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createMoveCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createMoveCommand>::value != 
		function_uuid<(base_type)&Base::createMoveCommand>::value;
};


template <class, class, class, class = void>
struct calculateColorValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateColorValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateColorValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateColorValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateColorValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateColorValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateColorValues>::value != 
		function_uuid<(base_type)&Base::calculateColorValues>::value;
};


template <class, class, class, class = void>
struct toggleGroupTriggered {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupTriggered<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroupTriggered)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupTriggered))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroupTriggered));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupTriggered));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGroupTriggered>::value != 
		function_uuid<(base_type)&Base::toggleGroupTriggered>::value;
};


template <class, class, class, class = void>
struct spawnGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnGroup>::value != 
		function_uuid<(base_type)&Base::spawnGroup>::value;
};


template <class, class, class, class = void>
struct addToSection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToSection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToSection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToSection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToSection>::value != 
		function_uuid<(base_type)&Base::addToSection>::value;
};


template <class, class, class, class = void>
struct addToGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToGroup>::value != 
		function_uuid<(base_type)&Base::addToGroup>::value;
};


template <class, class, class, class = void>
struct removeFromGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeFromGroup>::value != 
		function_uuid<(base_type)&Base::removeFromGroup>::value;
};


template <class, class, class, class = void>
struct addObjectCounter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addObjectCounter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectCounter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectCounter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectCounter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectCounter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addObjectCounter>::value != 
		function_uuid<(base_type)&Base::addObjectCounter>::value;
};


template <class, class, class, class = void>
struct addToGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToGroups>::value != 
		function_uuid<(base_type)&Base::addToGroups>::value;
};


template <class, class, class, class = void>
struct atlasValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct atlasValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::atlasValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::atlasValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::atlasValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::atlasValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::atlasValue>::value != 
		function_uuid<(base_type)&Base::atlasValue>::value;
};


template <class, class, class, class = void>
struct calculateOpacityValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateOpacityValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateOpacityValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOpacityValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateOpacityValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOpacityValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateOpacityValues>::value != 
		function_uuid<(base_type)&Base::calculateOpacityValues>::value;
};


template <class, class, class, class = void>
struct checkSpawnObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct checkSpawnObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkSpawnObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSpawnObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkSpawnObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkSpawnObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::checkSpawnObjects>::value != 
		function_uuid<(base_type)&Base::checkSpawnObjects>::value;
};


template <class, class, class, class = void>
struct collectItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct collectItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collectItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collectItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::collectItem>::value != 
		function_uuid<(base_type)&Base::collectItem>::value;
};


template <class, class, class, class = void>
struct collectedObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct collectedObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collectedObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectedObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::collectedObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::collectedObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::collectedObject>::value != 
		function_uuid<(base_type)&Base::collectedObject>::value;
};


template <class, class, class, class = void>
struct createTextLayers {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createTextLayers<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createTextLayers)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createTextLayers))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createTextLayers));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createTextLayers));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createTextLayers>::value != 
		function_uuid<(base_type)&Base::createTextLayers>::value;
};


template <class, class, class, class = void>
struct damagingObjectsInRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct damagingObjectsInRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::damagingObjectsInRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::damagingObjectsInRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::damagingObjectsInRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::damagingObjectsInRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::damagingObjectsInRect>::value != 
		function_uuid<(base_type)&Base::damagingObjectsInRect>::value;
};


template <class, class, class, class = void>
struct enableHighCapacityMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enableHighCapacityMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableHighCapacityMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableHighCapacityMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableHighCapacityMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableHighCapacityMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enableHighCapacityMode>::value != 
		function_uuid<(base_type)&Base::enableHighCapacityMode>::value;
};


template <class, class, class, class = void>
struct getCapacityString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCapacityString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCapacityString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapacityString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCapacityString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCapacityString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCapacityString>::value != 
		function_uuid<(base_type)&Base::getCapacityString>::value;
};


template <class, class, class, class = void>
struct getGroundHeightForMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroundHeightForMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroundHeightForMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroundHeightForMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroundHeightForMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroundHeightForMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroundHeightForMode>::value != 
		function_uuid<(base_type)&Base::getGroundHeightForMode>::value;
};


template <class, class, class, class = void>
struct getGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroup>::value != 
		function_uuid<(base_type)&Base::getGroup>::value;
};


template <class, class, class, class = void>
struct getMoveDeltaForObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMoveDeltaForObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMoveDeltaForObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMoveDeltaForObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMoveDeltaForObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMoveDeltaForObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMoveDeltaForObjects>::value != 
		function_uuid<(base_type)&Base::getMoveDeltaForObjects>::value;
};


template <class, class, class, class = void>
struct getOptimizedGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOptimizedGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOptimizedGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOptimizedGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOptimizedGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOptimizedGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOptimizedGroup>::value != 
		function_uuid<(base_type)&Base::getOptimizedGroup>::value;
};


template <class, class, class, class = void>
struct getStaticGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStaticGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStaticGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStaticGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStaticGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStaticGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStaticGroup>::value != 
		function_uuid<(base_type)&Base::getStaticGroup>::value;
};


template <class, class, class, class = void>
struct isGroupDisabledForObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupDisabledForObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupDisabledForObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isGroupDisabledForObject>::value != 
		function_uuid<(base_type)&Base::isGroupDisabledForObject>::value;
};


template <class, class, class, class = void>
struct isGroupDisabledForObjectFull {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isGroupDisabledForObjectFull<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupDisabledForObjectFull)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObjectFull))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupDisabledForObjectFull));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupDisabledForObjectFull));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isGroupDisabledForObjectFull>::value != 
		function_uuid<(base_type)&Base::isGroupDisabledForObjectFull>::value;
};


template <class, class, class, class = void>
struct loadUpToPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadUpToPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadUpToPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadUpToPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadUpToPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadUpToPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadUpToPosition>::value != 
		function_uuid<(base_type)&Base::loadUpToPosition>::value;
};


template <class, class, class, class = void>
struct objectIntersectsCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectIntersectsCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectIntersectsCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectIntersectsCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectIntersectsCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectIntersectsCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectIntersectsCircle>::value != 
		function_uuid<(base_type)&Base::objectIntersectsCircle>::value;
};


template <class, class, class, class = void>
struct objectTriggered {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectTriggered<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectTriggered)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectTriggered))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectTriggered));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectTriggered));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectTriggered>::value != 
		function_uuid<(base_type)&Base::objectTriggered>::value;
};


template <class, class, class, class = void>
struct optimizeMoveGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct optimizeMoveGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeMoveGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeMoveGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeMoveGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeMoveGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::optimizeMoveGroups>::value != 
		function_uuid<(base_type)&Base::optimizeMoveGroups>::value;
};


template <class, class, class, class = void>
struct parentForZLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct parentForZLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::parentForZLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentForZLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::parentForZLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::parentForZLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::parentForZLayer>::value != 
		function_uuid<(base_type)&Base::parentForZLayer>::value;
};


template <class, class, class, class = void>
struct playerTouchedRing {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerTouchedRing<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTouchedRing)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchedRing))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerTouchedRing));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerTouchedRing));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerTouchedRing>::value != 
		function_uuid<(base_type)&Base::playerTouchedRing>::value;
};


template <class, class, class, class = void>
struct processColorObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processColorObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processColorObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColorObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processColorObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColorObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processColorObject>::value != 
		function_uuid<(base_type)&Base::processColorObject>::value;
};


template <class, class, class, class = void>
struct processFollowActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processFollowActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processFollowActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processFollowActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processFollowActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processFollowActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processFollowActions>::value != 
		function_uuid<(base_type)&Base::processFollowActions>::value;
};


template <class, class, class, class = void>
struct processMoveActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processMoveActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processMoveActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processMoveActions>::value != 
		function_uuid<(base_type)&Base::processMoveActions>::value;
};


template <class, class, class, class = void>
struct processMoveActionsStep {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processMoveActionsStep<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processMoveActionsStep)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActionsStep))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processMoveActionsStep));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processMoveActionsStep));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processMoveActionsStep>::value != 
		function_uuid<(base_type)&Base::processMoveActionsStep>::value;
};


template <class, class, class, class = void>
struct processOpacityObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processOpacityObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processOpacityObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processOpacityObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processOpacityObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processOpacityObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processOpacityObject>::value != 
		function_uuid<(base_type)&Base::processOpacityObject>::value;
};


template <class, class, class, class = void>
struct processPlayerFollowActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processPlayerFollowActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processPlayerFollowActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPlayerFollowActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processPlayerFollowActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPlayerFollowActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processPlayerFollowActions>::value != 
		function_uuid<(base_type)&Base::processPlayerFollowActions>::value;
};


template <class, class, class, class = void>
struct processRotationActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processRotationActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processRotationActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processRotationActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processRotationActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processRotationActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processRotationActions>::value != 
		function_uuid<(base_type)&Base::processRotationActions>::value;
};


template <class, class, class, class = void>
struct rectIntersectsCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct rectIntersectsCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rectIntersectsCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rectIntersectsCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rectIntersectsCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rectIntersectsCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::rectIntersectsCircle>::value != 
		function_uuid<(base_type)&Base::rectIntersectsCircle>::value;
};


template <class, class, class, class = void>
struct refreshCounterLabels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct refreshCounterLabels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshCounterLabels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshCounterLabels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::refreshCounterLabels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::refreshCounterLabels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::refreshCounterLabels>::value != 
		function_uuid<(base_type)&Base::refreshCounterLabels>::value;
};


template <class, class, class, class = void>
struct removeFromGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeFromGroups>::value != 
		function_uuid<(base_type)&Base::removeFromGroups>::value;
};


template <class, class, class, class = void>
struct removeObjectFromSection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeObjectFromSection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectFromSection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectFromSection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeObjectFromSection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeObjectFromSection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeObjectFromSection>::value != 
		function_uuid<(base_type)&Base::removeObjectFromSection>::value;
};


template <class, class, class, class = void>
struct reorderObjectSection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reorderObjectSection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reorderObjectSection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderObjectSection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reorderObjectSection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reorderObjectSection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reorderObjectSection>::value != 
		function_uuid<(base_type)&Base::reorderObjectSection>::value;
};


template <class, class, class, class = void>
struct resetGroupCounters {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupCounters<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetGroupCounters)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupCounters))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetGroupCounters));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupCounters));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetGroupCounters>::value != 
		function_uuid<(base_type)&Base::resetGroupCounters>::value;
};


template <class, class, class, class = void>
struct resetMoveOptimizedValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveOptimizedValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMoveOptimizedValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveOptimizedValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMoveOptimizedValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveOptimizedValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetMoveOptimizedValue>::value != 
		function_uuid<(base_type)&Base::resetMoveOptimizedValue>::value;
};


template <class, class, class, class = void>
struct sectionForPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sectionForPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sectionForPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sectionForPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sectionForPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sectionForPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sectionForPos>::value != 
		function_uuid<(base_type)&Base::sectionForPos>::value;
};


template <class, class, class, class = void>
struct setupLayers {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupLayers<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLayers)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLayers))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLayers));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLayers));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupLayers>::value != 
		function_uuid<(base_type)&Base::setupLayers>::value;
};


template <class, class, class, class = void>
struct shouldExitHackedLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct shouldExitHackedLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shouldExitHackedLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldExitHackedLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shouldExitHackedLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldExitHackedLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::shouldExitHackedLevel>::value != 
		function_uuid<(base_type)&Base::shouldExitHackedLevel>::value;
};


template <class, class, class, class = void>
struct spawnGroupTriggered {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnGroupTriggered<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnGroupTriggered)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroupTriggered))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnGroupTriggered));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnGroupTriggered));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnGroupTriggered>::value != 
		function_uuid<(base_type)&Base::spawnGroupTriggered>::value;
};


template <class, class, class, class = void>
struct staticObjectsInRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct staticObjectsInRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::staticObjectsInRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::staticObjectsInRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::staticObjectsInRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::staticObjectsInRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::staticObjectsInRect>::value != 
		function_uuid<(base_type)&Base::staticObjectsInRect>::value;
};


template <class, class, class, class = void>
struct testInstantCountTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct testInstantCountTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::testInstantCountTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testInstantCountTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::testInstantCountTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::testInstantCountTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::testInstantCountTrigger>::value != 
		function_uuid<(base_type)&Base::testInstantCountTrigger>::value;
};


template <class, class, class, class = void>
struct toggleGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGroup>::value != 
		function_uuid<(base_type)&Base::toggleGroup>::value;
};


template <class, class, class, class = void>
struct togglePlayerVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct togglePlayerVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePlayerVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePlayerVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePlayerVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::togglePlayerVisibility>::value != 
		function_uuid<(base_type)&Base::togglePlayerVisibility>::value;
};


template <class, class, class, class = void>
struct triggerMoveCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct triggerMoveCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerMoveCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerMoveCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerMoveCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerMoveCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::triggerMoveCommand>::value != 
		function_uuid<(base_type)&Base::triggerMoveCommand>::value;
};


template <class, class, class, class = void>
struct updateCollisionBlocks {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCollisionBlocks<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollisionBlocks)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollisionBlocks))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCollisionBlocks));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCollisionBlocks));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCollisionBlocks>::value != 
		function_uuid<(base_type)&Base::updateCollisionBlocks>::value;
};


template <class, class, class, class = void>
struct updateCounters {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCounters<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCounters)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCounters))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCounters));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCounters));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCounters>::value != 
		function_uuid<(base_type)&Base::updateCounters>::value;
};


template <class, class, class, class = void>
struct updateDisabledObjectsLastPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDisabledObjectsLastPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisabledObjectsLastPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisabledObjectsLastPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDisabledObjectsLastPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDisabledObjectsLastPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDisabledObjectsLastPos>::value != 
		function_uuid<(base_type)&Base::updateDisabledObjectsLastPos>::value;
};


template <class, class, class, class = void>
struct updateLayerCapacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateLayerCapacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLayerCapacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLayerCapacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLayerCapacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLayerCapacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateLayerCapacity>::value != 
		function_uuid<(base_type)&Base::updateLayerCapacity>::value;
};


template <class, class, class, class = void>
struct updateLegacyLayerCapacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateLegacyLayerCapacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLegacyLayerCapacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLegacyLayerCapacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLegacyLayerCapacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLegacyLayerCapacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateLegacyLayerCapacity>::value != 
		function_uuid<(base_type)&Base::updateLegacyLayerCapacity>::value;
};


template <class, class, class, class = void>
struct updateOBB2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOBB2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOBB2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOBB2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOBB2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOBB2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOBB2>::value != 
		function_uuid<(base_type)&Base::updateOBB2>::value;
};


template <class, class, class, class = void>
struct updateQueuedLabels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateQueuedLabels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateQueuedLabels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateQueuedLabels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateQueuedLabels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateQueuedLabels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateQueuedLabels>::value != 
		function_uuid<(base_type)&Base::updateQueuedLabels>::value;
};


template <class, class, class, class = void>
struct activeColorForIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activeColorForIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activeColorForIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeColorForIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activeColorForIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeColorForIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activeColorForIndex>::value != 
		function_uuid<(base_type)&Base::activeColorForIndex>::value;
};


template <class, class, class, class = void>
struct activeOpacityForIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activeOpacityForIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activeOpacityForIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeOpacityForIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activeOpacityForIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activeOpacityForIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activeOpacityForIndex>::value != 
		function_uuid<(base_type)&Base::activeOpacityForIndex>::value;
};


template <class, class, class, class = void>
struct addAllInheritedColorActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addAllInheritedColorActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addAllInheritedColorActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllInheritedColorActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addAllInheritedColorActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addAllInheritedColorActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addAllInheritedColorActions>::value != 
		function_uuid<(base_type)&Base::addAllInheritedColorActions>::value;
};


template <class, class, class, class = void>
struct addGroupPulseEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addGroupPulseEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addGroupPulseEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addGroupPulseEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addGroupPulseEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addGroupPulseEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addGroupPulseEffect>::value != 
		function_uuid<(base_type)&Base::addGroupPulseEffect>::value;
};


template <class, class, class, class = void>
struct calculateBaseActiveColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateBaseActiveColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateBaseActiveColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateBaseActiveColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateBaseActiveColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateBaseActiveColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateBaseActiveColors>::value != 
		function_uuid<(base_type)&Base::calculateBaseActiveColors>::value;
};


template <class, class, class, class = void>
struct calculateInheritedColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateInheritedColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateInheritedColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateInheritedColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateInheritedColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateInheritedColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateInheritedColor>::value != 
		function_uuid<(base_type)&Base::calculateInheritedColor>::value;
};


template <class, class, class, class = void>
struct calculateLightBGColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateLightBGColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateLightBGColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateLightBGColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateLightBGColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateLightBGColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateLightBGColor>::value != 
		function_uuid<(base_type)&Base::calculateLightBGColor>::value;
};


template <class, class, class, class = void>
struct colorActionChanged {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorActionChanged<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorActionChanged)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorActionChanged))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorActionChanged));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorActionChanged));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorActionChanged>::value != 
		function_uuid<(base_type)&Base::colorActionChanged>::value;
};


template <class, class, class, class = void>
struct colorExists {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorExists<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorExists)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorExists))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorExists));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorExists));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorExists>::value != 
		function_uuid<(base_type)&Base::colorExists>::value;
};


template <class, class, class, class = void>
struct colorForEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForEffect>::value != 
		function_uuid<(base_type)&Base::colorForEffect>::value;
};


template <class, class, class, class = void>
struct colorForGroupID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForGroupID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForGroupID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForGroupID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForGroupID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForGroupID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForGroupID>::value != 
		function_uuid<(base_type)&Base::colorForGroupID>::value;
};


template <class, class, class, class = void>
struct colorForIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForIndex>::value != 
		function_uuid<(base_type)&Base::colorForIndex>::value;
};


template <class, class, class, class = void>
struct colorForPulseEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForPulseEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForPulseEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForPulseEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForPulseEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForPulseEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForPulseEffect>::value != 
		function_uuid<(base_type)&Base::colorForPulseEffect>::value;
};


template <class, class, class, class = void>
struct countChangedForItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct countChangedForItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::countChangedForItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countChangedForItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::countChangedForItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countChangedForItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::countChangedForItem>::value != 
		function_uuid<(base_type)&Base::countChangedForItem>::value;
};


template <class, class, class, class = void>
struct countForItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct countForItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::countForItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countForItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::countForItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::countForItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::countForItem>::value != 
		function_uuid<(base_type)&Base::countForItem>::value;
};


template <class, class, class, class = void>
struct createFollowCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createFollowCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createFollowCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFollowCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createFollowCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createFollowCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createFollowCommand>::value != 
		function_uuid<(base_type)&Base::createFollowCommand>::value;
};


template <class, class, class, class = void>
struct createPlayerFollowCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createPlayerFollowCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createPlayerFollowCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createPlayerFollowCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createPlayerFollowCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createPlayerFollowCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createPlayerFollowCommand>::value != 
		function_uuid<(base_type)&Base::createPlayerFollowCommand>::value;
};


template <class, class, class, class = void>
struct createRotateCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createRotateCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRotateCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRotateCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createRotateCommand>::value != 
		function_uuid<(base_type)&Base::createRotateCommand>::value;
};


template <class, class, class, class = void>
struct getAllColorActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllColorActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllColorActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAllColorActions>::value != 
		function_uuid<(base_type)&Base::getAllColorActions>::value;
};


template <class, class, class, class = void>
struct getAllColorSprites {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAllColorSprites<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllColorSprites)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorSprites))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAllColorSprites));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAllColorSprites));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAllColorSprites>::value != 
		function_uuid<(base_type)&Base::getAllColorSprites>::value;
};


template <class, class, class, class = void>
struct getColorAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getColorAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getColorAction>::value != 
		function_uuid<(base_type)&Base::getColorAction>::value;
};


template <class, class, class, class = void>
struct getColorSprite {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getColorSprite<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorSprite)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorSprite))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorSprite));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorSprite));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getColorSprite>::value != 
		function_uuid<(base_type)&Base::getColorSprite>::value;
};


template <class, class, class, class = void>
struct getCurrentStateString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCurrentStateString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCurrentStateString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentStateString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCurrentStateString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCurrentStateString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCurrentStateString>::value != 
		function_uuid<(base_type)&Base::getCurrentStateString>::value;
};


template <class, class, class, class = void>
struct getLoadedMoveOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLoadedMoveOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLoadedMoveOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadedMoveOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLoadedMoveOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadedMoveOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLoadedMoveOffset>::value != 
		function_uuid<(base_type)&Base::getLoadedMoveOffset>::value;
};


template <class, class, class, class = void>
struct getMixedColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMixedColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMixedColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMixedColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMixedColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMixedColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMixedColor>::value != 
		function_uuid<(base_type)&Base::getMixedColor>::value;
};


template <class, class, class, class = void>
struct getOpacityActionForGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOpacityActionForGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOpacityActionForGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacityActionForGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOpacityActionForGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOpacityActionForGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOpacityActionForGroup>::value != 
		function_uuid<(base_type)&Base::getOpacityActionForGroup>::value;
};


template <class, class, class, class = void>
struct handleObjectCollision {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct handleObjectCollision<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handleObjectCollision)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleObjectCollision))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handleObjectCollision));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleObjectCollision));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::handleObjectCollision>::value != 
		function_uuid<(base_type)&Base::handleObjectCollision>::value;
};


template <class, class, class, class = void>
struct hasActiveDualTouch {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasActiveDualTouch<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasActiveDualTouch)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasActiveDualTouch))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasActiveDualTouch));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasActiveDualTouch));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasActiveDualTouch>::value != 
		function_uuid<(base_type)&Base::hasActiveDualTouch>::value;
};


template <class, class, class, class = void>
struct hasBeenTriggered {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenTriggered<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenTriggered)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenTriggered))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenTriggered));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenTriggered));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasBeenTriggered>::value != 
		function_uuid<(base_type)&Base::hasBeenTriggered>::value;
};


template <class, class, class, class = void>
struct hasPulseEffectForGroupID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasPulseEffectForGroupID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasPulseEffectForGroupID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPulseEffectForGroupID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasPulseEffectForGroupID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPulseEffectForGroupID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasPulseEffectForGroupID>::value != 
		function_uuid<(base_type)&Base::hasPulseEffectForGroupID>::value;
};


template <class, class, class, class = void>
struct isGroupEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isGroupEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isGroupEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isGroupEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isGroupEnabled>::value != 
		function_uuid<(base_type)&Base::isGroupEnabled>::value;
};


template <class, class, class, class = void>
struct keyForGroupIDColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyForGroupIDColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyForGroupIDColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyForGroupIDColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyForGroupIDColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyForGroupIDColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyForGroupIDColor>::value != 
		function_uuid<(base_type)&Base::keyForGroupIDColor>::value;
};


template <class, class, class, class = void>
struct loadState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadState>::value != 
		function_uuid<(base_type)&Base::loadState>::value;
};


template <class, class, class, class = void>
struct opacityForIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct opacityForIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::opacityForIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityForIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::opacityForIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityForIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::opacityForIndex>::value != 
		function_uuid<(base_type)&Base::opacityForIndex>::value;
};


template <class, class, class, class = void>
struct opacityModForGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct opacityModForGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::opacityModForGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityModForGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::opacityModForGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::opacityModForGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::opacityModForGroup>::value != 
		function_uuid<(base_type)&Base::opacityModForGroup>::value;
};


template <class, class, class, class = void>
struct playerButton {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerButton<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerButton)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerButton))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerButton));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerButton));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerButton>::value != 
		function_uuid<(base_type)&Base::playerButton>::value;
};


template <class, class, class, class = void>
struct playerDied {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerDied<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerDied)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDied))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerDied));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerDied));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerDied>::value != 
		function_uuid<(base_type)&Base::playerDied>::value;
};


template <class, class, class, class = void>
struct postCollisionCheck {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct postCollisionCheck<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postCollisionCheck)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollisionCheck))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::postCollisionCheck));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::postCollisionCheck));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::postCollisionCheck>::value != 
		function_uuid<(base_type)&Base::postCollisionCheck>::value;
};


template <class, class, class, class = void>
struct preCollisionCheck {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct preCollisionCheck<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preCollisionCheck)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollisionCheck))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::preCollisionCheck));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::preCollisionCheck));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::preCollisionCheck>::value != 
		function_uuid<(base_type)&Base::preCollisionCheck>::value;
};


template <class, class, class, class = void>
struct prepareMoveActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct prepareMoveActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::prepareMoveActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareMoveActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::prepareMoveActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareMoveActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::prepareMoveActions>::value != 
		function_uuid<(base_type)&Base::prepareMoveActions>::value;
};


template <class, class, class, class = void>
struct processColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processColors>::value != 
		function_uuid<(base_type)&Base::processColors>::value;
};


template <class, class, class, class = void>
struct processCopyColorPulseActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processCopyColorPulseActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processCopyColorPulseActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processCopyColorPulseActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processCopyColorPulseActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processCopyColorPulseActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processCopyColorPulseActions>::value != 
		function_uuid<(base_type)&Base::processCopyColorPulseActions>::value;
};


template <class, class, class, class = void>
struct processInheritedColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processInheritedColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processInheritedColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processInheritedColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processInheritedColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processInheritedColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processInheritedColors>::value != 
		function_uuid<(base_type)&Base::processInheritedColors>::value;
};


template <class, class, class, class = void>
struct processPulseActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processPulseActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processPulseActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPulseActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processPulseActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processPulseActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processPulseActions>::value != 
		function_uuid<(base_type)&Base::processPulseActions>::value;
};


template <class, class, class, class = void>
struct registerCollisionTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerCollisionTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerCollisionTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerCollisionTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerCollisionTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerCollisionTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerCollisionTrigger>::value != 
		function_uuid<(base_type)&Base::registerCollisionTrigger>::value;
};


template <class, class, class, class = void>
struct removeAllPulseActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllPulseActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllPulseActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllPulseActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllPulseActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllPulseActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllPulseActions>::value != 
		function_uuid<(base_type)&Base::removeAllPulseActions>::value;
};


template <class, class, class, class = void>
struct removeColorAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeColorAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeColorAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeColorAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeColorAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeColorAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeColorAction>::value != 
		function_uuid<(base_type)&Base::removeColorAction>::value;
};


template <class, class, class, class = void>
struct resetColorCache {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetColorCache<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetColorCache)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetColorCache))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetColorCache));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetColorCache));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetColorCache>::value != 
		function_uuid<(base_type)&Base::resetColorCache>::value;
};


template <class, class, class, class = void>
struct resetEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetEffects>::value != 
		function_uuid<(base_type)&Base::resetEffects>::value;
};


template <class, class, class, class = void>
struct resetMoveActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetMoveActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMoveActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMoveActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMoveActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetMoveActions>::value != 
		function_uuid<(base_type)&Base::resetMoveActions>::value;
};


template <class, class, class, class = void>
struct resetToggledGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetToggledGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetToggledGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetToggledGroups>::value != 
		function_uuid<(base_type)&Base::resetToggledGroups>::value;
};


template <class, class, class, class = void>
struct resetTriggeredIDs {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetTriggeredIDs<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetTriggeredIDs)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetTriggeredIDs))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetTriggeredIDs));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetTriggeredIDs));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetTriggeredIDs>::value != 
		function_uuid<(base_type)&Base::resetTriggeredIDs>::value;
};


template <class, class, class, class = void>
struct runCountTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runCountTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runCountTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runCountTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runCountTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runCountTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runCountTrigger>::value != 
		function_uuid<(base_type)&Base::runCountTrigger>::value;
};


template <class, class, class, class = void>
struct runDeathTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runDeathTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runDeathTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runDeathTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runDeathTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runDeathTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runDeathTrigger>::value != 
		function_uuid<(base_type)&Base::runDeathTrigger>::value;
};


template <class, class, class, class = void>
struct runOpacityActionOnGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runOpacityActionOnGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runOpacityActionOnGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runOpacityActionOnGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runOpacityActionOnGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runOpacityActionOnGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runOpacityActionOnGroup>::value != 
		function_uuid<(base_type)&Base::runOpacityActionOnGroup>::value;
};


template <class, class, class, class = void>
struct runPulseEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runPulseEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runPulseEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runPulseEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runPulseEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runPulseEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runPulseEffect>::value != 
		function_uuid<(base_type)&Base::runPulseEffect>::value;
};


template <class, class, class, class = void>
struct runTouchTriggerCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runTouchTriggerCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runTouchTriggerCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runTouchTriggerCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runTouchTriggerCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runTouchTriggerCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runTouchTriggerCommand>::value != 
		function_uuid<(base_type)&Base::runTouchTriggerCommand>::value;
};


template <class, class, class, class = void>
struct setColorAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setColorAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColorAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setColorAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setColorAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setColorAction>::value != 
		function_uuid<(base_type)&Base::setColorAction>::value;
};


template <class, class, class, class = void>
struct setFollowing {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFollowing<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFollowing)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFollowing))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFollowing));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFollowing));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFollowing>::value != 
		function_uuid<(base_type)&Base::setFollowing>::value;
};


template <class, class, class, class = void>
struct shouldBlend {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct shouldBlend<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shouldBlend)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldBlend))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shouldBlend));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shouldBlend));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::shouldBlend>::value != 
		function_uuid<(base_type)&Base::shouldBlend>::value;
};


template <class, class, class, class = void>
struct stopActionsForTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopActionsForTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopActionsForTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionsForTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopActionsForTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopActionsForTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopActionsForTrigger>::value != 
		function_uuid<(base_type)&Base::stopActionsForTrigger>::value;
};


template <class, class, class, class = void>
struct stopMoveActionsForGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopMoveActionsForGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopMoveActionsForGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopMoveActionsForGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopMoveActionsForGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopMoveActionsForGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopMoveActionsForGroup>::value != 
		function_uuid<(base_type)&Base::stopMoveActionsForGroup>::value;
};


template <class, class, class, class = void>
struct storeTriggeredID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storeTriggeredID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeTriggeredID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeTriggeredID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeTriggeredID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeTriggeredID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storeTriggeredID>::value != 
		function_uuid<(base_type)&Base::storeTriggeredID>::value;
};


template <class, class, class, class = void>
struct traverseInheritanceChain {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct traverseInheritanceChain<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::traverseInheritanceChain)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::traverseInheritanceChain))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::traverseInheritanceChain));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::traverseInheritanceChain));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::traverseInheritanceChain>::value != 
		function_uuid<(base_type)&Base::traverseInheritanceChain>::value;
};


template <class, class, class, class = void>
struct updateActiveOpacityEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateActiveOpacityEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateActiveOpacityEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateActiveOpacityEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateActiveOpacityEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateActiveOpacityEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateActiveOpacityEffects>::value != 
		function_uuid<(base_type)&Base::updateActiveOpacityEffects>::value;
};


template <class, class, class, class = void>
struct updateColorAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateColorAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColorAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColorAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateColorAction>::value != 
		function_uuid<(base_type)&Base::updateColorAction>::value;
};


template <class, class, class, class = void>
struct updateColorEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateColorEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColorEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColorEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColorEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateColorEffects>::value != 
		function_uuid<(base_type)&Base::updateColorEffects>::value;
};


template <class, class, class, class = void>
struct updateEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateEffects>::value != 
		function_uuid<(base_type)&Base::updateEffects>::value;
};


template <class, class, class, class = void>
struct updateOpacityAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacityAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacityAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOpacityAction>::value != 
		function_uuid<(base_type)&Base::updateOpacityAction>::value;
};


template <class, class, class, class = void>
struct updateOpacityEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOpacityEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacityEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOpacityEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOpacityEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOpacityEffects>::value != 
		function_uuid<(base_type)&Base::updateOpacityEffects>::value;
};


template <class, class, class, class = void>
struct updatePulseEffects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updatePulseEffects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePulseEffects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePulseEffects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updatePulseEffects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updatePulseEffects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updatePulseEffects>::value != 
		function_uuid<(base_type)&Base::updatePulseEffects>::value;
};


template <class, class, class, class = void>
struct updateSpawnTriggers {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSpawnTriggers<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpawnTriggers)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpawnTriggers))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSpawnTriggers));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSpawnTriggers));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSpawnTriggers>::value != 
		function_uuid<(base_type)&Base::updateSpawnTriggers>::value;
};


template <class, class, class, class = void>
struct wasFollowing {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct wasFollowing<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::wasFollowing)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wasFollowing))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::wasFollowing));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wasFollowing));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::wasFollowing>::value != 
		function_uuid<(base_type)&Base::wasFollowing>::value;
};


template <class, class, class, class = void>
struct wouldCreateLoop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct wouldCreateLoop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::wouldCreateLoop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wouldCreateLoop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::wouldCreateLoop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::wouldCreateLoop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::wouldCreateLoop>::value != 
		function_uuid<(base_type)&Base::wouldCreateLoop>::value;
};


template <class, class, class, class = void>
struct createWithCoder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithCoder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithCoder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithCoder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithCoder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithCoder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithCoder>::value != 
		function_uuid<(base_type)&Base::createWithCoder>::value;
};


template <class, class, class, class = void>
struct getAudioFileName {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAudioFileName<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAudioFileName)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAudioFileName))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAudioFileName));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAudioFileName));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAudioFileName>::value != 
		function_uuid<(base_type)&Base::getAudioFileName>::value;
};


template <class, class, class, class = void>
struct getCoinKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getCoinKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCoinKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCoinKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getCoinKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getCoinKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getCoinKey>::value != 
		function_uuid<(base_type)&Base::getCoinKey>::value;
};


template <class, class, class, class = void>
struct getLengthKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLengthKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLengthKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLengthKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLengthKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLengthKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLengthKey>::value != 
		function_uuid<(base_type)&Base::getLengthKey>::value;
};


template <class, class, class, class = void>
struct getNormalPercent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNormalPercent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNormalPercent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalPercent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNormalPercent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNormalPercent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNormalPercent>::value != 
		function_uuid<(base_type)&Base::getNormalPercent>::value;
};


template <class, class, class, class = void>
struct levelWasAltered {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelWasAltered<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelWasAltered)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWasAltered))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelWasAltered));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelWasAltered));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelWasAltered>::value != 
		function_uuid<(base_type)&Base::levelWasAltered>::value;
};


template <class, class, class, class = void>
struct savePercentage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct savePercentage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::savePercentage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::savePercentage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::savePercentage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::savePercentage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::savePercentage>::value != 
		function_uuid<(base_type)&Base::savePercentage>::value;
};


template <class, class, class, class = void>
struct getAverageDifficulty {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getAverageDifficulty<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAverageDifficulty)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAverageDifficulty))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getAverageDifficulty));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getAverageDifficulty));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getAverageDifficulty>::value != 
		function_uuid<(base_type)&Base::getAverageDifficulty>::value;
};


template <class, class, class, class = void>
struct onPlayerColor1 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor1<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerColor1)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor1))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerColor1));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor1));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlayerColor1>::value != 
		function_uuid<(base_type)&Base::onPlayerColor1>::value;
};


template <class, class, class, class = void>
struct onPlayerColor2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerColor2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerColor2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerColor2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerColor2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlayerColor2>::value != 
		function_uuid<(base_type)&Base::onPlayerColor2>::value;
};


template <class, class, class, class = void>
struct onSelectTab {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSelectTab<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectTab)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectTab))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSelectTab));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSelectTab));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSelectTab>::value != 
		function_uuid<(base_type)&Base::onSelectTab>::value;
};


template <class, class, class, class = void>
struct onPlayerIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPlayerIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPlayerIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPlayerIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPlayerIcon>::value != 
		function_uuid<(base_type)&Base::onPlayerIcon>::value;
};


template <class, class, class, class = void>
struct onShipIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onShipIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShipIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShipIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShipIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShipIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onShipIcon>::value != 
		function_uuid<(base_type)&Base::onShipIcon>::value;
};


template <class, class, class, class = void>
struct onBallIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBallIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBallIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBallIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBallIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBallIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBallIcon>::value != 
		function_uuid<(base_type)&Base::onBallIcon>::value;
};


template <class, class, class, class = void>
struct onBirdIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBirdIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBirdIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBirdIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBirdIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBirdIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBirdIcon>::value != 
		function_uuid<(base_type)&Base::onBirdIcon>::value;
};


template <class, class, class, class = void>
struct onDartIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDartIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDartIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDartIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDartIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDartIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDartIcon>::value != 
		function_uuid<(base_type)&Base::onDartIcon>::value;
};


template <class, class, class, class = void>
struct onRobotIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onRobotIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRobotIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobotIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onRobotIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onRobotIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onRobotIcon>::value != 
		function_uuid<(base_type)&Base::onRobotIcon>::value;
};


template <class, class, class, class = void>
struct onSpiderIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onSpiderIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSpiderIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSpiderIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onSpiderIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onSpiderIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onSpiderIcon>::value != 
		function_uuid<(base_type)&Base::onSpiderIcon>::value;
};


template <class, class, class, class = void>
struct onShards {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onShards<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShards)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShards))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShards));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShards));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onShards>::value != 
		function_uuid<(base_type)&Base::onShards>::value;
};


template <class, class, class, class = void>
struct onBack {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onBack<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBack)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBack))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onBack));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onBack));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onBack>::value != 
		function_uuid<(base_type)&Base::onBack>::value;
};


template <class, class, class, class = void>
struct onShop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onShop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onShop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onShop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onShop>::value != 
		function_uuid<(base_type)&Base::onShop>::value;
};


template <class, class, class, class = void>
struct updateGroundWidth {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGroundWidth<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGroundWidth)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroundWidth))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGroundWidth));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroundWidth));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGroundWidth>::value != 
		function_uuid<(base_type)&Base::updateGroundWidth>::value;
};


template <class, class, class, class = void>
struct createBrowserIcon {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createBrowserIcon<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createBrowserIcon)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBrowserIcon))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createBrowserIcon));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBrowserIcon));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createBrowserIcon>::value != 
		function_uuid<(base_type)&Base::createBrowserIcon>::value;
};


template <class, class, class, class = void>
struct setupLevelBrowser {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelBrowser<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLevelBrowser)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelBrowser))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLevelBrowser));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelBrowser));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupLevelBrowser>::value != 
		function_uuid<(base_type)&Base::setupLevelBrowser>::value;
};


template <class, class, class, class = void>
struct hideSecondary {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hideSecondary<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideSecondary)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideSecondary))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hideSecondary));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hideSecondary));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hideSecondary>::value != 
		function_uuid<(base_type)&Base::hideSecondary>::value;
};


template <class, class, class, class = void>
struct updateColor02 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateColor02<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColor02)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor02))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateColor02));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateColor02));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateColor02>::value != 
		function_uuid<(base_type)&Base::updateColor02>::value;
};


template <class, class, class, class = void>
struct updateFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateFrame>::value != 
		function_uuid<(base_type)&Base::updateFrame>::value;
};


template <class, class, class, class = void>
struct loadValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadValues>::value != 
		function_uuid<(base_type)&Base::loadValues>::value;
};


template <class, class, class, class = void>
struct getType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getType>::value != 
		function_uuid<(base_type)&Base::getType>::value;
};


template <class, class, class, class = void>
struct getPlayerFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerFrame>::value != 
		function_uuid<(base_type)&Base::getPlayerFrame>::value;
};


template <class, class, class, class = void>
struct getPlayerBird {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerBird<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerBird)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBird))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerBird));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerBird));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerBird>::value != 
		function_uuid<(base_type)&Base::getPlayerBird>::value;
};


template <class, class, class, class = void>
struct getPlayerDart {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDart<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerDart)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDart))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerDart));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDart));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerDart>::value != 
		function_uuid<(base_type)&Base::getPlayerDart>::value;
};


template <class, class, class, class = void>
struct getPlayerDeathEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerDeathEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerDeathEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDeathEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerDeathEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerDeathEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerDeathEffect>::value != 
		function_uuid<(base_type)&Base::getPlayerDeathEffect>::value;
};


template <class, class, class, class = void>
struct getPlayerColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerColor>::value != 
		function_uuid<(base_type)&Base::getPlayerColor>::value;
};


template <class, class, class, class = void>
struct getPlayerGlow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerGlow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerGlow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerGlow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerGlow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerGlow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerGlow>::value != 
		function_uuid<(base_type)&Base::getPlayerGlow>::value;
};


template <class, class, class, class = void>
struct getPlayerIconType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayerIconType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerIconType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerIconType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayerIconType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayerIconType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayerIconType>::value != 
		function_uuid<(base_type)&Base::getPlayerIconType>::value;
};


template <class, class, class, class = void>
struct setPlayerFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerFrame>::value != 
		function_uuid<(base_type)&Base::setPlayerFrame>::value;
};


template <class, class, class, class = void>
struct setPlayerShip {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerShip<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerShip)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerShip))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerShip));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerShip));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerShip>::value != 
		function_uuid<(base_type)&Base::setPlayerShip>::value;
};


template <class, class, class, class = void>
struct setPlayerBall {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBall<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerBall)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBall))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerBall));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBall));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerBall>::value != 
		function_uuid<(base_type)&Base::setPlayerBall>::value;
};


template <class, class, class, class = void>
struct setPlayerBird {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerBird<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerBird)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBird))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerBird));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerBird));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerBird>::value != 
		function_uuid<(base_type)&Base::setPlayerBird>::value;
};


template <class, class, class, class = void>
struct setPlayerDart {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDart<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerDart)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDart))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerDart));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDart));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerDart>::value != 
		function_uuid<(base_type)&Base::setPlayerDart>::value;
};


template <class, class, class, class = void>
struct setPlayerRobot {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerRobot<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerRobot)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerRobot))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerRobot));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerRobot));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerRobot>::value != 
		function_uuid<(base_type)&Base::setPlayerRobot>::value;
};


template <class, class, class, class = void>
struct setPlayerSpider {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerSpider<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerSpider)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerSpider))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerSpider));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerSpider));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerSpider>::value != 
		function_uuid<(base_type)&Base::setPlayerSpider>::value;
};


template <class, class, class, class = void>
struct setPlayerStreak {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerStreak<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerStreak)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerStreak))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerStreak));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerStreak));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerStreak>::value != 
		function_uuid<(base_type)&Base::setPlayerStreak>::value;
};


template <class, class, class, class = void>
struct setPlayerDeathEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerDeathEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerDeathEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDeathEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerDeathEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerDeathEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerDeathEffect>::value != 
		function_uuid<(base_type)&Base::setPlayerDeathEffect>::value;
};


template <class, class, class, class = void>
struct setPlayerColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerColor>::value != 
		function_uuid<(base_type)&Base::setPlayerColor>::value;
};


template <class, class, class, class = void>
struct setPlayerColor2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerColor2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerColor2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerColor2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerColor2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerColor2>::value != 
		function_uuid<(base_type)&Base::setPlayerColor2>::value;
};


template <class, class, class, class = void>
struct setPlayerGlow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerGlow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerGlow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerGlow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerGlow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerGlow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerGlow>::value != 
		function_uuid<(base_type)&Base::setPlayerGlow>::value;
};


template <class, class, class, class = void>
struct setPlayerIconType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setPlayerIconType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerIconType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerIconType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setPlayerIconType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setPlayerIconType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setPlayerIconType>::value != 
		function_uuid<(base_type)&Base::setPlayerIconType>::value;
};


template <class, class, class, class = void>
struct setQuality {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setQuality<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setQuality)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setQuality))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setQuality));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setQuality));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setQuality>::value != 
		function_uuid<(base_type)&Base::setQuality>::value;
};


template <class, class, class, class = void>
struct getPlayLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getPlayLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getPlayLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getPlayLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getPlayLayer>::value != 
		function_uuid<(base_type)&Base::getPlayLayer>::value;
};


template <class, class, class, class = void>
struct getEditorLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getEditorLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getEditorLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getEditorLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getEditorLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getEditorLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getEditorLayer>::value != 
		function_uuid<(base_type)&Base::getEditorLayer>::value;
};


template <class, class, class, class = void>
struct getGameVariableDefault {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariableDefault<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameVariableDefault)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariableDefault))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameVariableDefault));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariableDefault));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGameVariableDefault>::value != 
		function_uuid<(base_type)&Base::getGameVariableDefault>::value;
};


template <class, class, class, class = void>
struct getIntGameVariableDefault {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariableDefault<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIntGameVariableDefault)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariableDefault))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIntGameVariableDefault));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariableDefault));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getIntGameVariableDefault>::value != 
		function_uuid<(base_type)&Base::getIntGameVariableDefault>::value;
};


template <class, class, class, class = void>
struct colorForIdx {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForIdx<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForIdx)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIdx))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForIdx));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForIdx));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForIdx>::value != 
		function_uuid<(base_type)&Base::colorForIdx>::value;
};


template <class, class, class, class = void>
struct didExitPlayscene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct didExitPlayscene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didExitPlayscene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didExitPlayscene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didExitPlayscene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didExitPlayscene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::didExitPlayscene>::value != 
		function_uuid<(base_type)&Base::didExitPlayscene>::value;
};


template <class, class, class, class = void>
struct doQuickSave {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct doQuickSave<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doQuickSave)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doQuickSave))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::doQuickSave));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::doQuickSave));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::doQuickSave>::value != 
		function_uuid<(base_type)&Base::doQuickSave>::value;
};


template <class, class, class, class = void>
struct fadeInMusic {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fadeInMusic<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeInMusic)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInMusic))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fadeInMusic));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fadeInMusic));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fadeInMusic>::value != 
		function_uuid<(base_type)&Base::fadeInMusic>::value;
};


template <class, class, class, class = void>
struct getBGTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBGTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBGTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBGTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBGTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBGTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBGTexture>::value != 
		function_uuid<(base_type)&Base::getBGTexture>::value;
};


template <class, class, class, class = void>
struct getFontFile {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getFontFile<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getFontFile)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getFontFile))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getFontFile));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getFontFile));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getFontFile>::value != 
		function_uuid<(base_type)&Base::getFontFile>::value;
};


template <class, class, class, class = void>
struct getGameVariable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGameVariable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameVariable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameVariable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameVariable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGameVariable>::value != 
		function_uuid<(base_type)&Base::getGameVariable>::value;
};


template <class, class, class, class = void>
struct getIntGameVariable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getIntGameVariable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIntGameVariable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getIntGameVariable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getIntGameVariable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getIntGameVariable>::value != 
		function_uuid<(base_type)&Base::getIntGameVariable>::value;
};


template <class, class, class, class = void>
struct getUGV {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getUGV<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUGV)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUGV))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUGV));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUGV));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getUGV>::value != 
		function_uuid<(base_type)&Base::getUGV>::value;
};


template <class, class, class, class = void>
struct loadDeathEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadDeathEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadDeathEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDeathEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadDeathEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDeathEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadDeathEffect>::value != 
		function_uuid<(base_type)&Base::loadDeathEffect>::value;
};


template <class, class, class, class = void>
struct loadFont {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadFont<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFont)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFont))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadFont));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadFont));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadFont>::value != 
		function_uuid<(base_type)&Base::loadFont>::value;
};


template <class, class, class, class = void>
struct reloadAll {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadAll<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAll)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAll))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAll));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAll));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadAll>::value != 
		function_uuid<(base_type)&Base::reloadAll>::value;
};


template <class, class, class, class = void>
struct reloadAllStep2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAllStep2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAllStep2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadAllStep2>::value != 
		function_uuid<(base_type)&Base::reloadAllStep2>::value;
};


template <class, class, class, class = void>
struct reloadAllStep5 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reloadAllStep5<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAllStep5)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep5))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reloadAllStep5));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reloadAllStep5));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reloadAllStep5>::value != 
		function_uuid<(base_type)&Base::reloadAllStep5>::value;
};


template <class, class, class, class = void>
struct reportPercentageForLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reportPercentageForLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reportPercentageForLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportPercentageForLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reportPercentageForLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportPercentageForLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reportPercentageForLevel>::value != 
		function_uuid<(base_type)&Base::reportPercentageForLevel>::value;
};


template <class, class, class, class = void>
struct setGameVariable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGameVariable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameVariable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameVariable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameVariable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameVariable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGameVariable>::value != 
		function_uuid<(base_type)&Base::setGameVariable>::value;
};


template <class, class, class, class = void>
struct setIntGameVariable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setIntGameVariable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setIntGameVariable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setIntGameVariable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setIntGameVariable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setIntGameVariable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setIntGameVariable>::value != 
		function_uuid<(base_type)&Base::setIntGameVariable>::value;
};


template <class, class, class, class = void>
struct setUGV {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setUGV<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUGV)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUGV))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setUGV));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setUGV));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setUGV>::value != 
		function_uuid<(base_type)&Base::setUGV>::value;
};


template <class, class, class, class = void>
struct getGTexture {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGTexture<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGTexture)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGTexture))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGTexture));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGTexture));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGTexture>::value != 
		function_uuid<(base_type)&Base::getGTexture>::value;
};


template <class, class, class, class = void>
struct reportAchievementWithID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct reportAchievementWithID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reportAchievementWithID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportAchievementWithID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::reportAchievementWithID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::reportAchievementWithID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::reportAchievementWithID>::value != 
		function_uuid<(base_type)&Base::reportAchievementWithID>::value;
};


template <class, class, class, class = void>
struct resolutionForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resolutionForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resolutionForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resolutionForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resolutionForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resolutionForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resolutionForKey>::value != 
		function_uuid<(base_type)&Base::resolutionForKey>::value;
};


template <class, class, class, class = void>
struct isColorUnlocked {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isColorUnlocked<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isColorUnlocked)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorUnlocked))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isColorUnlocked));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorUnlocked));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isColorUnlocked>::value != 
		function_uuid<(base_type)&Base::isColorUnlocked>::value;
};


template <class, class, class, class = void>
struct isIconUnlocked {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isIconUnlocked<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isIconUnlocked)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIconUnlocked))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isIconUnlocked));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isIconUnlocked));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isIconUnlocked>::value != 
		function_uuid<(base_type)&Base::isIconUnlocked>::value;
};


template <class, class, class, class = void>
struct toggleGameVariable {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGameVariable<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGameVariable)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGameVariable))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGameVariable));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGameVariable));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGameVariable>::value != 
		function_uuid<(base_type)&Base::toggleGameVariable>::value;
};


template <class, class, class, class = void>
struct returnToLastScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct returnToLastScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::returnToLastScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::returnToLastScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::returnToLastScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::returnToLastScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::returnToLastScene>::value != 
		function_uuid<(base_type)&Base::returnToLastScene>::value;
};


template <class, class, class, class = void>
struct getStartPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStartPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStartPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStartPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStartPosition>::value != 
		function_uuid<(base_type)&Base::getStartPosition>::value;
};


template <class, class, class, class = void>
struct setStartPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setStartPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStartPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStartPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setStartPosition>::value != 
		function_uuid<(base_type)&Base::setStartPosition>::value;
};


template <class, class, class, class = void>
struct getUniqueID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getUniqueID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUniqueID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUniqueID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getUniqueID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getUniqueID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getUniqueID>::value != 
		function_uuid<(base_type)&Base::getUniqueID>::value;
};


template <class, class, class, class = void>
struct getGroupID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroupID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroupID>::value != 
		function_uuid<(base_type)&Base::getGroupID>::value;
};


template <class, class, class, class = void>
struct getGroupIDCount {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDCount<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupIDCount)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDCount))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupIDCount));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDCount));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroupIDCount>::value != 
		function_uuid<(base_type)&Base::getGroupIDCount>::value;
};


template <class, class, class, class = void>
struct getGroupIDs {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGroupIDs<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupIDs)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDs))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGroupIDs));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGroupIDs));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGroupIDs>::value != 
		function_uuid<(base_type)&Base::getGroupIDs>::value;
};


template <class, class, class, class = void>
struct getGameZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getGameZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getGameZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getGameZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getGameZOrder>::value != 
		function_uuid<(base_type)&Base::getGameZOrder>::value;
};


template <class, class, class, class = void>
struct setGameZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGameZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGameZOrder>::value != 
		function_uuid<(base_type)&Base::setGameZOrder>::value;
};


template <class, class, class, class = void>
struct setGameObjType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGameObjType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameObjType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameObjType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGameObjType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGameObjType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGameObjType>::value != 
		function_uuid<(base_type)&Base::setGameObjType>::value;
};


template <class, class, class, class = void>
struct getBaseColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBaseColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBaseColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBaseColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBaseColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBaseColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBaseColor>::value != 
		function_uuid<(base_type)&Base::getBaseColor>::value;
};


template <class, class, class, class = void>
struct getDetailColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDetailColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDetailColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDetailColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDetailColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDetailColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDetailColor>::value != 
		function_uuid<(base_type)&Base::getDetailColor>::value;
};


template <class, class, class, class = void>
struct setupCustomSprites {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupCustomSprites<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCustomSprites)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCustomSprites))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCustomSprites));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCustomSprites));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupCustomSprites>::value != 
		function_uuid<(base_type)&Base::setupCustomSprites>::value;
};


template <class, class, class, class = void>
struct addMainSpriteToParent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addMainSpriteToParent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addMainSpriteToParent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addMainSpriteToParent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addMainSpriteToParent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addMainSpriteToParent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addMainSpriteToParent>::value != 
		function_uuid<(base_type)&Base::addMainSpriteToParent>::value;
};


template <class, class, class, class = void>
struct activateObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activateObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activateObject>::value != 
		function_uuid<(base_type)&Base::activateObject>::value;
};


template <class, class, class, class = void>
struct deactivateObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct deactivateObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deactivateObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deactivateObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::deactivateObject>::value != 
		function_uuid<(base_type)&Base::deactivateObject>::value;
};


template <class, class, class, class = void>
struct getObjectRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectRect>::value != 
		function_uuid<(base_type)&Base::getObjectRect>::value;
};


template <class, class, class, class = void>
struct getObjectRect2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRect2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRect2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRect2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRect2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectRect2>::value != 
		function_uuid<(base_type)&Base::getObjectRect2>::value;
};


template <class, class, class, class = void>
struct getObjectTextureRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectTextureRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectTextureRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectTextureRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectTextureRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectTextureRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectTextureRect>::value != 
		function_uuid<(base_type)&Base::getObjectTextureRect>::value;
};


template <class, class, class, class = void>
struct setStartPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setStartPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStartPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setStartPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setStartPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setStartPos>::value != 
		function_uuid<(base_type)&Base::setStartPos>::value;
};


template <class, class, class, class = void>
struct updateStartValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateStartValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStartValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStartValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateStartValues>::value != 
		function_uuid<(base_type)&Base::updateStartValues>::value;
};


template <class, class, class, class = void>
struct customObjectSetup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct customObjectSetup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::customObjectSetup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customObjectSetup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::customObjectSetup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::customObjectSetup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::customObjectSetup>::value != 
		function_uuid<(base_type)&Base::customObjectSetup>::value;
};


template <class, class, class, class = void>
struct isFlipX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isFlipX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isFlipX>::value != 
		function_uuid<(base_type)&Base::isFlipX>::value;
};


template <class, class, class, class = void>
struct isFlipY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isFlipY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isFlipY>::value != 
		function_uuid<(base_type)&Base::isFlipY>::value;
};


template <class, class, class, class = void>
struct setRScaleX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScaleX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScaleX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRScaleX>::value != 
		function_uuid<(base_type)&Base::setRScaleX>::value;
};


template <class, class, class, class = void>
struct setRScaleY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRScaleY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScaleY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScaleY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScaleY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRScaleY>::value != 
		function_uuid<(base_type)&Base::setRScaleY>::value;
};


template <class, class, class, class = void>
struct setRScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setRScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setRScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setRScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setRScale>::value != 
		function_uuid<(base_type)&Base::setRScale>::value;
};


template <class, class, class, class = void>
struct getRScaleX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRScaleX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRScaleX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRScaleX>::value != 
		function_uuid<(base_type)&Base::getRScaleX>::value;
};


template <class, class, class, class = void>
struct getRScaleY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRScaleY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRScaleY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRScaleY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRScaleY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRScaleY>::value != 
		function_uuid<(base_type)&Base::getRScaleY>::value;
};


template <class, class, class, class = void>
struct calculateSpawnXPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateSpawnXPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateSpawnXPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateSpawnXPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateSpawnXPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateSpawnXPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateSpawnXPos>::value != 
		function_uuid<(base_type)&Base::calculateSpawnXPos>::value;
};


template <class, class, class, class = void>
struct triggerActivated {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct triggerActivated<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerActivated)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerActivated))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::triggerActivated));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::triggerActivated));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::triggerActivated>::value != 
		function_uuid<(base_type)&Base::triggerActivated>::value;
};


template <class, class, class, class = void>
struct powerOnObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct powerOnObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::powerOnObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOnObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::powerOnObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOnObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::powerOnObject>::value != 
		function_uuid<(base_type)&Base::powerOnObject>::value;
};


template <class, class, class, class = void>
struct powerOffObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct powerOffObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::powerOffObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOffObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::powerOffObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::powerOffObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::powerOffObject>::value != 
		function_uuid<(base_type)&Base::powerOffObject>::value;
};


template <class, class, class, class = void>
struct setGlowColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGlowColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGlowColor>::value != 
		function_uuid<(base_type)&Base::setGlowColor>::value;
};


template <class, class, class, class = void>
struct spawnXPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnXPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnXPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnXPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnXPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnXPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnXPosition>::value != 
		function_uuid<(base_type)&Base::spawnXPosition>::value;
};


template <class, class, class, class = void>
struct getObjectRectDirty {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRectDirty<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRectDirty)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRectDirty))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRectDirty));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRectDirty));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectRectDirty>::value != 
		function_uuid<(base_type)&Base::getObjectRectDirty>::value;
};


template <class, class, class, class = void>
struct setObjectRectDirty {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setObjectRectDirty<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObjectRectDirty)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectRectDirty))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setObjectRectDirty));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setObjectRectDirty));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setObjectRectDirty>::value != 
		function_uuid<(base_type)&Base::setObjectRectDirty>::value;
};


template <class, class, class, class = void>
struct getOrientedRectDirty {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOrientedRectDirty<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrientedRectDirty)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedRectDirty))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOrientedRectDirty));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOrientedRectDirty));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOrientedRectDirty>::value != 
		function_uuid<(base_type)&Base::getOrientedRectDirty>::value;
};


template <class, class, class, class = void>
struct setOrientedRectDirty {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setOrientedRectDirty<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOrientedRectDirty)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrientedRectDirty))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setOrientedRectDirty));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setOrientedRectDirty));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setOrientedRectDirty>::value != 
		function_uuid<(base_type)&Base::setOrientedRectDirty>::value;
};


template <class, class, class, class = void>
struct setType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setType>::value != 
		function_uuid<(base_type)&Base::setType>::value;
};


template <class, class, class, class = void>
struct getStartPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStartPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStartPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStartPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStartPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStartPos>::value != 
		function_uuid<(base_type)&Base::getStartPos>::value;
};


template <class, class, class, class = void>
struct activatedByPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activatedByPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activatedByPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activatedByPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activatedByPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activatedByPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activatedByPlayer>::value != 
		function_uuid<(base_type)&Base::activatedByPlayer>::value;
};


template <class, class, class, class = void>
struct addColorSprite {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addColorSprite<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addColorSprite)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSprite))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addColorSprite));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSprite));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addColorSprite>::value != 
		function_uuid<(base_type)&Base::addColorSprite>::value;
};


template <class, class, class, class = void>
struct addColorSpriteToParent {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addColorSpriteToParent<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addColorSpriteToParent)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSpriteToParent))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addColorSpriteToParent));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addColorSpriteToParent));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addColorSpriteToParent>::value != 
		function_uuid<(base_type)&Base::addColorSpriteToParent>::value;
};


template <class, class, class, class = void>
struct addToTempOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToTempOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToTempOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTempOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToTempOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToTempOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToTempOffset>::value != 
		function_uuid<(base_type)&Base::addToTempOffset>::value;
};


template <class, class, class, class = void>
struct calculateOrientedBox {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct calculateOrientedBox<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateOrientedBox)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOrientedBox))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::calculateOrientedBox));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::calculateOrientedBox));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::calculateOrientedBox>::value != 
		function_uuid<(base_type)&Base::calculateOrientedBox>::value;
};


template <class, class, class, class = void>
struct canChangeCustomColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct canChangeCustomColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::canChangeCustomColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canChangeCustomColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::canChangeCustomColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::canChangeCustomColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::canChangeCustomColor>::value != 
		function_uuid<(base_type)&Base::canChangeCustomColor>::value;
};


template <class, class, class, class = void>
struct colorForMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorForMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorForMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorForMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorForMode>::value != 
		function_uuid<(base_type)&Base::colorForMode>::value;
};


template <class, class, class, class = void>
struct commonSetup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct commonSetup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::commonSetup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commonSetup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::commonSetup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commonSetup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::commonSetup>::value != 
		function_uuid<(base_type)&Base::commonSetup>::value;
};


template <class, class, class, class = void>
struct copyGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct copyGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::copyGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::copyGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::copyGroups>::value != 
		function_uuid<(base_type)&Base::copyGroups>::value;
};


template <class, class, class, class = void>
struct createWithFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithFrame>::value != 
		function_uuid<(base_type)&Base::createWithFrame>::value;
};


template <class, class, class, class = void>
struct createWithKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithKey>::value != 
		function_uuid<(base_type)&Base::createWithKey>::value;
};


template <class, class, class, class = void>
struct destroyObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct destroyObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::destroyObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::destroyObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::destroyObject>::value != 
		function_uuid<(base_type)&Base::destroyObject>::value;
};


template <class, class, class, class = void>
struct determineSlopeDirection {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct determineSlopeDirection<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::determineSlopeDirection)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::determineSlopeDirection))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::determineSlopeDirection));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::determineSlopeDirection));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::determineSlopeDirection>::value != 
		function_uuid<(base_type)&Base::determineSlopeDirection>::value;
};


template <class, class, class, class = void>
struct getActiveColorForMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getActiveColorForMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActiveColorForMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveColorForMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getActiveColorForMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getActiveColorForMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getActiveColorForMode>::value != 
		function_uuid<(base_type)&Base::getActiveColorForMode>::value;
};


template <class, class, class, class = void>
struct getBallFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBallFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBallFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBallFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBallFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBallFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBallFrame>::value != 
		function_uuid<(base_type)&Base::getBallFrame>::value;
};


template <class, class, class, class = void>
struct getBoxOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getBoxOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBoxOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoxOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getBoxOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getBoxOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getBoxOffset>::value != 
		function_uuid<(base_type)&Base::getBoxOffset>::value;
};


template <class, class, class, class = void>
struct getColorIndex {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getColorIndex<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorIndex)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorIndex))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getColorIndex));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getColorIndex));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getColorIndex>::value != 
		function_uuid<(base_type)&Base::getColorIndex>::value;
};


template <class, class, class, class = void>
struct getDidUpdateLastPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getDidUpdateLastPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDidUpdateLastPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDidUpdateLastPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getDidUpdateLastPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getDidUpdateLastPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getDidUpdateLastPosition>::value != 
		function_uuid<(base_type)&Base::getDidUpdateLastPosition>::value;
};


template <class, class, class, class = void>
struct getLastPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLastPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLastPosition>::value != 
		function_uuid<(base_type)&Base::getLastPosition>::value;
};


template <class, class, class, class = void>
struct getMainColorMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMainColorMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMainColorMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainColorMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMainColorMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMainColorMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMainColorMode>::value != 
		function_uuid<(base_type)&Base::getMainColorMode>::value;
};


template <class, class, class, class = void>
struct getObjectZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectZOrder>::value != 
		function_uuid<(base_type)&Base::getObjectZOrder>::value;
};


template <class, class, class, class = void>
struct getObjectRadius {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectRadius<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRadius)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRadius))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectRadius));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectRadius));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectRadius>::value != 
		function_uuid<(base_type)&Base::getObjectRadius>::value;
};


template <class, class, class, class = void>
struct getSecondaryColorMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSecondaryColorMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecondaryColorMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondaryColorMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecondaryColorMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecondaryColorMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSecondaryColorMode>::value != 
		function_uuid<(base_type)&Base::getSecondaryColorMode>::value;
};


template <class, class, class, class = void>
struct getSectionIdx {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSectionIdx<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSectionIdx)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSectionIdx))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSectionIdx));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSectionIdx));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSectionIdx>::value != 
		function_uuid<(base_type)&Base::getSectionIdx>::value;
};


template <class, class, class, class = void>
struct groupWasDisabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct groupWasDisabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::groupWasDisabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasDisabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::groupWasDisabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasDisabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::groupWasDisabled>::value != 
		function_uuid<(base_type)&Base::groupWasDisabled>::value;
};


template <class, class, class, class = void>
struct groupWasEnabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct groupWasEnabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::groupWasEnabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasEnabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::groupWasEnabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::groupWasEnabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::groupWasEnabled>::value != 
		function_uuid<(base_type)&Base::groupWasEnabled>::value;
};


template <class, class, class, class = void>
struct hasBeenActivated {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivated<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenActivated)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivated))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenActivated));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivated));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasBeenActivated>::value != 
		function_uuid<(base_type)&Base::hasBeenActivated>::value;
};


template <class, class, class, class = void>
struct hasBeenActivatedByPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasBeenActivatedByPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenActivatedByPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivatedByPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasBeenActivatedByPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasBeenActivatedByPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasBeenActivatedByPlayer>::value != 
		function_uuid<(base_type)&Base::hasBeenActivatedByPlayer>::value;
};


template <class, class, class, class = void>
struct hasSecondaryColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasSecondaryColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasSecondaryColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecondaryColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasSecondaryColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecondaryColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasSecondaryColor>::value != 
		function_uuid<(base_type)&Base::hasSecondaryColor>::value;
};


template <class, class, class, class = void>
struct ignoreEnter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ignoreEnter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreEnter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreEnter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreEnter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreEnter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ignoreEnter>::value != 
		function_uuid<(base_type)&Base::ignoreEnter>::value;
};


template <class, class, class, class = void>
struct ignoreFade {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct ignoreFade<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreFade)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreFade))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::ignoreFade));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::ignoreFade));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::ignoreFade>::value != 
		function_uuid<(base_type)&Base::ignoreFade>::value;
};


template <class, class, class, class = void>
struct isBasicTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isBasicTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBasicTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBasicTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isBasicTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isBasicTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isBasicTrigger>::value != 
		function_uuid<(base_type)&Base::isBasicTrigger>::value;
};


template <class, class, class, class = void>
struct isColorTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isColorTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isColorTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isColorTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isColorTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isColorTrigger>::value != 
		function_uuid<(base_type)&Base::isColorTrigger>::value;
};


template <class, class, class, class = void>
struct isSpawnableTrigger {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSpawnableTrigger<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSpawnableTrigger)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpawnableTrigger))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSpawnableTrigger));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpawnableTrigger));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSpawnableTrigger>::value != 
		function_uuid<(base_type)&Base::isSpawnableTrigger>::value;
};


template <class, class, class, class = void>
struct isSpecialObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isSpecialObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSpecialObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpecialObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isSpecialObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isSpecialObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isSpecialObject>::value != 
		function_uuid<(base_type)&Base::isSpecialObject>::value;
};


template <class, class, class, class = void>
struct objectFromString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectFromString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectFromString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectFromString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectFromString>::value != 
		function_uuid<(base_type)&Base::objectFromString>::value;
};


template <class, class, class, class = void>
struct playShineEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playShineEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playShineEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playShineEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playShineEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playShineEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playShineEffect>::value != 
		function_uuid<(base_type)&Base::playShineEffect>::value;
};


template <class, class, class, class = void>
struct quickUpdatePosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct quickUpdatePosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::quickUpdatePosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quickUpdatePosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::quickUpdatePosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quickUpdatePosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::quickUpdatePosition>::value != 
		function_uuid<(base_type)&Base::quickUpdatePosition>::value;
};


template <class, class, class, class = void>
struct removeGlow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeGlow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeGlow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeGlow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeGlow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeGlow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeGlow>::value != 
		function_uuid<(base_type)&Base::removeGlow>::value;
};


template <class, class, class, class = void>
struct resetGroupDisabled {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetGroupDisabled<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetGroupDisabled)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupDisabled))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetGroupDisabled));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetGroupDisabled));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetGroupDisabled>::value != 
		function_uuid<(base_type)&Base::resetGroupDisabled>::value;
};


template <class, class, class, class = void>
struct saveActiveColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveActiveColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveActiveColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveActiveColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveActiveColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveActiveColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveActiveColors>::value != 
		function_uuid<(base_type)&Base::saveActiveColors>::value;
};


template <class, class, class, class = void>
struct setDefaultMainColorMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDefaultMainColorMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDefaultMainColorMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDefaultMainColorMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDefaultMainColorMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDefaultMainColorMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDefaultMainColorMode>::value != 
		function_uuid<(base_type)&Base::setDefaultMainColorMode>::value;
};


template <class, class, class, class = void>
struct setDidUpdateLastPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setDidUpdateLastPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDidUpdateLastPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDidUpdateLastPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setDidUpdateLastPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setDidUpdateLastPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setDidUpdateLastPosition>::value != 
		function_uuid<(base_type)&Base::setDidUpdateLastPosition>::value;
};


template <class, class, class, class = void>
struct setGlowOpacity {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOpacity<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowOpacity)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOpacity))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowOpacity));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOpacity));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGlowOpacity>::value != 
		function_uuid<(base_type)&Base::setGlowOpacity>::value;
};


template <class, class, class, class = void>
struct setLastPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setLastPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLastPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLastPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setLastPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setLastPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setLastPosition>::value != 
		function_uuid<(base_type)&Base::setLastPosition>::value;
};


template <class, class, class, class = void>
struct setMainColorMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMainColorMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMainColorMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMainColorMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMainColorMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMainColorMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMainColorMode>::value != 
		function_uuid<(base_type)&Base::setMainColorMode>::value;
};


template <class, class, class, class = void>
struct setSectionIdx {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setSectionIdx<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSectionIdx)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSectionIdx))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setSectionIdx));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setSectionIdx));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setSectionIdx>::value != 
		function_uuid<(base_type)&Base::setSectionIdx>::value;
};


template <class, class, class, class = void>
struct setupCoinArt {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupCoinArt<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCoinArt)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCoinArt))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupCoinArt));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupCoinArt));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupCoinArt>::value != 
		function_uuid<(base_type)&Base::setupCoinArt>::value;
};


template <class, class, class, class = void>
struct slopeFloorTop {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct slopeFloorTop<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::slopeFloorTop)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeFloorTop))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::slopeFloorTop));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeFloorTop));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::slopeFloorTop>::value != 
		function_uuid<(base_type)&Base::slopeFloorTop>::value;
};


template <class, class, class, class = void>
struct slopeWallLeft {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct slopeWallLeft<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::slopeWallLeft)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeWallLeft))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::slopeWallLeft));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::slopeWallLeft));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::slopeWallLeft>::value != 
		function_uuid<(base_type)&Base::slopeWallLeft>::value;
};


template <class, class, class, class = void>
struct updateCustomScale {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCustomScale<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCustomScale)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCustomScale))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCustomScale));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCustomScale));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCustomScale>::value != 
		function_uuid<(base_type)&Base::updateCustomScale>::value;
};


template <class, class, class, class = void>
struct updateMainColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateMainColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateMainColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMainColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateMainColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMainColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateMainColor>::value != 
		function_uuid<(base_type)&Base::updateMainColor>::value;
};


template <class, class, class, class = void>
struct updateOrientedBox {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOrientedBox<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOrientedBox)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOrientedBox))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOrientedBox));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOrientedBox));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOrientedBox>::value != 
		function_uuid<(base_type)&Base::updateOrientedBox>::value;
};


template <class, class, class, class = void>
struct updateSecondaryColor {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSecondaryColor<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSecondaryColor)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSecondaryColor))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSecondaryColor));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSecondaryColor));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSecondaryColor>::value != 
		function_uuid<(base_type)&Base::updateSecondaryColor>::value;
};


template <class, class, class, class = void>
struct updateStartPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateStartPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStartPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStartPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStartPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateStartPos>::value != 
		function_uuid<(base_type)&Base::updateStartPos>::value;
};


template <class, class, class, class = void>
struct updateState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateState>::value != 
		function_uuid<(base_type)&Base::updateState>::value;
};


template <class, class, class, class = void>
struct updateSyncedAnimation {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateSyncedAnimation<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSyncedAnimation)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSyncedAnimation))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateSyncedAnimation));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateSyncedAnimation));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateSyncedAnimation>::value != 
		function_uuid<(base_type)&Base::updateSyncedAnimation>::value;
};


template <class, class, class, class = void>
struct deselectObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct deselectObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deselectObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::deselectObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::deselectObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::deselectObject>::value != 
		function_uuid<(base_type)&Base::deselectObject>::value;
};


template <class, class, class, class = void>
struct createRotateAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createRotateAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRotateAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createRotateAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createRotateAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createRotateAction>::value != 
		function_uuid<(base_type)&Base::createRotateAction>::value;
};


template <class, class, class, class = void>
struct setMyAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setMyAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMyAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMyAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setMyAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setMyAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setMyAction>::value != 
		function_uuid<(base_type)&Base::setMyAction>::value;
};


template <class, class, class, class = void>
struct awardCurrencyForLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct awardCurrencyForLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardCurrencyForLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardCurrencyForLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardCurrencyForLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardCurrencyForLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::awardCurrencyForLevel>::value != 
		function_uuid<(base_type)&Base::awardCurrencyForLevel>::value;
};


template <class, class, class, class = void>
struct awardDiamondsForLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct awardDiamondsForLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardDiamondsForLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardDiamondsForLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardDiamondsForLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardDiamondsForLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::awardDiamondsForLevel>::value != 
		function_uuid<(base_type)&Base::awardDiamondsForLevel>::value;
};


template <class, class, class, class = void>
struct awardSecretKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct awardSecretKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardSecretKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardSecretKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::awardSecretKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::awardSecretKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::awardSecretKey>::value != 
		function_uuid<(base_type)&Base::awardSecretKey>::value;
};


template <class, class, class, class = void>
struct getSecretCoinKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getSecretCoinKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecretCoinKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecretCoinKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getSecretCoinKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getSecretCoinKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getSecretCoinKey>::value != 
		function_uuid<(base_type)&Base::getSecretCoinKey>::value;
};


template <class, class, class, class = void>
struct getStat {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getStat<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStat)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStat))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getStat));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getStat));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getStat>::value != 
		function_uuid<(base_type)&Base::getStat>::value;
};


template <class, class, class, class = void>
struct hasPendingUserCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasPendingUserCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasPendingUserCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPendingUserCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasPendingUserCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasPendingUserCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasPendingUserCoin>::value != 
		function_uuid<(base_type)&Base::hasPendingUserCoin>::value;
};


template <class, class, class, class = void>
struct hasSecretCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasSecretCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasSecretCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecretCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasSecretCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasSecretCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasSecretCoin>::value != 
		function_uuid<(base_type)&Base::hasSecretCoin>::value;
};


template <class, class, class, class = void>
struct hasUserCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasUserCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasUserCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUserCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasUserCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUserCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasUserCoin>::value != 
		function_uuid<(base_type)&Base::hasUserCoin>::value;
};


template <class, class, class, class = void>
struct incrementStat {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct incrementStat<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementStat)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementStat))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::incrementStat));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::incrementStat));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::incrementStat>::value != 
		function_uuid<(base_type)&Base::incrementStat>::value;
};


template <class, class, class, class = void>
struct storePendingUserCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storePendingUserCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storePendingUserCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storePendingUserCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storePendingUserCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storePendingUserCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storePendingUserCoin>::value != 
		function_uuid<(base_type)&Base::storePendingUserCoin>::value;
};


template <class, class, class, class = void>
struct storeSecretCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storeSecretCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeSecretCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeSecretCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeSecretCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeSecretCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storeSecretCoin>::value != 
		function_uuid<(base_type)&Base::storeSecretCoin>::value;
};


template <class, class, class, class = void>
struct storeUserCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storeUserCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeUserCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeUserCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeUserCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeUserCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storeUserCoin>::value != 
		function_uuid<(base_type)&Base::storeUserCoin>::value;
};


template <class, class, class, class = void>
struct addPoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addPoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addPoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addPoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addPoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addPoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addPoint>::value != 
		function_uuid<(base_type)&Base::addPoint>::value;
};


template <class, class, class, class = void>
struct clearBehindXPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct clearBehindXPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clearBehindXPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearBehindXPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clearBehindXPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearBehindXPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::clearBehindXPos>::value != 
		function_uuid<(base_type)&Base::clearBehindXPos>::value;
};


template <class, class, class, class = void>
struct firstSetup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct firstSetup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::firstSetup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstSetup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::firstSetup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::firstSetup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::firstSetup>::value != 
		function_uuid<(base_type)&Base::firstSetup>::value;
};


template <class, class, class, class = void>
struct normalizeAngle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct normalizeAngle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::normalizeAngle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::normalizeAngle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::normalizeAngle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::normalizeAngle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::normalizeAngle>::value != 
		function_uuid<(base_type)&Base::normalizeAngle>::value;
};


template <class, class, class, class = void>
struct quadCornerOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct quadCornerOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::quadCornerOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quadCornerOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::quadCornerOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::quadCornerOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::quadCornerOffset>::value != 
		function_uuid<(base_type)&Base::quadCornerOffset>::value;
};


template <class, class, class, class = void>
struct updateStroke {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateStroke<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStroke)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStroke))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateStroke));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateStroke));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateStroke>::value != 
		function_uuid<(base_type)&Base::updateStroke>::value;
};


template <class, class, class, class = void>
struct onPrevPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onPrevPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPrevPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPrevPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onPrevPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onPrevPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onPrevPage>::value != 
		function_uuid<(base_type)&Base::onPrevPage>::value;
};


template <class, class, class, class = void>
struct onNextPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onNextPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onNextPage>::value != 
		function_uuid<(base_type)&Base::onNextPage>::value;
};


template <class, class, class, class = void>
struct goToPage {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct goToPage<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::goToPage)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::goToPage))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::goToPage));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::goToPage));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::goToPage>::value != 
		function_uuid<(base_type)&Base::goToPage>::value;
};


template <class, class, class, class = void>
struct downloadFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct downloadFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::downloadFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::downloadFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::downloadFinished>::value != 
		function_uuid<(base_type)&Base::downloadFinished>::value;
};


template <class, class, class, class = void>
struct downloadFailed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct downloadFailed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::downloadFailed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFailed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::downloadFailed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::downloadFailed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::downloadFailed>::value != 
		function_uuid<(base_type)&Base::downloadFailed>::value;
};


template <class, class, class, class = void>
struct timeForXPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::timeForXPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::timeForXPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::timeForXPos>::value != 
		function_uuid<(base_type)&Base::timeForXPos>::value;
};


template <class, class, class, class = void>
struct xPosForTime {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct xPosForTime<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::xPosForTime)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::xPosForTime))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::xPosForTime));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::xPosForTime));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::xPosForTime>::value != 
		function_uuid<(base_type)&Base::xPosForTime>::value;
};


template <class, class, class, class = void>
struct levelSettingsUpdated {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelSettingsUpdated<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelSettingsUpdated)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelSettingsUpdated))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelSettingsUpdated));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelSettingsUpdated));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelSettingsUpdated>::value != 
		function_uuid<(base_type)&Base::levelSettingsUpdated>::value;
};


template <class, class, class, class = void>
struct activateTriggerEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct activateTriggerEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateTriggerEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateTriggerEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::activateTriggerEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::activateTriggerEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::activateTriggerEffect>::value != 
		function_uuid<(base_type)&Base::activateTriggerEffect>::value;
};


template <class, class, class, class = void>
struct addObjectFromString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addObjectFromString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectFromString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectFromString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addObjectFromString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addObjectFromString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addObjectFromString>::value != 
		function_uuid<(base_type)&Base::addObjectFromString>::value;
};


template <class, class, class, class = void>
struct addSpecial {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addSpecial<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addSpecial)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpecial))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addSpecial));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addSpecial));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addSpecial>::value != 
		function_uuid<(base_type)&Base::addSpecial>::value;
};


template <class, class, class, class = void>
struct addToRedoList {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToRedoList<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToRedoList)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToRedoList))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToRedoList));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToRedoList));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToRedoList>::value != 
		function_uuid<(base_type)&Base::addToRedoList>::value;
};


template <class, class, class, class = void>
struct addToUndoList {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToUndoList<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToUndoList)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToUndoList))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToUndoList));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToUndoList));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToUndoList>::value != 
		function_uuid<(base_type)&Base::addToUndoList>::value;
};


template <class, class, class, class = void>
struct animateInDualGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animateInDualGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateInDualGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInDualGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateInDualGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInDualGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animateInDualGround>::value != 
		function_uuid<(base_type)&Base::animateInDualGround>::value;
};


template <class, class, class, class = void>
struct checkCollisions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct checkCollisions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkCollisions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkCollisions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::checkCollisions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::checkCollisions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::checkCollisions>::value != 
		function_uuid<(base_type)&Base::checkCollisions>::value;
};


template <class, class, class, class = void>
struct createBackground {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createBackground<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createBackground)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBackground))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createBackground));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createBackground));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createBackground>::value != 
		function_uuid<(base_type)&Base::createBackground>::value;
};


template <class, class, class, class = void>
struct createGroundLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createGroundLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createGroundLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createGroundLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createGroundLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createGroundLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createGroundLayer>::value != 
		function_uuid<(base_type)&Base::createGroundLayer>::value;
};


template <class, class, class, class = void>
struct createObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createObject>::value != 
		function_uuid<(base_type)&Base::createObject>::value;
};


template <class, class, class, class = void>
struct createObjectsFromSetup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromSetup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObjectsFromSetup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromSetup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObjectsFromSetup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromSetup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createObjectsFromSetup>::value != 
		function_uuid<(base_type)&Base::createObjectsFromSetup>::value;
};


template <class, class, class, class = void>
struct createObjectsFromString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createObjectsFromString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObjectsFromString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createObjectsFromString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createObjectsFromString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createObjectsFromString>::value != 
		function_uuid<(base_type)&Base::createObjectsFromString>::value;
};


template <class, class, class, class = void>
struct getLastObjectX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLastObjectX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastObjectX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastObjectX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastObjectX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastObjectX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLastObjectX>::value != 
		function_uuid<(base_type)&Base::getLastObjectX>::value;
};


template <class, class, class, class = void>
struct getLevelString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLevelString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLevelString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLevelString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLevelString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLevelString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLevelString>::value != 
		function_uuid<(base_type)&Base::getLevelString>::value;
};


template <class, class, class, class = void>
struct getNextColorChannel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNextColorChannel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextColorChannel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextColorChannel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextColorChannel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextColorChannel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNextColorChannel>::value != 
		function_uuid<(base_type)&Base::getNextColorChannel>::value;
};


template <class, class, class, class = void>
struct getNextFreeBlockID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeBlockID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeBlockID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeBlockID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeBlockID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeBlockID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNextFreeBlockID>::value != 
		function_uuid<(base_type)&Base::getNextFreeBlockID>::value;
};


template <class, class, class, class = void>
struct getNextFreeGroupID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeGroupID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeGroupID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeGroupID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeGroupID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeGroupID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNextFreeGroupID>::value != 
		function_uuid<(base_type)&Base::getNextFreeGroupID>::value;
};


template <class, class, class, class = void>
struct getNextFreeItemID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getNextFreeItemID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeItemID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeItemID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getNextFreeItemID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getNextFreeItemID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getNextFreeItemID>::value != 
		function_uuid<(base_type)&Base::getNextFreeItemID>::value;
};


template <class, class, class, class = void>
struct getRelativeOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRelativeOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRelativeOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRelativeOffset>::value != 
		function_uuid<(base_type)&Base::getRelativeOffset>::value;
};


template <class, class, class, class = void>
struct handleAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct handleAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handleAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::handleAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::handleAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::handleAction>::value != 
		function_uuid<(base_type)&Base::handleAction>::value;
};


template <class, class, class, class = void>
struct objectAtPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectAtPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectAtPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectAtPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectAtPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectAtPosition>::value != 
		function_uuid<(base_type)&Base::objectAtPosition>::value;
};


template <class, class, class, class = void>
struct objectMoved {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectMoved<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectMoved)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectMoved))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectMoved));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectMoved));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectMoved>::value != 
		function_uuid<(base_type)&Base::objectMoved>::value;
};


template <class, class, class, class = void>
struct objectsInRect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectsInRect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectsInRect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsInRect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectsInRect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectsInRect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectsInRect>::value != 
		function_uuid<(base_type)&Base::objectsInRect>::value;
};


template <class, class, class, class = void>
struct pasteAttributeState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pasteAttributeState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pasteAttributeState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteAttributeState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pasteAttributeState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pasteAttributeState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pasteAttributeState>::value != 
		function_uuid<(base_type)&Base::pasteAttributeState>::value;
};


template <class, class, class, class = void>
struct playMusic {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playMusic<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playMusic)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playMusic))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playMusic));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playMusic));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playMusic>::value != 
		function_uuid<(base_type)&Base::playMusic>::value;
};


template <class, class, class, class = void>
struct recreateGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct recreateGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::recreateGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recreateGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::recreateGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recreateGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::recreateGroups>::value != 
		function_uuid<(base_type)&Base::recreateGroups>::value;
};


template <class, class, class, class = void>
struct removeAllObjectsOfType {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeAllObjectsOfType<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllObjectsOfType)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjectsOfType))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeAllObjectsOfType));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeAllObjectsOfType));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeAllObjectsOfType>::value != 
		function_uuid<(base_type)&Base::removeAllObjectsOfType>::value;
};


template <class, class, class, class = void>
struct removeSpecial {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeSpecial<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeSpecial)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeSpecial))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeSpecial));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeSpecial));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeSpecial>::value != 
		function_uuid<(base_type)&Base::removeSpecial>::value;
};


template <class, class, class, class = void>
struct resetMovingObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetMovingObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMovingObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMovingObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetMovingObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetMovingObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetMovingObjects>::value != 
		function_uuid<(base_type)&Base::resetMovingObjects>::value;
};


template <class, class, class, class = void>
struct resetObjectVector {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetObjectVector<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetObjectVector)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObjectVector))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetObjectVector));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetObjectVector));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetObjectVector>::value != 
		function_uuid<(base_type)&Base::resetObjectVector>::value;
};


template <class, class, class, class = void>
struct resetToggledGroupsAndObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetToggledGroupsAndObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetToggledGroupsAndObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroupsAndObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetToggledGroupsAndObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetToggledGroupsAndObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetToggledGroupsAndObjects>::value != 
		function_uuid<(base_type)&Base::resetToggledGroupsAndObjects>::value;
};


template <class, class, class, class = void>
struct resetUnusedColorChannels {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetUnusedColorChannels<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetUnusedColorChannels)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetUnusedColorChannels))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetUnusedColorChannels));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetUnusedColorChannels));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetUnusedColorChannels>::value != 
		function_uuid<(base_type)&Base::resetUnusedColorChannels>::value;
};


template <class, class, class, class = void>
struct rotationForSlopeNearObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct rotationForSlopeNearObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rotationForSlopeNearObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotationForSlopeNearObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::rotationForSlopeNearObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::rotationForSlopeNearObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::rotationForSlopeNearObject>::value != 
		function_uuid<(base_type)&Base::rotationForSlopeNearObject>::value;
};


template <class, class, class, class = void>
struct runColorEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct runColorEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runColorEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runColorEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::runColorEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::runColorEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::runColorEffect>::value != 
		function_uuid<(base_type)&Base::runColorEffect>::value;
};


template <class, class, class, class = void>
struct setupLevelStart {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupLevelStart<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLevelStart)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelStart))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLevelStart));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLevelStart));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupLevelStart>::value != 
		function_uuid<(base_type)&Base::setupLevelStart>::value;
};


template <class, class, class, class = void>
struct sortStickyGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sortStickyGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortStickyGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortStickyGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortStickyGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortStickyGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sortStickyGroups>::value != 
		function_uuid<(base_type)&Base::sortStickyGroups>::value;
};


template <class, class, class, class = void>
struct stopTriggersInGroup {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopTriggersInGroup<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopTriggersInGroup)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopTriggersInGroup))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopTriggersInGroup));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopTriggersInGroup));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopTriggersInGroup>::value != 
		function_uuid<(base_type)&Base::stopTriggersInGroup>::value;
};


template <class, class, class, class = void>
struct toggleDualMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleDualMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleDualMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDualMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleDualMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleDualMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleDualMode>::value != 
		function_uuid<(base_type)&Base::toggleDualMode>::value;
};


template <class, class, class, class = void>
struct toggleGroupPreview {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGroupPreview<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroupPreview)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupPreview))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGroupPreview));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGroupPreview));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGroupPreview>::value != 
		function_uuid<(base_type)&Base::toggleGroupPreview>::value;
};


template <class, class, class, class = void>
struct transferDefaultColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct transferDefaultColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transferDefaultColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transferDefaultColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::transferDefaultColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::transferDefaultColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::transferDefaultColors>::value != 
		function_uuid<(base_type)&Base::transferDefaultColors>::value;
};


template <class, class, class, class = void>
struct updateBGAndGColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBGAndGColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGAndGColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGAndGColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBGAndGColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBGAndGColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBGAndGColors>::value != 
		function_uuid<(base_type)&Base::updateBGAndGColors>::value;
};


template <class, class, class, class = void>
struct updateBlendValues {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBlendValues<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlendValues)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendValues))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBlendValues));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBlendValues));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBlendValues>::value != 
		function_uuid<(base_type)&Base::updateBlendValues>::value;
};


template <class, class, class, class = void>
struct updateDualGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateDualGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDualGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDualGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateDualGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateDualGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateDualGround>::value != 
		function_uuid<(base_type)&Base::updateDualGround>::value;
};


template <class, class, class, class = void>
struct updateEditorMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateEditorMode>::value != 
		function_uuid<(base_type)&Base::updateEditorMode>::value;
};


template <class, class, class, class = void>
struct updateGameObjectsNew {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGameObjectsNew<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGameObjectsNew)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGameObjectsNew))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGameObjectsNew));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGameObjectsNew));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGameObjectsNew>::value != 
		function_uuid<(base_type)&Base::updateGameObjectsNew>::value;
};


template <class, class, class, class = void>
struct updateGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGround>::value != 
		function_uuid<(base_type)&Base::updateGround>::value;
};


template <class, class, class, class = void>
struct updateOptions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateOptions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOptions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOptions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateOptions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateOptions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateOptions>::value != 
		function_uuid<(base_type)&Base::updateOptions>::value;
};


template <class, class, class, class = void>
struct updateToggledGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateToggledGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateToggledGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateToggledGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateToggledGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateToggledGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateToggledGroups>::value != 
		function_uuid<(base_type)&Base::updateToggledGroups>::value;
};


template <class, class, class, class = void>
struct updateVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateVisibility>::value != 
		function_uuid<(base_type)&Base::updateVisibility>::value;
};


template <class, class, class, class = void>
struct onViewProfile {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onViewProfile<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onViewProfile)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onViewProfile))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onViewProfile));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onViewProfile));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onViewProfile>::value != 
		function_uuid<(base_type)&Base::onViewProfile>::value;
};


template <class, class, class, class = void>
struct objectFromDict {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct objectFromDict<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectFromDict)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromDict))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::objectFromDict));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::objectFromDict));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::objectFromDict>::value != 
		function_uuid<(base_type)&Base::objectFromDict>::value;
};


template <class, class, class, class = void>
struct setupColorsFromLegacyMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupColorsFromLegacyMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupColorsFromLegacyMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupColorsFromLegacyMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupColorsFromLegacyMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupColorsFromLegacyMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupColorsFromLegacyMode>::value != 
		function_uuid<(base_type)&Base::setupColorsFromLegacyMode>::value;
};


template <class, class, class, class = void>
struct willTweenToIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct willTweenToIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willTweenToIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willTweenToIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willTweenToIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willTweenToIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::willTweenToIndexPath>::value != 
		function_uuid<(base_type)&Base::willTweenToIndexPath>::value;
};


template <class, class, class, class = void>
struct didEndTweenToIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct didEndTweenToIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didEndTweenToIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didEndTweenToIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::didEndTweenToIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::didEndTweenToIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::didEndTweenToIndexPath>::value != 
		function_uuid<(base_type)&Base::didEndTweenToIndexPath>::value;
};


template <class, class, class, class = void>
struct TableViewDidDisplayCellForRowAtIndexPath {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct TableViewDidDisplayCellForRowAtIndexPath<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewDidDisplayCellForRowAtIndexPath)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewDidDisplayCellForRowAtIndexPath))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::TableViewDidDisplayCellForRowAtIndexPath));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::TableViewDidDisplayCellForRowAtIndexPath));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::TableViewDidDisplayCellForRowAtIndexPath>::value != 
		function_uuid<(base_type)&Base::TableViewDidDisplayCellForRowAtIndexPath>::value;
};


template <class, class, class, class = void>
struct setFromRefresh {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFromRefresh<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFromRefresh)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFromRefresh))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFromRefresh));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFromRefresh));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFromRefresh>::value != 
		function_uuid<(base_type)&Base::setFromRefresh>::value;
};


template <class, class, class, class = void>
struct getLoadingString {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLoadingString<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLoadingString)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadingString))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLoadingString));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLoadingString));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLoadingString>::value != 
		function_uuid<(base_type)&Base::getLoadingString>::value;
};


template <class, class, class, class = void>
struct loadAssets {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadAssets<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadAssets)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadAssets))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadAssets));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadAssets));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadAssets>::value != 
		function_uuid<(base_type)&Base::loadAssets>::value;
};


template <class, class, class, class = void>
struct loadingFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadingFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadingFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadingFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadingFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadingFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadingFinished>::value != 
		function_uuid<(base_type)&Base::loadingFinished>::value;
};


template <class, class, class, class = void>
struct resetPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetPlayer>::value != 
		function_uuid<(base_type)&Base::resetPlayer>::value;
};


template <class, class, class, class = void>
struct addToggle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToggle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToggle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToggle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToggle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToggle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToggle>::value != 
		function_uuid<(base_type)&Base::addToggle>::value;
};


template <class, class, class, class = void>
struct onKeybindings {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onKeybindings<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onKeybindings)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onKeybindings))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onKeybindings));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onKeybindings));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onKeybindings>::value != 
		function_uuid<(base_type)&Base::onKeybindings>::value;
};


template <class, class, class, class = void>
struct frameToKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct frameToKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::frameToKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::frameToKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::frameToKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::frameToKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::frameToKey>::value != 
		function_uuid<(base_type)&Base::frameToKey>::value;
};


template <class, class, class, class = void>
struct intKeyToFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct intKeyToFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::intKeyToFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intKeyToFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::intKeyToFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::intKeyToFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::intKeyToFrame>::value != 
		function_uuid<(base_type)&Base::intKeyToFrame>::value;
};


template <class, class, class, class = void>
struct keyToFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct keyToFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyToFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::keyToFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::keyToFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::keyToFrame>::value != 
		function_uuid<(base_type)&Base::keyToFrame>::value;
};


template <class, class, class, class = void>
struct gridNodeSizeForKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct gridNodeSizeForKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gridNodeSizeForKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gridNodeSizeForKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gridNodeSizeForKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gridNodeSizeForKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::gridNodeSizeForKey>::value != 
		function_uuid<(base_type)&Base::gridNodeSizeForKey>::value;
};


template <class, class, class, class = void>
struct perspectiveBlockFrame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct perspectiveBlockFrame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::perspectiveBlockFrame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::perspectiveBlockFrame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::perspectiveBlockFrame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::perspectiveBlockFrame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::perspectiveBlockFrame>::value != 
		function_uuid<(base_type)&Base::perspectiveBlockFrame>::value;
};


template <class, class, class, class = void>
struct step {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct step<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::step)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::step))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::step));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::step));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::step>::value != 
		function_uuid<(base_type)&Base::step>::value;
};


template <class, class, class, class = void>
struct addToCurrentScene {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToCurrentScene<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToCurrentScene)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToCurrentScene))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToCurrentScene));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToCurrentScene));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToCurrentScene>::value != 
		function_uuid<(base_type)&Base::addToCurrentScene>::value;
};


template <class, class, class, class = void>
struct addCircle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addCircle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addCircle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addCircle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addCircle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addCircle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addCircle>::value != 
		function_uuid<(base_type)&Base::addCircle>::value;
};


template <class, class, class, class = void>
struct addToGroupOld {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToGroupOld<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroupOld)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroupOld))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToGroupOld));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToGroupOld));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToGroupOld>::value != 
		function_uuid<(base_type)&Base::addToGroupOld>::value;
};


template <class, class, class, class = void>
struct addToSpeedObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct addToSpeedObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToSpeedObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSpeedObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::addToSpeedObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::addToSpeedObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::addToSpeedObjects>::value != 
		function_uuid<(base_type)&Base::addToSpeedObjects>::value;
};


template <class, class, class, class = void>
struct animateInGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animateInGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateInGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateInGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateInGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animateInGround>::value != 
		function_uuid<(base_type)&Base::animateInGround>::value;
};


template <class, class, class, class = void>
struct animateOutGround {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGround<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateOutGround)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGround))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateOutGround));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGround));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animateOutGround>::value != 
		function_uuid<(base_type)&Base::animateOutGround>::value;
};


template <class, class, class, class = void>
struct animateOutGroundFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct animateOutGroundFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateOutGroundFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGroundFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::animateOutGroundFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::animateOutGroundFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::animateOutGroundFinished>::value != 
		function_uuid<(base_type)&Base::animateOutGroundFinished>::value;
};


template <class, class, class, class = void>
struct applyEnterEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct applyEnterEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applyEnterEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applyEnterEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::applyEnterEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::applyEnterEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::applyEnterEffect>::value != 
		function_uuid<(base_type)&Base::applyEnterEffect>::value;
};


template <class, class, class, class = void>
struct cameraMoveX {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveX<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cameraMoveX)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveX))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cameraMoveX));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveX));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::cameraMoveX>::value != 
		function_uuid<(base_type)&Base::cameraMoveX>::value;
};


template <class, class, class, class = void>
struct cameraMoveY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct cameraMoveY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cameraMoveY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::cameraMoveY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::cameraMoveY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::cameraMoveY>::value != 
		function_uuid<(base_type)&Base::cameraMoveY>::value;
};


template <class, class, class, class = void>
struct claimParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct claimParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::claimParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::claimParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::claimParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::claimParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::claimParticle>::value != 
		function_uuid<(base_type)&Base::claimParticle>::value;
};


template <class, class, class, class = void>
struct clearPickedUpItems {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct clearPickedUpItems<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clearPickedUpItems)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearPickedUpItems))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::clearPickedUpItems));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::clearPickedUpItems));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::clearPickedUpItems>::value != 
		function_uuid<(base_type)&Base::clearPickedUpItems>::value;
};


template <class, class, class, class = void>
struct colorObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct colorObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::colorObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::colorObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::colorObject>::value != 
		function_uuid<(base_type)&Base::colorObject>::value;
};


template <class, class, class, class = void>
struct commitJumps {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct commitJumps<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::commitJumps)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commitJumps))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::commitJumps));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::commitJumps));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::commitJumps>::value != 
		function_uuid<(base_type)&Base::commitJumps>::value;
};


template <class, class, class, class = void>
struct createCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createCheckpoint>::value != 
		function_uuid<(base_type)&Base::createCheckpoint>::value;
};


template <class, class, class, class = void>
struct createParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createParticle>::value != 
		function_uuid<(base_type)&Base::createParticle>::value;
};


template <class, class, class, class = void>
struct delayedResetLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct delayedResetLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::delayedResetLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::delayedResetLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::delayedResetLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::delayedResetLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::delayedResetLevel>::value != 
		function_uuid<(base_type)&Base::delayedResetLevel>::value;
};


template <class, class, class, class = void>
struct destroyPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct destroyPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::destroyPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::destroyPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::destroyPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::destroyPlayer>::value != 
		function_uuid<(base_type)&Base::destroyPlayer>::value;
};


template <class, class, class, class = void>
struct enterDualMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enterDualMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterDualMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterDualMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enterDualMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enterDualMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enterDualMode>::value != 
		function_uuid<(base_type)&Base::enterDualMode>::value;
};


template <class, class, class, class = void>
struct exitAirMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitAirMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitAirMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitAirMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitAirMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitAirMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitAirMode>::value != 
		function_uuid<(base_type)&Base::exitAirMode>::value;
};


template <class, class, class, class = void>
struct exitBirdMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitBirdMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitBirdMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitBirdMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitBirdMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitBirdMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitBirdMode>::value != 
		function_uuid<(base_type)&Base::exitBirdMode>::value;
};


template <class, class, class, class = void>
struct exitDartMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitDartMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitDartMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitDartMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitDartMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitDartMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitDartMode>::value != 
		function_uuid<(base_type)&Base::exitDartMode>::value;
};


template <class, class, class, class = void>
struct exitFlyMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitFlyMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitFlyMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitFlyMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitFlyMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitFlyMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitFlyMode>::value != 
		function_uuid<(base_type)&Base::exitFlyMode>::value;
};


template <class, class, class, class = void>
struct exitRobotMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitRobotMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitRobotMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRobotMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitRobotMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRobotMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitRobotMode>::value != 
		function_uuid<(base_type)&Base::exitRobotMode>::value;
};


template <class, class, class, class = void>
struct exitRollMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitRollMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitRollMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRollMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitRollMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitRollMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitRollMode>::value != 
		function_uuid<(base_type)&Base::exitRollMode>::value;
};


template <class, class, class, class = void>
struct exitSpiderMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct exitSpiderMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitSpiderMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitSpiderMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::exitSpiderMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::exitSpiderMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::exitSpiderMode>::value != 
		function_uuid<(base_type)&Base::exitSpiderMode>::value;
};


template <class, class, class, class = void>
struct flipFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct flipFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::flipFinished>::value != 
		function_uuid<(base_type)&Base::flipFinished>::value;
};


template <class, class, class, class = void>
struct flipObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct flipObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::flipObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::flipObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::flipObjects>::value != 
		function_uuid<(base_type)&Base::flipObjects>::value;
};


template <class, class, class, class = void>
struct fullReset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct fullReset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fullReset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fullReset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::fullReset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::fullReset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::fullReset>::value != 
		function_uuid<(base_type)&Base::fullReset>::value;
};


template <class, class, class, class = void>
struct getLastCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getLastCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getLastCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getLastCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getLastCheckpoint>::value != 
		function_uuid<(base_type)&Base::getLastCheckpoint>::value;
};


template <class, class, class, class = void>
struct getMaxPortalY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMaxPortalY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxPortalY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxPortalY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMaxPortalY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMaxPortalY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMaxPortalY>::value != 
		function_uuid<(base_type)&Base::getMaxPortalY>::value;
};


template <class, class, class, class = void>
struct getMinPortalY {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getMinPortalY<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMinPortalY)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinPortalY))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getMinPortalY));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getMinPortalY));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getMinPortalY>::value != 
		function_uuid<(base_type)&Base::getMinPortalY>::value;
};


template <class, class, class, class = void>
struct getObjectsState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getObjectsState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectsState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectsState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getObjectsState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getObjectsState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getObjectsState>::value != 
		function_uuid<(base_type)&Base::getObjectsState>::value;
};


template <class, class, class, class = void>
struct getOtherPlayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getOtherPlayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOtherPlayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOtherPlayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getOtherPlayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getOtherPlayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getOtherPlayer>::value != 
		function_uuid<(base_type)&Base::getOtherPlayer>::value;
};


template <class, class, class, class = void>
struct getParticleKey {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParticleKey)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParticleKey));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getParticleKey>::value != 
		function_uuid<(base_type)&Base::getParticleKey>::value;
};


template <class, class, class, class = void>
struct getParticleKey2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getParticleKey2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParticleKey2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getParticleKey2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getParticleKey2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getParticleKey2>::value != 
		function_uuid<(base_type)&Base::getParticleKey2>::value;
};


template <class, class, class, class = void>
struct getRelativeMod {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getRelativeMod<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRelativeMod)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeMod))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getRelativeMod));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getRelativeMod));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getRelativeMod>::value != 
		function_uuid<(base_type)&Base::getRelativeMod>::value;
};


template <class, class, class, class = void>
struct getTempMilliTime {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getTempMilliTime<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTempMilliTime)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTempMilliTime))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getTempMilliTime));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getTempMilliTime));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getTempMilliTime>::value != 
		function_uuid<(base_type)&Base::getTempMilliTime>::value;
};


template <class, class, class, class = void>
struct gravityEffectFinished {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct gravityEffectFinished<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityEffectFinished)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityEffectFinished))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::gravityEffectFinished));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::gravityEffectFinished));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::gravityEffectFinished>::value != 
		function_uuid<(base_type)&Base::gravityEffectFinished>::value;
};


template <class, class, class, class = void>
struct hasItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasItem>::value != 
		function_uuid<(base_type)&Base::hasItem>::value;
};


template <class, class, class, class = void>
struct hasUniqueCoin {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasUniqueCoin<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasUniqueCoin)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUniqueCoin))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasUniqueCoin));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasUniqueCoin));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasUniqueCoin>::value != 
		function_uuid<(base_type)&Base::hasUniqueCoin>::value;
};


template <class, class, class, class = void>
struct isFlipping {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct isFlipping<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipping)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipping))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::isFlipping));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::isFlipping));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::isFlipping>::value != 
		function_uuid<(base_type)&Base::isFlipping>::value;
};


template <class, class, class, class = void>
struct levelComplete {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct levelComplete<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelComplete)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelComplete))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::levelComplete));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::levelComplete));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::levelComplete>::value != 
		function_uuid<(base_type)&Base::levelComplete>::value;
};


template <class, class, class, class = void>
struct lightningFlash {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct lightningFlash<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lightningFlash)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lightningFlash))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::lightningFlash));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::lightningFlash));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::lightningFlash>::value != 
		function_uuid<(base_type)&Base::lightningFlash>::value;
};


template <class, class, class, class = void>
struct loadDefaultColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadDefaultColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadDefaultColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDefaultColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadDefaultColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadDefaultColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadDefaultColors>::value != 
		function_uuid<(base_type)&Base::loadDefaultColors>::value;
};


template <class, class, class, class = void>
struct loadLastCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadLastCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadLastCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadLastCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadLastCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadLastCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadLastCheckpoint>::value != 
		function_uuid<(base_type)&Base::loadLastCheckpoint>::value;
};


template <class, class, class, class = void>
struct loadSavedObjectsState {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct loadSavedObjectsState<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadSavedObjectsState)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSavedObjectsState))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::loadSavedObjectsState));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::loadSavedObjectsState));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::loadSavedObjectsState>::value != 
		function_uuid<(base_type)&Base::loadSavedObjectsState>::value;
};


template <class, class, class, class = void>
struct markCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct markCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::markCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::markCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::markCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::markCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::markCheckpoint>::value != 
		function_uuid<(base_type)&Base::markCheckpoint>::value;
};


template <class, class, class, class = void>
struct moveCameraToPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct moveCameraToPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveCameraToPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveCameraToPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::moveCameraToPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::moveCameraToPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::moveCameraToPos>::value != 
		function_uuid<(base_type)&Base::moveCameraToPos>::value;
};


template <class, class, class, class = void>
struct optimizeColorGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct optimizeColorGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeColorGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeColorGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeColorGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeColorGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::optimizeColorGroups>::value != 
		function_uuid<(base_type)&Base::optimizeColorGroups>::value;
};


template <class, class, class, class = void>
struct optimizeOpacityGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct optimizeOpacityGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeOpacityGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeOpacityGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeOpacityGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeOpacityGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::optimizeOpacityGroups>::value != 
		function_uuid<(base_type)&Base::optimizeOpacityGroups>::value;
};


template <class, class, class, class = void>
struct optimizeSaveRequiredGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct optimizeSaveRequiredGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeSaveRequiredGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeSaveRequiredGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::optimizeSaveRequiredGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::optimizeSaveRequiredGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::optimizeSaveRequiredGroups>::value != 
		function_uuid<(base_type)&Base::optimizeSaveRequiredGroups>::value;
};


template <class, class, class, class = void>
struct pauseGame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pauseGame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pauseGame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseGame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pauseGame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pauseGame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pauseGame>::value != 
		function_uuid<(base_type)&Base::pauseGame>::value;
};


template <class, class, class, class = void>
struct pickupItem {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pickupItem<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pickupItem)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pickupItem))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pickupItem));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pickupItem));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pickupItem>::value != 
		function_uuid<(base_type)&Base::pickupItem>::value;
};


template <class, class, class, class = void>
struct playAnimationCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playAnimationCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playAnimationCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimationCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playAnimationCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playAnimationCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playAnimationCommand>::value != 
		function_uuid<(base_type)&Base::playAnimationCommand>::value;
};


template <class, class, class, class = void>
struct playEndAnimationToPos {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playEndAnimationToPos<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playEndAnimationToPos)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEndAnimationToPos))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playEndAnimationToPos));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playEndAnimationToPos));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playEndAnimationToPos>::value != 
		function_uuid<(base_type)&Base::playEndAnimationToPos>::value;
};


template <class, class, class, class = void>
struct playExitDualEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playExitDualEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playExitDualEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playExitDualEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playExitDualEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playExitDualEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playExitDualEffect>::value != 
		function_uuid<(base_type)&Base::playExitDualEffect>::value;
};


template <class, class, class, class = void>
struct playFlashEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playFlashEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playFlashEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playFlashEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playFlashEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playFlashEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playFlashEffect>::value != 
		function_uuid<(base_type)&Base::playFlashEffect>::value;
};


template <class, class, class, class = void>
struct playGravityEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playGravityEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playGravityEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playGravityEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playGravityEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playGravityEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playGravityEffect>::value != 
		function_uuid<(base_type)&Base::playGravityEffect>::value;
};


template <class, class, class, class = void>
struct playSpeedParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playSpeedParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playSpeedParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playSpeedParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playSpeedParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playSpeedParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playSpeedParticle>::value != 
		function_uuid<(base_type)&Base::playSpeedParticle>::value;
};


template <class, class, class, class = void>
struct playerWillSwitchMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct playerWillSwitchMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerWillSwitchMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerWillSwitchMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::playerWillSwitchMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::playerWillSwitchMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::playerWillSwitchMode>::value != 
		function_uuid<(base_type)&Base::playerWillSwitchMode>::value;
};


template <class, class, class, class = void>
struct prepareSpawnObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct prepareSpawnObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::prepareSpawnObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareSpawnObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::prepareSpawnObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::prepareSpawnObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::prepareSpawnObjects>::value != 
		function_uuid<(base_type)&Base::prepareSpawnObjects>::value;
};


template <class, class, class, class = void>
struct processItems {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processItems<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processItems)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processItems))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processItems));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processItems));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processItems>::value != 
		function_uuid<(base_type)&Base::processItems>::value;
};


template <class, class, class, class = void>
struct processLoadedMoveActions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct processLoadedMoveActions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processLoadedMoveActions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processLoadedMoveActions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::processLoadedMoveActions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::processLoadedMoveActions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::processLoadedMoveActions>::value != 
		function_uuid<(base_type)&Base::processLoadedMoveActions>::value;
};


template <class, class, class, class = void>
struct recordAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct recordAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::recordAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recordAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::recordAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::recordAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::recordAction>::value != 
		function_uuid<(base_type)&Base::recordAction>::value;
};


template <class, class, class, class = void>
struct registerActiveObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerActiveObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerActiveObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerActiveObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerActiveObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerActiveObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerActiveObject>::value != 
		function_uuid<(base_type)&Base::registerActiveObject>::value;
};


template <class, class, class, class = void>
struct registerStateObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct registerStateObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerStateObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerStateObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::registerStateObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::registerStateObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::registerStateObject>::value != 
		function_uuid<(base_type)&Base::registerStateObject>::value;
};


template <class, class, class, class = void>
struct removeFromGroupOld {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeFromGroupOld<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroupOld)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroupOld))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeFromGroupOld));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeFromGroupOld));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeFromGroupOld>::value != 
		function_uuid<(base_type)&Base::removeFromGroupOld>::value;
};


template <class, class, class, class = void>
struct removeLastCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removeLastCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeLastCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removeLastCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removeLastCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removeLastCheckpoint>::value != 
		function_uuid<(base_type)&Base::removeLastCheckpoint>::value;
};


template <class, class, class, class = void>
struct removePlayer2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct removePlayer2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removePlayer2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePlayer2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::removePlayer2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::removePlayer2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::removePlayer2>::value != 
		function_uuid<(base_type)&Base::removePlayer2>::value;
};


template <class, class, class, class = void>
struct resetLevel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resetLevel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetLevel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetLevel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resetLevel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resetLevel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resetLevel>::value != 
		function_uuid<(base_type)&Base::resetLevel>::value;
};


template <class, class, class, class = void>
struct resume {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resume<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resume)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resume))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resume));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resume));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resume>::value != 
		function_uuid<(base_type)&Base::resume>::value;
};


template <class, class, class, class = void>
struct resumeAndRestart {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct resumeAndRestart<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeAndRestart)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeAndRestart))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::resumeAndRestart));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::resumeAndRestart));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::resumeAndRestart>::value != 
		function_uuid<(base_type)&Base::resumeAndRestart>::value;
};


template <class, class, class, class = void>
struct saveRecordAction {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct saveRecordAction<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveRecordAction)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveRecordAction))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::saveRecordAction));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::saveRecordAction));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::saveRecordAction>::value != 
		function_uuid<(base_type)&Base::saveRecordAction>::value;
};


template <class, class, class, class = void>
struct setupReplay {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupReplay<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupReplay)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupReplay))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupReplay));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupReplay));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupReplay>::value != 
		function_uuid<(base_type)&Base::setupReplay>::value;
};


template <class, class, class, class = void>
struct shakeCamera {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct shakeCamera<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shakeCamera)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shakeCamera))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::shakeCamera));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::shakeCamera));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::shakeCamera>::value != 
		function_uuid<(base_type)&Base::shakeCamera>::value;
};


template <class, class, class, class = void>
struct showCompleteEffect {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteEffect<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCompleteEffect)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteEffect))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCompleteEffect));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteEffect));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showCompleteEffect>::value != 
		function_uuid<(base_type)&Base::showCompleteEffect>::value;
};


template <class, class, class, class = void>
struct showCompleteText {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showCompleteText<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCompleteText)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteText))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showCompleteText));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showCompleteText));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showCompleteText>::value != 
		function_uuid<(base_type)&Base::showCompleteText>::value;
};


template <class, class, class, class = void>
struct showEndLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showEndLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showEndLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showEndLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showEndLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showEndLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showEndLayer>::value != 
		function_uuid<(base_type)&Base::showEndLayer>::value;
};


template <class, class, class, class = void>
struct showHint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showHint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showHint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showHint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showHint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showHint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showHint>::value != 
		function_uuid<(base_type)&Base::showHint>::value;
};


template <class, class, class, class = void>
struct showNewBest {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showNewBest<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showNewBest)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNewBest))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showNewBest));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showNewBest));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showNewBest>::value != 
		function_uuid<(base_type)&Base::showNewBest>::value;
};


template <class, class, class, class = void>
struct showRetryLayer {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showRetryLayer<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showRetryLayer)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showRetryLayer))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showRetryLayer));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showRetryLayer));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showRetryLayer>::value != 
		function_uuid<(base_type)&Base::showRetryLayer>::value;
};


template <class, class, class, class = void>
struct showTwoPlayerGuide {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct showTwoPlayerGuide<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showTwoPlayerGuide)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showTwoPlayerGuide))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::showTwoPlayerGuide));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::showTwoPlayerGuide));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::showTwoPlayerGuide>::value != 
		function_uuid<(base_type)&Base::showTwoPlayerGuide>::value;
};


template <class, class, class, class = void>
struct sortGroups {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct sortGroups<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortGroups)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortGroups))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::sortGroups));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::sortGroups));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::sortGroups>::value != 
		function_uuid<(base_type)&Base::sortGroups>::value;
};


template <class, class, class, class = void>
struct spawnFirework {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnFirework<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnFirework)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFirework))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnFirework));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnFirework));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnFirework>::value != 
		function_uuid<(base_type)&Base::spawnFirework>::value;
};


template <class, class, class, class = void>
struct spawnParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnParticle>::value != 
		function_uuid<(base_type)&Base::spawnParticle>::value;
};


template <class, class, class, class = void>
struct spawnPlayer2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct spawnPlayer2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnPlayer2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPlayer2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::spawnPlayer2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::spawnPlayer2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::spawnPlayer2>::value != 
		function_uuid<(base_type)&Base::spawnPlayer2>::value;
};


template <class, class, class, class = void>
struct startGame {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startGame<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startGame)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startGame))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startGame));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startGame));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startGame>::value != 
		function_uuid<(base_type)&Base::startGame>::value;
};


template <class, class, class, class = void>
struct startMusic {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startMusic<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startMusic)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startMusic))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startMusic));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startMusic));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startMusic>::value != 
		function_uuid<(base_type)&Base::startMusic>::value;
};


template <class, class, class, class = void>
struct startRecording {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startRecording<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startRecording)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecording))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startRecording));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecording));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startRecording>::value != 
		function_uuid<(base_type)&Base::startRecording>::value;
};


template <class, class, class, class = void>
struct startRecordingDelayed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct startRecordingDelayed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startRecordingDelayed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecordingDelayed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::startRecordingDelayed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::startRecordingDelayed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::startRecordingDelayed>::value != 
		function_uuid<(base_type)&Base::startRecordingDelayed>::value;
};


template <class, class, class, class = void>
struct stopCameraShake {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopCameraShake<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopCameraShake)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopCameraShake))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopCameraShake));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopCameraShake));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopCameraShake>::value != 
		function_uuid<(base_type)&Base::stopCameraShake>::value;
};


template <class, class, class, class = void>
struct stopRecording {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct stopRecording<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopRecording)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRecording))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::stopRecording));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::stopRecording));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::stopRecording>::value != 
		function_uuid<(base_type)&Base::stopRecording>::value;
};


template <class, class, class, class = void>
struct storeCheckpoint {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct storeCheckpoint<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeCheckpoint)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCheckpoint))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::storeCheckpoint));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::storeCheckpoint));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::storeCheckpoint>::value != 
		function_uuid<(base_type)&Base::storeCheckpoint>::value;
};


template <class, class, class, class = void>
struct switchToFlyMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct switchToFlyMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToFlyMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToFlyMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToFlyMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToFlyMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::switchToFlyMode>::value != 
		function_uuid<(base_type)&Base::switchToFlyMode>::value;
};


template <class, class, class, class = void>
struct switchToRobotMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct switchToRobotMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToRobotMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRobotMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToRobotMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRobotMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::switchToRobotMode>::value != 
		function_uuid<(base_type)&Base::switchToRobotMode>::value;
};


template <class, class, class, class = void>
struct switchToRollMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct switchToRollMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToRollMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRollMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToRollMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToRollMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::switchToRollMode>::value != 
		function_uuid<(base_type)&Base::switchToRollMode>::value;
};


template <class, class, class, class = void>
struct switchToSpiderMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct switchToSpiderMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToSpiderMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToSpiderMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::switchToSpiderMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::switchToSpiderMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::switchToSpiderMode>::value != 
		function_uuid<(base_type)&Base::switchToSpiderMode>::value;
};


template <class, class, class, class = void>
struct timeForXPos2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct timeForXPos2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::timeForXPos2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::timeForXPos2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::timeForXPos2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::timeForXPos2>::value != 
		function_uuid<(base_type)&Base::timeForXPos2>::value;
};


template <class, class, class, class = void>
struct toggleBGEffectVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleBGEffectVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleBGEffectVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBGEffectVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleBGEffectVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleBGEffectVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleBGEffectVisibility>::value != 
		function_uuid<(base_type)&Base::toggleBGEffectVisibility>::value;
};


template <class, class, class, class = void>
struct toggleFlipped {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleFlipped<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFlipped)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlipped))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleFlipped));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleFlipped));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleFlipped>::value != 
		function_uuid<(base_type)&Base::toggleFlipped>::value;
};


template <class, class, class, class = void>
struct toggleGlitter {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleGlitter<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGlitter)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGlitter))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleGlitter));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleGlitter));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleGlitter>::value != 
		function_uuid<(base_type)&Base::toggleGlitter>::value;
};


template <class, class, class, class = void>
struct togglePracticeMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct togglePracticeMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePracticeMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePracticeMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::togglePracticeMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::togglePracticeMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::togglePracticeMode>::value != 
		function_uuid<(base_type)&Base::togglePracticeMode>::value;
};


template <class, class, class, class = void>
struct toggleProgressbar {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleProgressbar<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleProgressbar)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleProgressbar))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleProgressbar));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleProgressbar));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleProgressbar>::value != 
		function_uuid<(base_type)&Base::toggleProgressbar>::value;
};


template <class, class, class, class = void>
struct tryStartRecord {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct tryStartRecord<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tryStartRecord)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryStartRecord))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::tryStartRecord));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::tryStartRecord));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::tryStartRecord>::value != 
		function_uuid<(base_type)&Base::tryStartRecord>::value;
};


template <class, class, class, class = void>
struct unclaimParticle {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unclaimParticle<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unclaimParticle)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unclaimParticle))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unclaimParticle));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unclaimParticle));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unclaimParticle>::value != 
		function_uuid<(base_type)&Base::unclaimParticle>::value;
};


template <class, class, class, class = void>
struct unregisterActiveObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unregisterActiveObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterActiveObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterActiveObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterActiveObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterActiveObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unregisterActiveObject>::value != 
		function_uuid<(base_type)&Base::unregisterActiveObject>::value;
};


template <class, class, class, class = void>
struct unregisterStateObject {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct unregisterStateObject<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterStateObject)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterStateObject))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::unregisterStateObject));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::unregisterStateObject));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::unregisterStateObject>::value != 
		function_uuid<(base_type)&Base::unregisterStateObject>::value;
};


template <class, class, class, class = void>
struct updateAttempts {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateAttempts<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateAttempts)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateAttempts))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateAttempts));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateAttempts));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateAttempts>::value != 
		function_uuid<(base_type)&Base::updateAttempts>::value;
};


template <class, class, class, class = void>
struct updateCamera {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateCamera<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCamera)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCamera))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateCamera));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateCamera));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateCamera>::value != 
		function_uuid<(base_type)&Base::updateCamera>::value;
};


template <class, class, class, class = void>
struct updateEffectPositions {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateEffectPositions<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEffectPositions)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffectPositions))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEffectPositions));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEffectPositions));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateEffectPositions>::value != 
		function_uuid<(base_type)&Base::updateEffectPositions>::value;
};


template <class, class, class, class = void>
struct updateLevelColors {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateLevelColors<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLevelColors)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLevelColors))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateLevelColors));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateLevelColors));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateLevelColors>::value != 
		function_uuid<(base_type)&Base::updateLevelColors>::value;
};


template <class, class, class, class = void>
struct updateMoveObjectsLastPosition {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateMoveObjectsLastPosition<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateMoveObjectsLastPosition)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMoveObjectsLastPosition))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateMoveObjectsLastPosition));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateMoveObjectsLastPosition));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateMoveObjectsLastPosition>::value != 
		function_uuid<(base_type)&Base::updateMoveObjectsLastPosition>::value;
};


template <class, class, class, class = void>
struct updateProgressbar {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateProgressbar<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateProgressbar)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateProgressbar))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateProgressbar));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateProgressbar));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateProgressbar>::value != 
		function_uuid<(base_type)&Base::updateProgressbar>::value;
};


template <class, class, class, class = void>
struct updateReplay {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateReplay<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateReplay)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateReplay))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateReplay));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateReplay));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateReplay>::value != 
		function_uuid<(base_type)&Base::updateReplay>::value;
};


template <class, class, class, class = void>
struct vfDChk {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct vfDChk<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::vfDChk)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::vfDChk))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::vfDChk));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::vfDChk));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::vfDChk>::value != 
		function_uuid<(base_type)&Base::vfDChk>::value;
};


template <class, class, class, class = void>
struct visitWithColorFlash {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct visitWithColorFlash<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::visitWithColorFlash)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visitWithColorFlash))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::visitWithColorFlash));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::visitWithColorFlash));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::visitWithColorFlash>::value != 
		function_uuid<(base_type)&Base::visitWithColorFlash>::value;
};


template <class, class, class, class = void>
struct willSwitchToMode {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct willSwitchToMode<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willSwitchToMode)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToMode))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::willSwitchToMode));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::willSwitchToMode));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::willSwitchToMode>::value != 
		function_uuid<(base_type)&Base::willSwitchToMode>::value;
};


template <class, class, class, class = void>
struct onNextGroupID1 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onNextGroupID1<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextGroupID1)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextGroupID1))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onNextGroupID1));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onNextGroupID1));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onNextGroupID1>::value != 
		function_uuid<(base_type)&Base::onNextGroupID1>::value;
};


template <class, class, class, class = void>
struct updateGroupIDLabel {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateGroupIDLabel<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGroupIDLabel)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroupIDLabel))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateGroupIDLabel));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateGroupIDLabel));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateGroupIDLabel>::value != 
		function_uuid<(base_type)&Base::updateGroupIDLabel>::value;
};


template <class, class, class, class = void>
struct updateEditorLayerID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorLayerID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorLayerID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateEditorLayerID>::value != 
		function_uuid<(base_type)&Base::updateEditorLayerID>::value;
};


template <class, class, class, class = void>
struct updateEditorLayerID2 {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateEditorLayerID2<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorLayerID2)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID2))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateEditorLayerID2));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateEditorLayerID2));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateEditorLayerID2>::value != 
		function_uuid<(base_type)&Base::updateEditorLayerID2>::value;
};


template <class, class, class, class = void>
struct updateZOrder {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateZOrder<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateZOrder)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZOrder))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateZOrder));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateZOrder));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateZOrder>::value != 
		function_uuid<(base_type)&Base::updateZOrder>::value;
};


template <class, class, class, class = void>
struct onItemIDArrow {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onItemIDArrow<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onItemIDArrow)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onItemIDArrow))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onItemIDArrow));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onItemIDArrow));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onItemIDArrow>::value != 
		function_uuid<(base_type)&Base::onItemIDArrow>::value;
};


template <class, class, class, class = void>
struct updateItemID {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateItemID<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateItemID)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateItemID))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateItemID));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateItemID));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateItemID>::value != 
		function_uuid<(base_type)&Base::updateItemID>::value;
};


template <class, class, class, class = void>
struct hasGlowOutline {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct hasGlowOutline<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasGlowOutline)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasGlowOutline))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::hasGlowOutline));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::hasGlowOutline));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::hasGlowOutline>::value != 
		function_uuid<(base_type)&Base::hasGlowOutline>::value;
};


template <class, class, class, class = void>
struct setGlowOutline {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setGlowOutline<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowOutline)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOutline))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setGlowOutline));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setGlowOutline));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setGlowOutline>::value != 
		function_uuid<(base_type)&Base::setGlowOutline>::value;
};


template <class, class, class, class = void>
struct setFrames {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setFrames<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFrames)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFrames))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setFrames));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setFrames));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setFrames>::value != 
		function_uuid<(base_type)&Base::setFrames>::value;
};


template <class, class, class, class = void>
struct setValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setValue>::value != 
		function_uuid<(base_type)&Base::setValue>::value;
};


template <class, class, class, class = void>
struct setBarVisibility {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setBarVisibility<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBarVisibility)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBarVisibility))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setBarVisibility));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setBarVisibility));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setBarVisibility>::value != 
		function_uuid<(base_type)&Base::setBarVisibility>::value;
};


template <class, class, class, class = void>
struct getValue {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getValue<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getValue)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getValue))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getValue));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getValue));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getValue>::value != 
		function_uuid<(base_type)&Base::getValue>::value;
};


template <class, class, class, class = void>
struct updateBar {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct updateBar<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBar)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBar))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::updateBar));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::updateBar));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::updateBar>::value != 
		function_uuid<(base_type)&Base::updateBar>::value;
};


template <class, class, class, class = void>
struct getThumb {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct getThumb<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getThumb)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getThumb))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::getThumb));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::getThumb));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::getThumb>::value != 
		function_uuid<(base_type)&Base::getThumb>::value;
};


template <class, class, class, class = void>
struct textInputOpened {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textInputOpened<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputOpened)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputOpened))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputOpened));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputOpened));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textInputOpened>::value != 
		function_uuid<(base_type)&Base::textInputOpened>::value;
};


template <class, class, class, class = void>
struct textInputClosed {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textInputClosed<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputClosed)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputClosed))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputClosed));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputClosed));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textInputClosed>::value != 
		function_uuid<(base_type)&Base::textInputClosed>::value;
};


template <class, class, class, class = void>
struct textInputShouldOffset {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textInputShouldOffset<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputShouldOffset)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputShouldOffset))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputShouldOffset));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputShouldOffset));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textInputShouldOffset>::value != 
		function_uuid<(base_type)&Base::textInputShouldOffset>::value;
};


template <class, class, class, class = void>
struct textInputReturn {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct textInputReturn<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputReturn)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputReturn))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::textInputReturn));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::textInputReturn));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::textInputReturn>::value != 
		function_uuid<(base_type)&Base::textInputReturn>::value;
};


template <class, class, class, class = void>
struct allowTextInput {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct allowTextInput<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::allowTextInput)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allowTextInput))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::allowTextInput));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::allowTextInput));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::allowTextInput>::value != 
		function_uuid<(base_type)&Base::allowTextInput>::value;
};


template <class, class, class, class = void>
struct setupLeaderboard {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupLeaderboard<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLeaderboard)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLeaderboard))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupLeaderboard));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupLeaderboard));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupLeaderboard>::value != 
		function_uuid<(base_type)&Base::setupLeaderboard>::value;
};


template <class, class, class, class = void>
struct setupPageInfo {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct setupPageInfo<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupPageInfo)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupPageInfo))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::setupPageInfo));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::setupPageInfo));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::setupPageInfo>::value != 
		function_uuid<(base_type)&Base::setupPageInfo>::value;
};


template <class, class, class, class = void>
struct disableMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct disableMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::disableMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::disableMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::disableMenu>::value != 
		function_uuid<(base_type)&Base::disableMenu>::value;
};


template <class, class, class, class = void>
struct enableMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct enableMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::enableMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::enableMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::enableMenu>::value != 
		function_uuid<(base_type)&Base::enableMenu>::value;
};


template <class, class, class, class = void>
struct pCommand {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct pCommand<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pCommand)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pCommand))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::pCommand));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::pCommand));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::pCommand>::value != 
		function_uuid<(base_type)&Base::pCommand>::value;
};


template <class, class, class, class = void>
struct toggleCheckpointsMenu {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct toggleCheckpointsMenu<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleCheckpointsMenu)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleCheckpointsMenu))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::toggleCheckpointsMenu));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::toggleCheckpointsMenu));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::toggleCheckpointsMenu>::value != 
		function_uuid<(base_type)&Base::toggleCheckpointsMenu>::value;
};


template <class, class, class, class = void>
struct onCheck {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onCheck<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCheck)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCheck))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onCheck));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onCheck));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onCheck>::value != 
		function_uuid<(base_type)&Base::onCheck>::value;
};


template <class, class, class, class = void>
struct onDeleteCheck {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct onDeleteCheck<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeleteCheck)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteCheck))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::onDeleteCheck));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::onDeleteCheck));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::onDeleteCheck>::value != 
		function_uuid<(base_type)&Base::onDeleteCheck>::value;
};


template <class, class, class, class = void>
struct createWithTransformObjects {
	constexpr static inline bool value = false;
};

template <class Derived, class Base, class Ret, class ...Parameters>
struct createWithTransformObjects<Derived, Base, Ret(Parameters...), std::void_t<
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithTransformObjects)),
	decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTransformObjects))
>> {
private:
	using base_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Base::createWithTransformObjects));         
	using derived_type = decltype(substitute<Ret, Base, Derived, Parameters...>(&Derived::createWithTransformObjects));   
public:
	constexpr static inline bool value = 
		function_uuid<(derived_type)&Derived::createWithTransformObjects>::value != 
		function_uuid<(base_type)&Base::createWithTransformObjects>::value;
};

